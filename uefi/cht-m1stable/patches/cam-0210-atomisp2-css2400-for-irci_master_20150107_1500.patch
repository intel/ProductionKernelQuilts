From cf77f41258daeb8e02d4c62692caf383186020ee Mon Sep 17 00:00:00 2001
From: Pengpeng Cui <pengpengx.cui@intel.com>
Date: Thu, 8 Jan 2015 22:58:40 +0800
Subject: [PATCH 210/210] atomisp2: css2400 for irci_master_20150107_1500

Merge CSS2.1 for css2400  for
irci_master_20150107_1500 firmware

Change-Id: I82e9721c4fd2a1d37ead93ee62ee813048bb7d68
Tracked-On: https://jira01.devtools.intel.com/browse/IMINAN-16283
Signed-off-by: Pengpeng Cui <pengpengx.cui@intel.com>
Reviewed-on: https://icggerrit.ir.intel.com/35410
Approver: Wei Tao <wei.tao@intel.com>
Reviewed-by: Wei Tao <wei.tao@intel.com>
---
 .../camera/pipe/src/pipe_binarydesc.c              |   5 +
 .../pci/atomisp2/css2400b0_v21/css_api_version.h   |  14 +-
 .../media/pci/atomisp2/css2400b0_v21/css_trace.h   | 152 +++-
 .../ia_css_isp_params.c                            |  19 +-
 .../ia_css_isp_params.h                            |   4 +-
 .../ia_css_isp_states.c                            |  24 +
 .../ia_css_isp_states.h                            |   3 +
 .../hive_isp_css_include/host/isp_op1w.h           |  59 +-
 .../hive_isp_css_include/host/isp_op2w.h           |  58 +-
 .../hive_isp_css_include/host/isp_op_count.h       |  10 +-
 .../hive_isp_css_include/host/isys_irq_public.h    |  55 ++
 .../hive_isp_css_include/host/ref_vector_func.h    | 163 +++-
 .../host/ref_vector_func_types.h                   |  38 +-
 .../css2400b0_v21/hive_isp_css_include/isys_irq.h  |  50 ++
 .../hive_isp_css_include/math_support.h            |  39 +
 .../media/pci/atomisp2/css2400b0_v21/ia_css.h      |   4 +-
 .../pci/atomisp2/css2400b0_v21/ia_css_acc_types.h  |   2 +
 .../media/pci/atomisp2/css2400b0_v21/ia_css_err.h  |   2 +
 .../atomisp2/css2400b0_v21/ia_css_event_public.h   |  21 +-
 .../pci/atomisp2/css2400b0_v21/ia_css_host_data.h  |   4 +-
 .../atomisp2/css2400b0_v21/ia_css_memory_access.c  |   1 -
 .../atomisp2/css2400b0_v21/ia_css_pipe_public.h    |   4 +
 .../pci/atomisp2/css2400b0_v21/ia_css_timer.h      |  19 +-
 .../pci/atomisp2/css2400b0_v21/ia_css_types.h      |   4 +-
 .../atomisp2/css2400b0_v21/ia_css_version_data.h   |   2 +-
 .../isp/kernels/aa/aa_2/ia_css_aa2.host.c          |   8 +
 .../isp/kernels/aa/aa_2/ia_css_aa2.host.h          |   5 +
 .../isp/kernels/aa/aa_2/ia_css_aa2_param.h         |   1 -
 .../isp/kernels/aa/aa_2/ia_css_aa2_state.h         |  48 ++
 .../isp/kernels/bnlm/ia_css_bnlm.host.c            |  72 ++
 .../isp/kernels/bnlm/ia_css_bnlm.host.h            |  43 +
 .../isp/kernels/bnlm/ia_css_bnlm_param.h           |  36 +
 .../isp/kernels/bnlm/ia_css_bnlm_types.h           |  40 +
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.c        | 171 +++-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.h        |   8 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8_param.h       |  81 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8_state.h       |   8 +
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c   |   4 +-
 .../fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h   |   2 +-
 .../isp/kernels/hdr/ia_css_hdr.host.c              |   4 +-
 .../isp/kernels/hdr/ia_css_hdr.host.h              |   4 +-
 .../isp/kernels/hdr/ia_css_hdr_param.h             |   4 +-
 .../isp/kernels/hdr/ia_css_hdr_types.h             |   4 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.c      |  50 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.h      |   4 +-
 .../kernels/iefd2_6/ia_css_iefd2_6_default.host.c  |   8 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_param.h     |  12 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_state.h     |   6 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_types.h     |   8 +-
 .../io_ls/bayer_io_ls/ia_css_bayer_io_param.h      |  35 +
 .../isp/kernels/raw/raw_1.0/ia_css_raw.host.c      |  19 -
 .../isp/kernels/raw/raw_1.0/ia_css_raw.host.h      |  11 -
 .../isp/kernels/raw/raw_1.0/ia_css_raw_param.h     |   5 -
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c     |   4 +-
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h    |   6 +-
 .../isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.c   |  54 ++
 .../isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.h   |  38 +
 .../xnr/xnrvideo4/ia_css_xnr4_common_param.h       |  36 +
 .../xnr/xnrvideo4/ia_css_xnr4_downsample_param.h   |  45 +
 .../xnr/xnrvideo4/ia_css_xnr4_downsample_types.h   |  44 +
 .../xnr/xnrvideo4/ia_css_xnr4_edge_metric_param.h  |  32 +
 .../isp/kernels/xnr/xnrvideo4/ia_css_xnr4_param.h  |  30 +
 .../isp/kernels/xnr/xnrvideo4/ia_css_xnr4_types.h  |  29 +
 .../css2400b0_v21/isp/modes/interface/isp_const.h  |  83 +-
 .../isp/modes/interface/isp_defaults.h             |   4 -
 .../css2400b0_v21/isp/modes/interface/timer.isp.h  |  38 +
 .../css2400b0_v21/isp/modes/interface/trace.isp.h  | 176 ++++
 .../runtime/binary/interface/ia_css_binary.h       |   1 +
 .../css2400b0_v21/runtime/binary/src/binary.c      |  50 +-
 .../runtime/debug/interface/ia_css_debug.h         |   6 +
 .../css2400b0_v21/runtime/debug/src/ia_css_debug.c | 168 +++-
 .../css2400b0_v21/runtime/event/src/event.c        |   1 +
 .../css2400b0_v21/runtime/frame/src/frame.c        |  30 +-
 .../isp_param/interface/ia_css_isp_param_types.h   |   4 +-
 .../runtime/isp_param/src/isp_param.c              |  15 +-
 .../css2400b0_v21/runtime/isys/src/isys_init.c     |   6 +
 .../atomisp2/css2400b0_v21/runtime/isys/src/rx.c   |  14 -
 .../css2400b0_v21/runtime/pipeline/src/pipeline.c  |  11 +-
 .../css2400b0_v21/runtime/queue/src/queue.c        |   3 +
 .../tagger/interface/ia_css_tagger_common.h        |  50 ++
 .../media/pci/atomisp2/css2400b0_v21/sh_css.c      | 794 ++++++++++-------
 .../pci/atomisp2/css2400b0_v21/sh_css_firmware.c   |   4 +-
 .../pci/atomisp2/css2400b0_v21/sh_css_internal.h   |   1 +
 .../pci/atomisp2/css2400b0_v21/sh_css_params.c     | 241 ++----
 .../pci/atomisp2/css2400b0_v21/sh_css_params.h     |   6 +-
 .../media/pci/atomisp2/css2400b0_v21/sh_css_sp.c   |   3 +
 .../media/pci/atomisp2/css2400b0_v21/spmem_dump.c  | 952 +++++++++------------
 87 files changed, 3133 insertions(+), 1303 deletions(-)
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isys_irq_public.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/isys_irq.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_state.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/io_ls/bayer_io_ls/ia_css_bayer_io_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_common_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_edge_metric_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/timer.isp.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/trace.isp.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/tagger/interface/ia_css_tagger_common.h

diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c
index ae41372..05e21cc5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/camera/pipe/src/pipe_binarydesc.c
@@ -62,6 +62,7 @@ static void pipe_binarydesc_get_offline(
 	descr->enable_reduced_pipe = false;
 	descr->enable_dz = true;
 	descr->enable_xnr = false;
+	descr->enable_dpc = false;
 	descr->enable_fractional_ds = false;
 	descr->dvs_env.width = 0;
 	descr->dvs_env.height = 0;
@@ -320,6 +321,8 @@ enum ia_css_err ia_css_pipe_get_preview_binarydesc(
 	preview_descr->enable_fractional_ds =
 	    pipe->extra_config.enable_fractional_ds;
 
+	preview_descr->enable_dpc = pipe->config.enable_dpc;
+
 	preview_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
 	return IA_CSS_SUCCESS;
@@ -392,6 +395,8 @@ enum ia_css_err ia_css_pipe_get_video_binarydesc(
 		video_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 		video_descr->enable_fractional_ds =
 		    pipe->extra_config.enable_fractional_ds;
+		video_descr->enable_dpc =
+			pipe->config.enable_dpc;
 
 #if defined(IS_ISP_2500_SYSTEM)
 /*
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_api_version.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_api_version.h
index 07b5731..b8b6012 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_api_version.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_api_version.h
@@ -42,7 +42,7 @@ The version string has four dot-separated numbers, read left to right:
 
 */
 
-#define CSS_API_VERSION_STRING	"2.1.9.1"
+#define CSS_API_VERSION_STRING	"2.1.10.2"
 
 /*
 Change log
@@ -230,6 +230,18 @@ v2.1.9.1 (1 changes parallel), Exclude driver part from ia_css_buffer.h as it is
 - Excluded driver part of the interface from SP/ISP code
 - Driver I/F is not affected
 
+v2.1.9.2, added IA_CSS_EVENT_TYPE_TIMER
+- Added a new event called IA_CSS_EVENT_TYPE_TIMER
+
+v2.1.10.0 (2 changes parallel), Add a flag "enable_dpc" to "struct ia_css_pipe_config"
+- Add a flag "enable_dpc" to "struct ia_css_pipe_config"
+
+v2.1.10.2 (2 changes parallel), fix IEFD's puclic API types
+- fix IEFD public API members types: rad_cu6_x1,rad_cu_unsharp_x1 & unsharp_amount
+
+v2.1.10.2 (2 changes parallel), Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH
+- Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH enum to ia_css_fw_warning type
+
 */
 
 #endif /*__CSS_API_VERSION_H*/
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_trace.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_trace.h
index f568d86..6c0b2f4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_trace.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/css_trace.h
@@ -50,12 +50,110 @@ struct trace_header_t {
 	uint32_t  debug_ptr_value;
 };
 
-
-/* buffer offsets and sizes, common to SP and host */
+#define TRACER_VER			2
 #define TRACE_BUFF_ADDR       0xA000
 #define TRACE_BUFF_SIZE       0x1000	/* 4K allocated */
-#define SP1_TRACER_OFFSET     (TRACE_BUFF_SIZE/2)
-#define MAX_TRACER_POINTS     (TRACE_BUFF_SIZE/sizeof(struct trace_item_t))
+
+#ifdef IS_ISP_2500_SYSTEM
+#define TRACE_ENABLE_SP0 1
+#define TRACE_ENABLE_SP1 1
+#define TRACE_ENABLE_ISP 0
+#else
+#define TRACE_ENABLE_SP0 0
+#define TRACE_ENABLE_SP1 0
+#define TRACE_ENABLE_ISP 0
+#endif
+
+typedef enum {
+	TRACE_SP0_ID,
+	TRACE_SP1_ID,
+	TRACE_ISP_ID
+} TRACE_CORE_ID;
+
+/* TODO: add timing format? */
+typedef enum {
+	TRACE_DUMP_FORMAT_POINT,
+	TRACE_DUMP_FORMAT_VALUE24_HEX,
+	TRACE_DUMP_FORMAT_VALUE24_DEC,
+	TRACE_DUMP_FORMAT_VALUE24_TIMING,
+	TRACE_DUMP_FORMAT_VALUE24_TIMING_DELTA
+} TRACE_DUMP_FORMAT;
+
+
+/* currently divided as follows:*/
+#if (TRACE_ENABLE_SP0 + TRACE_ENABLE_SP1 + TRACE_ENABLE_ISP == 3)
+/* can be divided as needed */
+#define TRACE_SP0_SIZE (TRACE_BUFF_SIZE/4)
+#define TRACE_SP1_SIZE (TRACE_BUFF_SIZE/4)
+#define TRACE_ISP_SIZE (TRACE_BUFF_SIZE/2)
+#elif (TRACE_ENABLE_SP0 + TRACE_ENABLE_SP1 + TRACE_ENABLE_ISP == 2)
+#if TRACE_ENABLE_SP0
+#define TRACE_SP0_SIZE (TRACE_BUFF_SIZE/2)
+#else
+#define TRACE_SP0_SIZE (0)
+#endif
+#if TRACE_ENABLE_SP1
+#define TRACE_SP1_SIZE (TRACE_BUFF_SIZE/2)
+#else
+#define TRACE_SP1_SIZE (0)
+#endif
+#if TRACE_ENABLE_ISP
+#define TRACE_ISP_SIZE (TRACE_BUFF_SIZE/2)
+#else
+#define TRACE_ISP_SIZE (0)
+#endif
+#elif (TRACE_ENABLE_SP0 + TRACE_ENABLE_SP1 + TRACE_ENABLE_ISP == 1)
+#if TRACE_ENABLE_SP0
+#define TRACE_SP0_SIZE (TRACE_BUFF_SIZE)
+#else
+#define TRACE_SP0_SIZE (0)
+#endif
+#if TRACE_ENABLE_SP1
+#define TRACE_SP1_SIZE (TRACE_BUFF_SIZE)
+#else
+#define TRACE_SP1_SIZE (0)
+#endif
+#if TRACE_ENABLE_ISP
+#define TRACE_ISP_SIZE (TRACE_BUFF_SIZE)
+#else
+#define TRACE_ISP_SIZE (0)
+#endif
+#else
+#define TRACE_SP0_SIZE (0)
+#define TRACE_SP1_SIZE (0)
+#define TRACE_ISP_SIZE (0)
+#endif
+
+#define TRACE_SP0_ADDR (TRACE_BUFF_ADDR)
+#define TRACE_SP1_ADDR (TRACE_SP0_ADDR + TRACE_SP0_SIZE)
+#define TRACE_ISP_ADDR (TRACE_SP1_ADDR + TRACE_SP1_SIZE)
+
+/* check if it's a legal division */
+#if (TRACE_BUFF_SIZE < TRACE_SP0_SIZE + TRACE_SP1_SIZE + TRACE_ISP_SIZE)
+#error trace sizes are not divided correctly and are above limit
+#endif
+
+#define TRACE_SP0_HEADER_ADDR (TRACE_SP0_ADDR)
+#define TRACE_SP0_HEADER_SIZE (sizeof(struct trace_header_t))
+#define TRACE_SP0_ITEM_SIZE (sizeof(struct trace_item_t))
+#define TRACE_SP0_DATA_ADDR (TRACE_SP0_HEADER_ADDR + TRACE_SP0_HEADER_SIZE)
+#define TRACE_SP0_DATA_SIZE (TRACE_SP0_SIZE - TRACE_SP0_HEADER_SIZE)
+#define TRACE_SP0_MAX_POINTS (TRACE_SP0_DATA_SIZE / TRACE_SP0_ITEM_SIZE)
+
+#define TRACE_SP1_HEADER_ADDR (TRACE_SP1_ADDR)
+#define TRACE_SP1_HEADER_SIZE (sizeof(struct trace_header_t))
+#define TRACE_SP1_ITEM_SIZE (sizeof(struct trace_item_t))
+#define TRACE_SP1_DATA_ADDR (TRACE_SP1_HEADER_ADDR + TRACE_SP1_HEADER_SIZE)
+#define TRACE_SP1_DATA_SIZE (TRACE_SP1_SIZE - TRACE_SP1_HEADER_SIZE)
+#define TRACE_SP1_MAX_POINTS (TRACE_SP1_DATA_SIZE / TRACE_SP1_ITEM_SIZE)
+
+#define TRACE_ISP_HEADER_ADDR (TRACE_ISP_ADDR)
+#define TRACE_ISP_HEADER_SIZE (sizeof(struct trace_header_t))
+#define TRACE_ISP_ITEM_SIZE (sizeof(struct trace_item_t))
+#define TRACE_ISP_DATA_ADDR (TRACE_ISP_HEADER_ADDR + TRACE_ISP_HEADER_SIZE)
+#define TRACE_ISP_DATA_SIZE (TRACE_ISP_SIZE - TRACE_ISP_HEADER_SIZE)
+#define TRACE_ISP_MAX_POINTS (TRACE_ISP_DATA_SIZE / TRACE_ISP_ITEM_SIZE)
+
 
 /* offsets for master_port read/write */
 #define HDR_HDR_OFFSET              0	/* offset of the header */
@@ -83,4 +181,50 @@ typedef enum {
 /* command signature */
 #define CMD_SIGNATURE	0xAABBCC00
 
+/* shared macros in traces infrastructure */
+/* increment the pointer cyclicly */
+#define DBG_NEXT_ITEM(x, max_items) (((x+1) >= max_items) ? 0 : x+1)
+#define DBG_PREV_ITEM(x, max_items) ((x) ? x-1 : max_items-1)
+
+#define FIELD_MASK(width) (((1 << (width)) - 1))
+#define FIELD_PACK(value,mask,offset) (((value) & (mask)) << (offset))
+#define FIELD_UNPACK(value,mask,offset) (((value) >> (offset)) & (mask))
+
+
+#define FIELD_VALUE_OFFSET		(0)
+#define FIELD_VALUE_WIDTH		(16)
+#define FIELD_VALUE_MASK		FIELD_MASK(FIELD_VALUE_WIDTH)
+#define FIELD_VALUE_PACK(f)		FIELD_PACK(f,FIELD_VALUE_MASK,FIELD_VALUE_OFFSET)
+#define FIELD_VALUE_UNPACK(f)	FIELD_UNPACK(f,FIELD_VALUE_MASK,FIELD_VALUE_OFFSET)
+
+#define FIELD_MINOR_OFFSET		(FIELD_VALUE_OFFSET + FIELD_VALUE_WIDTH)
+#define FIELD_MINOR_WIDTH		(8)
+#define FIELD_MINOR_MASK		FIELD_MASK(FIELD_MINOR_WIDTH)
+#define FIELD_MINOR_PACK(f)		FIELD_PACK(f,FIELD_MINOR_MASK,FIELD_MINOR_OFFSET)
+#define FIELD_MINOR_UNPACK(f)	FIELD_UNPACK(f,FIELD_MINOR_MASK,FIELD_MINOR_OFFSET)
+
+#define FIELD_MAJOR_OFFSET		(FIELD_MINOR_OFFSET + FIELD_MINOR_WIDTH)
+#define FIELD_MAJOR_WIDTH		(5)
+#define FIELD_MAJOR_MASK		FIELD_MASK(FIELD_MAJOR_WIDTH)
+#define FIELD_MAJOR_PACK(f)		FIELD_PACK(f,FIELD_MAJOR_MASK,FIELD_MAJOR_OFFSET)
+#define FIELD_MAJOR_UNPACK(f)	FIELD_UNPACK(f,FIELD_MAJOR_MASK,FIELD_MAJOR_OFFSET)
+
+#define FIELD_FORMAT_OFFSET		(FIELD_MAJOR_OFFSET + FIELD_MAJOR_WIDTH)
+#define FIELD_FORMAT_WIDTH 		(3)
+#define FIELD_FORMAT_MASK 		FIELD_MASK(FIELD_FORMAT_WIDTH)
+#define FIELD_FORMAT_PACK(f)	FIELD_PACK(f,FIELD_FORMAT_MASK,FIELD_FORMAT_OFFSET)
+#define FIELD_FORMAT_UNPACK(f)	FIELD_UNPACK(f,FIELD_FORMAT_MASK,FIELD_FORMAT_OFFSET)
+
+#define FIELD_VALUE_24_OFFSET		(0)
+#define FIELD_VALUE_24_WIDTH		(24)
+#define FIELD_VALUE_24_MASK			FIELD_MASK(FIELD_VALUE_24_WIDTH)
+#define FIELD_VALUE_24_PACK(f)		FIELD_PACK(f,FIELD_VALUE_24_MASK,FIELD_VALUE_24_OFFSET)
+#define FIELD_VALUE_24_UNPACK(f)	FIELD_UNPACK(f,FIELD_VALUE_24_MASK,FIELD_VALUE_24_OFFSET)
+
+#define PACK_TRACEPOINT(format,major, minor, value)	\
+	(FIELD_FORMAT_PACK(format) | FIELD_MAJOR_PACK(major) | FIELD_MINOR_PACK(minor) | FIELD_VALUE_PACK(value))
+
+#define PACK_TRACE_VALUE24(format, major, value)	\
+	(FIELD_FORMAT_PACK(format) | FIELD_MAJOR_PACK(major) | FIELD_VALUE_24_PACK(value))
+
 #endif /* __CSS_TRACE_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c
index ad7040e..36b9e5d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.c
@@ -49,7 +49,6 @@
 #include "isp/kernels/ob/ob2/ia_css_ob2.host.h"
 #include "isp/kernels/ob/ob_1.0/ia_css_ob.host.h"
 #include "isp/kernels/output/output_1.0/ia_css_output.host.h"
-#include "isp/kernels/raw/raw_1.0/ia_css_raw.host.h"
 #include "isp/kernels/raw_aa_binning/raw_aa_binning_1.0/ia_css_raa.host.h"
 #include "isp/kernels/s3a/s3a_1.0/ia_css_s3a.host.h"
 #include "isp/kernels/sc/sc_1.0/ia_css_sc.host.h"
@@ -62,8 +61,10 @@
 #include "isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.h"
 #include "isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.h"
 #include "isp/kernels/xnr/xnrvideo4/ia_css_xnrvideo4.host.h"
+#include "isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.h"
 #include "isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h"
 #include "isp/kernels/ynr/ynr_2/ia_css_ynr2.host.h"
+#include "isp/kernels/bnlm/ia_css_bnlm.host.h"
 /* Generated code: do not edit or commmit. */
 
 #include "ia_css_pipeline.h"
@@ -937,7 +938,7 @@ size);
 /* Code generated by genparam/gencode.c:gen_process_function() */
 
 static void
-ia_css_process_raw(
+ia_css_process_bds(
 	unsigned pipe_id,
 	const struct ia_css_pipeline_stage *stage,
 	struct ia_css_isp_parameters *params)
@@ -945,21 +946,21 @@ ia_css_process_raw(
 	assert(params != NULL);
 
 	{
-		unsigned size   = stage->binary->info->mem_offsets.offsets.param->dmem.raw.size;
+		unsigned size   = stage->binary->info->mem_offsets.offsets.param->dmem.bds.size;
 
-		unsigned offset = stage->binary->info->mem_offsets.offsets.param->dmem.raw.offset;
+		unsigned offset = stage->binary->info->mem_offsets.offsets.param->dmem.bds.offset;
 
 		if (size) {
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_raw() enter:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bds() enter:\n");
 
-			ia_css_raw_encode((struct sh_css_isp_raw_params *)
+			ia_css_bds_encode((struct sh_css_isp_bds_params *)
 					&stage->binary->mem_params.params[IA_CSS_PARAM_CLASS_PARAM][IA_CSS_ISP_DMEM].address[offset],
-					&params->raw_config,
+					&params->bds_config,
 size);
 			params->isp_params_changed = true;
 			params->isp_mem_params_changed[pipe_id][stage->stage_num][IA_CSS_ISP_DMEM] = true;
 
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_raw() leave:\n");
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_bds() leave:\n");
 		}
 
 	}
@@ -1605,7 +1606,7 @@ void (* ia_css_kernel_process_param[IA_CSS_NUM_PARAMETER_IDS])(
 	ia_css_process_ob,
 	ia_css_process_output,
 	ia_css_process_sc,
-	ia_css_process_raw,
+	ia_css_process_bds,
 	ia_css_process_tnr,
 	ia_css_process_macc,
 	ia_css_process_sdis_horicoef,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.h
index ccec3da..50f650d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_params.h
@@ -53,7 +53,7 @@ enum ia_css_parameter_ids {
 	IA_CSS_OB_ID,
 	IA_CSS_OUTPUT_ID,
 	IA_CSS_SC_ID,
-	IA_CSS_RAW_ID,
+	IA_CSS_BDS_ID,
 	IA_CSS_TNR_ID,
 	IA_CSS_MACC_ID,
 	IA_CSS_SDIS_HORICOEF_ID,
@@ -102,7 +102,7 @@ struct ia_css_memory_offsets {
 		struct ia_css_isp_parameter ob;
 		struct ia_css_isp_parameter output;
 		struct ia_css_isp_parameter sc;
-		struct ia_css_isp_parameter raw;
+		struct ia_css_isp_parameter bds;
 		struct ia_css_isp_parameter tnr;
 		struct ia_css_isp_parameter macc;
 		struct ia_css_isp_parameter sdis_horiproj;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.c
index 2cf034a..42fb6d6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.c
@@ -29,6 +29,29 @@
 /* Code generated by genparam/genstate.c:gen_init_function() */
 
 static void
+ia_css_initialize_aa_state(
+	const struct ia_css_binary *binary)
+{
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_aa_state() enter:\n");
+
+	{
+		unsigned size   = binary->info->mem_offsets.offsets.state->vmem.aa.size;
+
+		unsigned offset = binary->info->mem_offsets.offsets.state->vmem.aa.offset;
+
+		if (size) {
+			ia_css_init_aa_state(
+				&binary->mem_params.params[IA_CSS_PARAM_CLASS_STATE][IA_CSS_ISP_VMEM].address[offset],
+				size);
+		}
+
+	}
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_initialize_aa_state() leave:\n");
+}
+
+/* Code generated by genparam/genstate.c:gen_init_function() */
+
+static void
 ia_css_initialize_cnr_state(
 	const struct ia_css_binary *binary)
 {
@@ -190,6 +213,7 @@ ia_css_initialize_ynr_state(
 /* Code generated by genparam/genstate.c:gen_state_init_table() */
 
 void (* ia_css_kernel_init_state[IA_CSS_NUM_STATE_IDS])(const struct ia_css_binary *binary) = {
+	ia_css_initialize_aa_state,
 	ia_css_initialize_cnr_state,
 	ia_css_initialize_cnr2_state,
 	ia_css_initialize_dp_state,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.h
index 83fb709..56ee6d6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_2400_system_generated/ia_css_isp_states.h
@@ -21,6 +21,7 @@
 
 #define IA_CSS_INCLUDE_STATES
 #include "ia_css_memory_access.h"
+#include "isp/kernels/aa/aa_2/ia_css_aa2.host.h"
 #include "isp/kernels/cnr/cnr_1.0/ia_css_cnr.host.h"
 #include "isp/kernels/cnr/cnr_2/ia_css_cnr2.host.h"
 #include "isp/kernels/de/de_1.0/ia_css_de.host.h"
@@ -36,6 +37,7 @@
 /* Code generated by genparam/gencode.c:gen_param_enum() */
 
 enum ia_css_state_ids {
+	IA_CSS_AA_STATE_ID,
 	IA_CSS_CNR_STATE_ID,
 	IA_CSS_CNR2_STATE_ID,
 	IA_CSS_DP_STATE_ID,
@@ -50,6 +52,7 @@ enum ia_css_state_ids {
 
 struct ia_css_state_memory_offsets {
 	struct {
+		struct ia_css_isp_parameter aa;
 		struct ia_css_isp_parameter cnr;
 		struct ia_css_isp_parameter cnr2;
 		struct ia_css_isp_parameter dp;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op1w.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op1w.h
index 61f314c..a0c1b71 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op1w.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op1w.h
@@ -173,22 +173,57 @@ STORAGE_CLASS_ISP_OP1W_FUNC_H tvector1w OP_1w_subsat(
     const tvector1w     _a,
     const tvector1w     _b);
 
-/** @brief subtraction with shift right
+/** @brief subtraction with shift right and rounding
  *
  * @param[in] _a	first argument
  * @param[in] _b	second argument
  *
  * @return		(a - b) >> 1
  *
- * This function will subtract _b from _a at full
- * precision, and right shift the result with 1 bit.
+ * This function subtracts _b from _a and right shifts
+ * the result by 1 bit with rounding.
  * No overflow can occur.
  * result = (_a - _b) >> 1
+ *
+ * Note: This function will be deprecated due to
+ * the naming confusion and it will be replaced
+ * by "OP_1w_subhalfrnd".
  */
 STORAGE_CLASS_ISP_OP1W_FUNC_H tvector1w OP_1w_subasr1(
     const tvector1w     _a,
     const tvector1w     _b);
 
+/** @brief Subtraction with shift right and rounding
+ *
+ * @param[in] _a	first operand
+ * @param[in] _b	second operand
+ *
+ * @return		(_a - _b) >> 1
+ *
+ * This function subtracts _b from _a and right shifts
+ * the result by 1 bit with rounding.
+ * No overflow can occur.
+ */
+STORAGE_CLASS_ISP_OP1W_FUNC_H tvector1w OP_1w_subhalfrnd(
+    const tvector1w	_a,
+    const tvector1w	_b);
+
+/** @brief Subtraction with shift right and no rounding
+ *
+ * @param[in] _a	first operand
+ * @param[in] _b	second operand
+ *
+ * @return		(_a - _b) >> 1
+ *
+ * This function subtracts _b from _a and right shifts
+ * the result by 1 bit without rounding (i.e. truncation).
+ * No overflow can occur.
+ */
+STORAGE_CLASS_ISP_OP1W_FUNC_H tvector1w OP_1w_subhalf(
+    const tvector1w	_a,
+    const tvector1w	_b);
+
+
 /** @brief saturated absolute value
  *
  * @param[in] _a	input
@@ -667,7 +702,23 @@ STORAGE_CLASS_ISP_OP1W_FUNC_H tvector1w OP_1w_mux(
     const tvector1w     _b,
     const tflags           _c);
 
-/** @brief Average
+/** @brief Average without rounding
+ *
+ * @param[in] _a	first operand
+ * @param[in] _b	second operand
+ *
+ * @return		(_a + _b) >> 1
+ *
+ * This function will add _a and _b, and right shift
+ * the result by one without rounding. No overflow
+ * will occur because addition is performed in the
+ * proper precision.
+ */
+STORAGE_CLASS_ISP_OP1W_FUNC_H tvector1w  OP_1w_avg(
+    const tvector1w     _a,
+    const tvector1w     _b);
+
+/** @brief Average with rounding
  *
  * @param[in] _a	first argument
  * @param[in] _b	second argument
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op2w.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op2w.h
index eef03d8..ec49942 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op2w.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op2w.h
@@ -172,22 +172,56 @@ STORAGE_CLASS_ISP_OP2W_FUNC_H tvector2w OP_2w_subsat(
     const tvector2w     _a,
     const tvector2w     _b);
 
-/** @brief subtraction with shift right
+/** @brief subtraction with shift right and rounding
  *
  * @param[in] _a	first argument
  * @param[in] _b	second argument
  *
  * @return		(a - b) >> 1
  *
- * This function will subtract _b from _a at full
- * precision, and right shift the result with 1 bit.
+ * This function subtracts _b from _a and right shifts
+ * the result by 1 bit with rounding.
  * No overflow can occur.
  * result = (_a - _b) >> 1
+ *
+ * Note: This function will be deprecated due to
+ * the naming confusion and it will be replaced
+ * by "OP_2w_subhalfrnd".
  */
 STORAGE_CLASS_ISP_OP2W_FUNC_H tvector2w OP_2w_subasr1(
     const tvector2w     _a,
     const tvector2w     _b);
 
+/** @brief Subtraction with shift right and rounding
+ *
+ * @param[in] _a	first operand
+ * @param[in] _b	second operand
+ *
+ * @return		(_a - _b) >> 1
+ *
+ * This function subtracts _b from _a and right shifts
+ * the result by 1 bit with rounding.
+ * No overflow can occur.
+ */
+STORAGE_CLASS_ISP_OP2W_FUNC_H tvector2w OP_2w_subhalfrnd(
+    const tvector2w	_a,
+    const tvector2w	_b);
+
+/** @brief Subtraction with shift right and no rounding
+ *
+ * @param[in] _a	first operand
+ * @param[in] _b	second operand
+ *
+ * @return		(_a - _b) >> 1
+ *
+ * This function subtracts _b from _a and right shifts
+ * the result by 1 bit without rounding (i.e. truncation).
+ * No overflow can occur.
+ */
+STORAGE_CLASS_ISP_OP2W_FUNC_H tvector2w OP_2w_subhalf(
+    const tvector2w	_a,
+    const tvector2w	_b);
+
 /** @brief saturated absolute value
  *
  * @param[in] _a	input
@@ -575,7 +609,23 @@ STORAGE_CLASS_ISP_OP2W_FUNC_H tvector2w OP_2w_mux(
     const tvector2w     _b,
     const tflags           _c);
 
-/** @brief Average
+/** @brief Average without rounding
+ *
+ * @param[in] _a	first operand
+ * @param[in] _b	second operand
+ *
+ * @return		(_a + _b) >> 1
+ *
+ * This function will add _a and _b, and right shift
+ * the result by one without rounding. No overflow
+ * will occur because addition is performed in the
+ * proper precision.
+ */
+STORAGE_CLASS_ISP_OP2W_FUNC_H tvector2w  OP_2w_avg(
+    const tvector2w     _a,
+    const tvector2w     _b);
+
+/** @brief Average with rounding
  *
  * @param[in] _a	first argument
  * @param[in] _b	second argument
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op_count.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op_count.h
index a3dfbfd..095f994 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op_count.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isp_op_count.h
@@ -25,9 +25,9 @@
 #include <stdio.h>
 
 typedef struct {
-	int bbb_cnt;   /* number of bbb      */
+	long long bbb_cnt;   /* number of bbb      */
 	int bbb_op;    /* operations per bbb */
-	int total_cnt; /* bbb_cnt * bbb_op   */
+	long long total_cnt; /* bbb_cnt * bbb_op   */
 } bbb_stat_t;
 
 typedef enum {
@@ -40,6 +40,8 @@ typedef enum {
 	bbb_func_OP_1w_addsat,
 	bbb_func_OP_1w_subsat,
 	bbb_func_OP_1w_subasr1,
+	bbb_func_OP_1w_subhalf,
+	bbb_func_OP_1w_subhalfrnd,
 	bbb_func_OP_1w_abs,
 	bbb_func_OP_1w_subabssat,
 	bbb_func_OP_1w_muld,
@@ -70,6 +72,7 @@ typedef enum {
 	bbb_func_OP_1w_mod,
 	bbb_func_OP_1w_sqrt_u,
 	bbb_func_OP_1w_mux,
+	bbb_func_OP_1w_avg,
 	bbb_func_OP_1w_avgrnd,
 	bbb_func_OP_1w_min,
 	bbb_func_OP_1w_max,
@@ -82,6 +85,8 @@ typedef enum {
 	bbb_func_OP_2w_addsat,
 	bbb_func_OP_2w_subsat,
 	bbb_func_OP_2w_subasr1,
+	bbb_func_OP_2w_subhalf,
+	bbb_func_OP_2w_subhalfrnd,
 	bbb_func_OP_2w_abs,
 	bbb_func_OP_2w_subabssat,
 	bbb_func_OP_2w_mul,
@@ -106,6 +111,7 @@ typedef enum {
 	bbb_func_OP_2w_mod,
 	bbb_func_OP_2w_sqrt_u,
 	bbb_func_OP_2w_mux,
+	bbb_func_OP_2w_avg,
 	bbb_func_OP_2w_avgrnd,
 	bbb_func_OP_2w_min,
 	bbb_func_OP_2w_max,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isys_irq_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isys_irq_public.h
new file mode 100644
index 0000000..258bc73
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/isys_irq_public.h
@@ -0,0 +1,55 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __ISYS_IRQ_PUBLIC_H__
+#define __ISYS_IRQ_PUBLIC_H__
+
+#include "isys_irq_global.h"
+#include "isys_irq_local.h"
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+
+STORAGE_CLASS_ISYS2401_IRQ_H void isys_irqc_state_get(
+	const isys_irq_ID_t	isys_irqc_id,
+	isys_irqc_state_t	*state);
+
+STORAGE_CLASS_ISYS2401_IRQ_H void isys_irqc_state_dump(
+	const isys_irq_ID_t	isys_irqc_id,
+	const isys_irqc_state_t *state);
+
+STORAGE_CLASS_ISYS2401_IRQ_H void isys_irqc_reg_store(
+	const isys_irq_ID_t	isys_irqc_id,
+	const unsigned int	reg_idx,
+	const hrt_data		value);
+
+STORAGE_CLASS_ISYS2401_IRQ_H hrt_data isys_irqc_reg_load(
+	const isys_irq_ID_t	isys_irqc_id,
+	const unsigned int	reg_idx);
+
+STORAGE_CLASS_ISYS2401_IRQ_H void isys_irqc_status_enable(
+	const isys_irq_ID_t	isys_irqc_id);
+
+#endif /* defined(USE_INPUT_SYSTEM_VERSION_2401) */
+
+#endif	/* __ISYS_IRQ_PUBLIC_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func.h
index 04e99e1..2329958 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func.h
@@ -1,7 +1,7 @@
 /*
  * INTEL CONFIDENTIAL
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
+ * Copyright (C) 2010 - 2014 Intel Corporation.
  * All Rights Reserved.
  *
  * The source code contained or described herein and all documents
@@ -90,6 +90,20 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_mul_realigning(
 	tvector1w b,
 	tscalar1w shift );
 
+/** @brief Leading bit index
+ *
+ * @param[in] a 	input
+ *
+ * @return		index of the leading bit of each element
+ *
+ * This function finds the index of leading one (set) bit of the
+ * input. The index starts with 0 for the LSB and can go upto
+ * ISP_VEC_ELEMBITS-1 for the MSB. For an input equal to zero,
+ * the returned index is -1.
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_lod(
+		tvector1w a);
+
 /** @brief Config Unit Input Processing
  *
  * @param[in] a 	    input
@@ -178,7 +192,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_piecewise_estimation(
  * is filled for y_offset and X-prev_values. */
 
 STORAGE_CLASS_REF_VECTOR_FUNC_H ref_config_point_vectors XCU_LUT_create(
-	ref_config_points config_points);
+	xcu_ref_config_points config_points);
 
 /** @brief XCU Fast Config Unit Piecewise linear estimation
  *
@@ -193,12 +207,12 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H ref_config_point_vectors XCU_LUT_create(
  * (approximated to the nearest power of 2 (upper bound)). This is done to have a
  * fast division operation to identify the interval of input x. Once the
  * interval of the input is idenitfied, its config data is retrieved from the
- * LUT and output y is calculated. Input points less than x1 are treated as
- * simple case of using first y_offset as the output.
+ * LUT and output y is calculated. Input points equal to x1 and xn are treated as
+ * simple cases of using their offset value as the output.
  */
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_X_piecewise_estimation(
 	tvector1w x,
-	ref_config_points config_points,
+	xcu_ref_config_points config_points,
 	ref_config_point_vectors init_vectors);
 
 /** @brief OP_1w_XCU Wrapper function for XCU LUT create, piecewise estimation and output clamping
@@ -214,7 +228,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_X_piecewise_estimation(
  **/
 STORAGE_CLASS_REF_VECTOR_FUNC_H  tvector1w OP_1w_XCU(
 	tvector1w x,
-	ref_config_points config_points);
+	xcu_ref_config_points config_points);
 
 
 /** @brief Coring
@@ -474,12 +488,149 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x5m_12dB_nrm (
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir5x5m_12dB_nrm (
 	const s_1w_5x5_matrix m);
 
+/** @brief Approximate averaging FIR 1x5
+ *
+ * @param[in] m	1x5 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will produce filtered output by
+ * applying the filter coefficients (1/8) * [1,1,1,1,1]
+ * _______
+ *   5 vector operations
+*/
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x5m_box (
 	s_1w_1x5_matrix m);
 
+/** @brief Approximate averaging FIR 1x9
+ *
+ * @param[in] m	1x9 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will produce filtered output by
+ * applying the filter coefficients (1/16) * [1,1,1,1,1,1,1,1,1]
+ * _______
+ *   9 vector operations
+*/
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x9m_box (
 	s_1w_1x9_matrix m);
 
+/** @brief Approximate averaging FIR 1x11
+ *
+ * @param[in] m	1x11 matrix with pixels
+ *
+ * @return		filtered output
+ *
+ * This function will produce filtered output by
+ * applying the filter coefficients (1/16) * [1,1,1,1,1,1,1,1,1,1,1]
+ * _______
+ *   12 vector operations
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x11m_box (
+	s_1w_1x11_matrix m);
+
+/** @brief Symmetric 7 tab filter with normalization
+ *
+ *  @param[in] in 1x7 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
+ *  @param[in] out_shift output pixel shift value for normalization
+ *
+ *  @return symmetric 7 tab filter output
+ *
+ * This function performs symmetric 7 tab filter over input pixels.
+ * Filter sum is normalized by shifting out_shift bits.
+ * Filter sum: p0*c3 + p1*c2 + p2*c1 + p3*c0 + p4*c1 + p5*c2 + p6*c3
+ * is implemented as: (p0 + p6)*c3 + (p1 + p5)*c2 + (p2 + p4)*c1 + p3*c0 to
+ * reduce multiplication.
+ * Input pixels should to be scaled, otherwise overflow is possible during
+ * addition
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x7m_sym_nrm(s_1w_1x7_matrix in,
+		s_1w_1x4_matrix coeff,
+		tvector1w out_shift);
+
+/** @brief approximation for Symmetric 4 tap filter(-1,9,9,-1) with normalization
+ *
+ *  @param[in] in 1x4 matrix with pixels
+ *
+ *  @return 4 tap filter output
+ *
+ * this function is used by xnr4 upscale2
+ *
+ * This function performs 4 tap filter over input pixels.
+ * Filter sum is normalized by shifting out_shift bits.
+ * Filter sum: p0*c0 + p1*c1 + p2*c2 + p3*c3
+ * The coeeficients are -1, 9, 9, -1 with shift of 4
+ * The below implementation is the approximation that consumes less cycles.
+ *
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x4m_sym_nrm_minus1_9_9_minus1_appr(s_1w_1x4_matrix in);
+
+/** @brief 4 tap filter with normalization
+ *
+ *  @param[in] in 1x4 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
+ *  @param[in] out_shift output pixel shift value for normalization
+ *
+ *  @return 4 tap filter output
+ *
+ * This function performs 4 tap filter over input pixels.
+ * Filter sum is normalized by shifting out_shift bits.
+ * Filter sum: p0*c0 + p1*c1 + p2*c2 + p3*c3
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x4m_nrm(s_1w_1x4_matrix in,
+		s_1w_1x4_matrix coeff,
+		tvector1w out_shift);
+
+/** @brief Symmetric 3 tab filter with normalization
+ *
+ *  @param[in] in 1x3 matrix with pixels
+ *  @param[in] coeff 1x2 matrix with coefficients
+ *  @param[in] out_shift output pixel shift value for normalization
+ *
+ *  @return symmetric 3 tab filter output
+ *
+ * This function performs symmetric 3 tab filter input pixels.
+ * Filter sum is normalized by shifting out_shift bits.
+ * Filter sum: p0*c1 + p1*c0 + p2*c1
+ * is implemented as: (p0 + p2)*c1 + p1*c0 to reduce multiplication.
+ * Input pixels should to be scaled, otherwise overflow is possible during
+ * addition
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x3m_sym_nrm(s_1w_1x3_matrix in,
+		s_1w_1x2_matrix coeff,
+		tvector1w out_shift);
+
+/** @brief Absolute gradient between two sets of 1x5 yuv matrices
+ *
+ *  @param[in] in0_y	1x5 matrix with y components of the first set of pixels
+ *  @param[in] in0_u	1x5 matrix with u components of the first set of pixels
+ *  @param[in] in0_v	1x5 matrix with v components of the first set of pixels
+ *  @param[in] in1_y	1x5 matrix with y components of the second set of pixels
+ *  @param[in] in1_u	1x5 matrix with u components of the second set of pixels
+ *  @param[in] in1_v	1x5 matrix with v components of the second set of pixels
+ *
+ *  @return absolute gradient
+ *
+ * This function finds the absolute gradient between two sets of 1x5 YUV
+ * vectors, that is basically |(Y1+U1+V1) - (Y2+U2+V2)|. Since addition
+ * and subtraction operations could overflow, "avgrnd" is used instead of
+ * "add" and "subhalfrnd" is used instead of "sub". Thus, all intermediate
+ * results are rounded.
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+gradabs1x5_yuv(s_1w_1x5_matrix in0_y,
+	    s_1w_1x5_matrix in0_u,
+	    s_1w_1x5_matrix in0_v,
+	    s_1w_1x5_matrix in1_y,
+	    s_1w_1x5_matrix in1_u,
+	    s_1w_1x5_matrix in1_v);
+
 /** @brief Mean of 1x3 matrix
  *
  *  @param[in] m 1x3 matrix with pixels
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func_types.h
index a1f7a31..9454231 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/host/ref_vector_func_types.h
@@ -1,7 +1,7 @@
 /*
  * INTEL CONFIDENTIAL
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
+ * Copyright (C) 2010 - 2014 Intel Corporation.
  * All Rights Reserved.
  *
  * The source code contained or described herein and all documents
@@ -42,7 +42,7 @@
 #define INPUT_SCALE_FACTOR 10
 #define OUTPUT_SCALE_FACTOR 10
 #define SLOPE_A_RESOLUTION 10
-#define CONFIG_UNIT_LUT_SIZE 32 /*XCU works for ISP_NWAY = 32 */
+#define CONFIG_UNIT_LUT_SIZE_32 32 /*XCU works for ISP_NWAY = 32 */
 
 #define ONE_IN_Q14 (1<<(NUM_BITS-2))
 #define Q29_TO_Q15_SHIFT_VAL (NUM_BITS-2)
@@ -81,7 +81,7 @@ typedef short tscalar1w_5bit_signed;         /* tscalar1w in interval [-2^(5-1),
 typedef unsigned short tscalar1w_5bit;       /* tscalar1w in interval [0, 2^5)                       */
 typedef short tscalar1w_range1wbit;          /* tscalar1w in interval [-NUM_BITS, NUM_BITS]          */
 typedef short tscalar1w_unsigned_range1wbit; /* tscalar1w in interval [0, NUM_BITS]                  */
-typedef unsigned short tvector_8bit;
+typedef unsigned short tvector_8bit;		/* 8 bit positive number */
 typedef unsigned short tvector_5bit;
 typedef unsigned short tvector_4bit;
 typedef unsigned short tscalar1w_16bit;
@@ -93,6 +93,11 @@ typedef struct {
 } s_1w_2x1_matrix;
 
 typedef struct {
+	tvector1w v00;
+	tvector1w v01;
+} s_1w_1x2_matrix;
+
+typedef struct {
   tvector1w     v00  ;
   tvector1w     v01 ;
   tvector1w     v02 ;
@@ -225,15 +230,36 @@ typedef struct {
 } s_1w_7x7_matrix;
 
 typedef struct {
+	tvector1w v0_0;
+	tvector1w v0_1;
+	tvector1w v0_2;
+	tvector1w v0_3;
+	tvector1w v0_4;
+	tvector1w v0_5;
+	tvector1w v0_6;
+	tvector1w v0_7;
+	tvector1w v0_8;
+	tvector1w v0_9;
+	tvector1w v0_10;
+} s_1w_1x11_matrix;
+
+typedef struct {
 	tvector1w x_cord[MAX_CONFIG_POINTS];
 	tvector1w slope[MAX_CONFIG_POINTS-1];
 	tvector1w y_offset[MAX_CONFIG_POINTS-1];
 } ref_config_points;
 
 typedef struct {
-	tscalar1w_16bit slope_vec[CONFIG_UNIT_LUT_SIZE];
-	tscalar1w_16bit offset_vec[CONFIG_UNIT_LUT_SIZE];
-	tscalar1w_16bit x_cord_vec[CONFIG_UNIT_LUT_SIZE];
+	tvector1w x_cord[MAX_CONFIG_POINTS];
+	tvector1w slope[MAX_CONFIG_POINTS-1];
+	tvector1w y_offset[MAX_CONFIG_POINTS];
+	tscalar1w_16bit slope_resolution;
+} xcu_ref_config_points;
+
+typedef struct {
+	tscalar1w_16bit slope_vec[CONFIG_UNIT_LUT_SIZE_32];
+	tscalar1w_16bit offset_vec[CONFIG_UNIT_LUT_SIZE_32];
+	tscalar1w_16bit x_cord_vec[CONFIG_UNIT_LUT_SIZE_32];
 	tscalar1w_16bit exponent;
 } ref_config_point_vectors;
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/isys_irq.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/isys_irq.h
new file mode 100644
index 0000000..c43c1d1
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/isys_irq.h
@@ -0,0 +1,50 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#ifndef __IA_CSS_ISYS_IRQ_H__
+#define __IA_CSS_ISYS_IRQ_H__
+
+#include <type_support.h>
+#include <storage_class.h>
+#include <system_local.h>
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+
+#ifndef __INLINE_ISYS2401_IRQ__
+
+#define STORAGE_CLASS_ISYS2401_IRQ_H STORAGE_CLASS_EXTERN
+#define STORAGE_CLASS_ISYS2401_IRQ_C STORAGE_CLASS_EXTERN
+#include "isys_irq_public.h"
+
+#else  /* __INLINE_ISYS2401_IRQ__ */
+
+#define STORAGE_CLASS_ISYS2401_IRQ_H STORAGE_CLASS_INLINE
+#define STORAGE_CLASS_ISYS2401_IRQ_C STORAGE_CLASS_INLINE
+#include "isys_irq_private.h"
+
+#endif /* __INLINE_ISYS2401_IRQ__ */
+
+#endif /* defined(USE_INPUT_SYSTEM_VERSION_2401) */
+
+#endif	/* __IA_CSS_ISYS_IRQ_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/math_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/math_support.h
index 471da10..a8a6937 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/math_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/hive_isp_css_include/math_support.h
@@ -142,6 +142,45 @@ STORAGE_CLASS_INLINE unsigned int ceil_shift_mul(unsigned int a, unsigned int b)
 	return CEIL_SHIFT_MUL(a, b);
 }
 
+
+/** @brief Next Power of Two
+ *
+ *  @param[in] unsigned number
+ *
+ *  @return next power of two
+ *
+ * This function rounds input to the nearest power of 2 (2^x)
+ * towards infinity
+ *
+ * Input Range: 0 .. 2^(8*sizeof(int)-1)
+ *
+ * IF input is a power of 2
+ *     out = in
+ * OTHERWISE
+ *     out = 2^(ceil(log2(in))
+ *
+ */
+
+STORAGE_CLASS_INLINE unsigned int ceil_pow2(unsigned int a)
+{
+	if (a == 0) {
+		return 1;
+	}
+	/* IF input is already a power of two*/
+	else if ((!((a)&((a)-1)))) {
+		return a;
+	}
+	else {
+		unsigned int v = a;
+		v |= v>>1;
+		v |= v>>2;
+		v |= v>>4;
+		v |= v>>8;
+		v |= v>>16;
+		return (v+1);
+	}
+}
+
 #endif /* !defined(PIPE_GENERATION) */
 
 #if !defined(__ISP) && !defined(__SP)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h
index e0d8a1c..c28bf5e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141129_0200 */
-/* Release Version: irci_master_20141129_0200 */
+/* Release Version: irci_master_20150107_1500 */
+/* Release Version: irci_master_20150107_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h
index 25020b9..3ebf8cf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_acc_types.h
@@ -279,6 +279,7 @@ struct ia_css_binary_info {
 		uint8_t	in_frame;
 		uint8_t	out_frame;
 		uint8_t	high_speed;
+		uint8_t	dpc;
 		uint8_t padding[2];
 	} enable;
 	struct {
@@ -354,6 +355,7 @@ struct ia_css_sp_info {
 	uint32_t ddr_parameter_size;    /**< acc param size, sp dmem */
 	/* Entry functions */
 	uint32_t sp_entry;	/**< The SP entry function */
+	uint32_t tagger_frames_addr;   /**< Base address of tagger state */
 };
 
 /* The following #if is there because this header file is also included
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h
index e4da5ec..8561689 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_err.h
@@ -80,6 +80,8 @@ enum ia_css_fw_warning {
 		This warning can be avoided by unlocking locked frame-buffers more timely. */
 	IA_CSS_FW_WARNING_TAG_EXP_ID_FAILED, /** < Exposure ID cannot be found on the circular buffer.
 		This warning can be avoided by unlocking locked frame-buffers more timely. */
+	IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH, /** < Frame and param pair mismatched in tagger.
+		This warning can be avoided by providing a param set for each frame. */
 };
 
 #endif /* __IA_CSS_ERR_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_event_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_event_public.h
index 587bb78..58cc5d7 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_event_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_event_public.h
@@ -29,6 +29,7 @@
 #include <type_support.h>	/* uint8_t */
 #include <ia_css_err.h>		/* ia_css_err */
 #include <ia_css_types.h>	/* ia_css_pipe */
+#include <ia_css_timer.h>	/* ia_css_timer */
 
 /** The event type, distinguishes the kind of events that
  * can are generated by the CSS system.
@@ -64,13 +65,16 @@ enum ia_css_event_type {
 	/**< Indication that LACE statistics are available. */
 	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE		= 1 << 11,
 	/**< Extension stage complete. */
-	IA_CSS_EVENT_TYPE_PORT_EOF			= 1 << 12,
+	IA_CSS_EVENT_TYPE_TIMER				= 1 << 12,
+	/**< Timer event for measuring the SP side latencies. It contains the
+             32-bit timer value from the SP */
+	IA_CSS_EVENT_TYPE_PORT_EOF			= 1 << 13,
 	/**< End Of Frame event, sent when in buffered sensor mode. */
-	IA_CSS_EVENT_TYPE_FW_ERROR			= 1 << 13,
+	IA_CSS_EVENT_TYPE_FW_ERROR			= 1 << 14,
 	/**< @deprecated{Unrecoverable error encounter by FW } */
-	IA_CSS_EVENT_TYPE_FW_WARNING			= 1 << 14,
+	IA_CSS_EVENT_TYPE_FW_WARNING			= 1 << 15,
 	/**< Performance warning encounter by FW */
-	IA_CSS_EVENT_TYPE_FW_ASSERT			= 1 << 15,
+	IA_CSS_EVENT_TYPE_FW_ASSERT			= 1 << 16,
 	/**< Assertion hit by FW */
 };
 
@@ -135,6 +139,15 @@ struct ia_css_event {
 	/**< Firmware module id, only for ASSERT events, should be logged by driver. */
 	uint16_t               fw_assert_line_no;
 	/**< Firmware line number, only for ASSERT events, should be logged by driver. */
+	clock_value_t	       timer_data;
+	/**< For storing the full 32-bit of the timer value. Valid only for TIMER
+	     event */
+	uint8_t                timer_code;
+	/**< For storing the code of the TIMER event. Valid only for
+	     TIMER event */
+	uint8_t                timer_subcode;
+	/**< For storing the subcode of the TIMER event. Valid only
+	     for TIMER event */
 };
 
 /** @brief Dequeue a PSYS event from the CSS system.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h
index c15d92b..d46a75a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_host_data.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141129_0200 */
-/* Release Version: irci_master_20141129_0200 */
+/* Release Version: irci_master_20150107_1500 */
+/* Release Version: irci_master_20150107_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_memory_access.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_memory_access.c
index a1aa8bb..9f2492e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_memory_access.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_memory_access.c
@@ -61,7 +61,6 @@ hrt_vaddress mmgr_alloc_attr(const size_t size, const uint16_t attrs)
 		my_attrs |= IA_CSS_MEM_ATTR_PAGEALIGN;
 
 	ptr = my_env.alloc(size, my_attrs);
-	assert(ptr != 0);
 	return ptr;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_pipe_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_pipe_public.h
index 771be57..0ecbbea 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_pipe_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_pipe_public.h
@@ -98,6 +98,9 @@ struct ia_css_pipe_config {
 	/**< Disabling digital zoom for a pipeline, if this is set to false,
 	     then setting a zoom factor will have no effect.
 	     In some use cases this provides better performance. */
+	bool enable_dpc;
+	/**< Disabling "Defect Pixel Correction" for a pipeline, if this is set
+	     to false. In some use cases this provides better performance. */
 	struct ia_css_isp_config *p_isp_config;
 	/**< Pointer to ISP configuration */
 };
@@ -124,6 +127,7 @@ struct ia_css_pipe_config {
 	IA_CSS_FRAME_DELAY_1,			/* dvs_frame_delay */ \
 	-1,					/* acc_num_execs */ \
 	false,					/* enable_dz */ \
+	false,					/* enable_dpc */ \
 	NULL					/* p_isp_config */\
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_timer.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_timer.h
index 36803c3..7836069 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_timer.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_timer.h
@@ -31,18 +31,31 @@
 /** @brief timer reading definition */
 typedef uint32_t clock_value_t;
 
-/** @brief 32 bit clock tick,(measured time in ticks)*/
+/** @brief 32 bit clock tick,(timestamp based on timer-value of CSS-internal timer)*/
 struct ia_css_clock_tick {
 	clock_value_t ticks; /**< measured time in ticks.*/
 };
 
-/** @brief  code measurement common struct */
+/** @brief TIMER event codes */
+enum ia_css_tm_event {
+	IA_CSS_TM_EVENT_AFTER_INIT,
+	/**< Timer Event after Initialization */
+	IA_CSS_TM_EVENT_MAIN_END,
+	/**< Timer Event after end of Main */
+	IA_CSS_TM_EVENT_THREAD_START,
+	/**< Timer Event after thread start */
+	IA_CSS_TM_EVENT_FRAME_PROC_START,
+	/**< Timer Event after Frame Process Start */
+	IA_CSS_TM_EVENT_FRAME_PROC_END
+	/**< Timer Event after Frame Process End */
+};
+
+/** @brief code measurement common struct */
 struct ia_css_time_meas {
 	clock_value_t	start_timer_value;	/**< measured time in ticks */
 	clock_value_t	end_timer_value;	/**< measured time in ticks */
 };
 
-
 /**@brief SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT checks to ensure correct alignment for struct ia_css_clock_tick. */
 #define SIZE_OF_IA_CSS_CLOCK_TICK_STRUCT sizeof(clock_value_t)
 /** @brief checks to ensure correct alignment for ia_css_time_meas. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h
index 7017de7..ff1cd6d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141129_0200 */
-/* Release Version: irci_master_20141129_0200 */
+/* Release Version: irci_master_20150107_1500 */
+/* Release Version: irci_master_20150107_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h
index 7f5b031..eeeecac 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/ia_css_version_data.h
@@ -29,7 +29,7 @@
 #define __IA_CSS_VERSION_DATA_H
 
 
-#define CSS_VERSION_STRING "REL:20141129_48.6_0251; API:2.1.9.1; GIT:irci_20141128_0200__94adaf#94adaf3c1a865d281381ceb0a4bae42f1448d77a; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
+#define CSS_VERSION_STRING "REL:20150107_02.3_1541; API:2.1.10.2; GIT:irci_20150106_0200__0cfebc#0cfebcfd820d99478df95508b7f102ba7df0fd95; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
 
 
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.c
index 2ea93f0..8dd4eab 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.c
@@ -47,6 +47,14 @@ ia_css_aa_encode(
 	to->strength = from->strength;
 }
 
+void
+ia_css_init_aa_state(
+	void *state,
+	size_t size)
+{
+	memset(state, 0, size);
+}
+
 #ifndef IA_CSS_NO_DEBUG
 void
 ia_css_aa_dump(
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.h
index 642fbc1..092a508 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2.host.h
@@ -37,6 +37,11 @@ ia_css_aa_encode(
 	const struct ia_css_aa_config *from,
 	unsigned size);
 
+void
+ia_css_init_aa_state(
+	void *state,
+	size_t size);
+
 #ifndef IA_CSS_NO_DEBUG
 void
 ia_css_aa_dump(
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_param.h
index 658a614..4282b54 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_param.h
@@ -24,7 +24,6 @@
 
 #include "type_support.h"
 
-/* Anti-Aliasing */
 struct sh_css_isp_aa_params {
 	int32_t strength;
 };
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_state.h
new file mode 100644
index 0000000..10bda03
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/aa/aa_2/ia_css_aa2_state.h
@@ -0,0 +1,48 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_AA2_STATE_H
+#define __IA_CSS_AA2_STATE_H
+
+#include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
+
+/* Denotes the maximum number of pixels per line that can be processed:
+* MAX_AA_VECTORS_PER_LINE  = maximum_line_width / ISP_NWAY */
+#ifndef MAX_AA_VECTORS_PER_LINE
+#error Please define MAX_AA_VECTORS_PER_LINE.
+#endif
+
+/* This uses 2 history lines for both y, u and v*/
+#define AA_STATE_Y_BUFFER_HEIGHT	2
+#define AA_STATE_UV_BUFFER_HEIGHT	2
+#define AA_STATE_Y_BUFFER_WIDTH		MAX_AA_VECTORS_PER_LINE
+/* The number of u and v elements is half y due to yuv420 downsampling. */
+#define AA_STATE_UV_BUFFER_WIDTH	(AA_STATE_Y_BUFFER_WIDTH/2)
+
+
+struct ia_css_isp_aa_vmem_state {
+	VMEM_ARRAY(y[AA_STATE_Y_BUFFER_HEIGHT], AA_STATE_Y_BUFFER_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(u[AA_STATE_UV_BUFFER_HEIGHT], AA_STATE_UV_BUFFER_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(v[AA_STATE_UV_BUFFER_HEIGHT], AA_STATE_UV_BUFFER_WIDTH*ISP_NWAY);
+};
+
+#endif /* __IA_CSS_AA2_STATE_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
new file mode 100644
index 0000000..a5c249e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
@@ -0,0 +1,72 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#include "type_support.h"
+#include "ia_css_bnlm.host.h"
+
+#ifndef IA_CSS_NO_DEBUG
+#include "ia_css_debug.h" /* ia_css_debug_dtrace() */
+#endif
+
+/* ToDo: add all the parameters of BNLM
+ * Presently only few parameters are added, as other parameter names are not
+ * clear in KFS and prm files. */
+
+/* Default kernel parameters. */
+const struct ia_css_bnlm_config default_bnlm_config = {
+	0,
+	0,
+	0,
+	0,
+	0
+};
+
+void
+ia_css_bnlm_encode(
+	struct sh_css_isp_bnlm_params *to,
+	const struct ia_css_bnlm_config *from,
+	size_t size)
+{
+	(void)size;
+	to->rad_enable = from->rad_enable;
+	to->rad_x_origin = from->rad_x_origin;
+	to->rad_y_origin = from->rad_y_origin;
+	to->avg_min_th = from->avg_min_th;
+	to->avg_max_th = from->avg_max_th;
+}
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnlm_debug_trace(
+	const struct ia_css_bnlm_config *bnlm,
+	unsigned level)
+{
+	if (!bnlm)
+		return;
+
+	ia_css_debug_dtrace(level, "BNLM:\n");
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rad_enable", bnlm->rad_enable);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rad_x_origin", bnlm->rad_x_origin);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "rad_y_origin", bnlm->rad_y_origin);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "avg_min_th", bnlm->avg_min_th);
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "avg_max_th", bnlm->avg_max_th);
+}
+#endif /* IA_CSS_NO_DEBUG */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.h
new file mode 100644
index 0000000..9439bd5
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm.host.h
@@ -0,0 +1,43 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNLM_HOST_H
+#define __IA_CSS_BNLM_HOST_H
+
+#include "ia_css_bnlm_types.h"
+#include "ia_css_bnlm_param.h"
+
+extern const struct ia_css_bnlm_config default_bnlm_config;
+
+void
+ia_css_bnlm_encode(
+	struct sh_css_isp_bnlm_params *to,
+	const struct ia_css_bnlm_config *from,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_bnlm_debug_trace(
+	const struct ia_css_bnlm_config *config,
+	unsigned level);
+#endif
+
+#endif /* __IA_CSS_BNLM_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
new file mode 100644
index 0000000..17fa9dc
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
@@ -0,0 +1,36 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNLM_PARAM_H
+#define __IA_CSS_BNLM_PARAM_H
+
+#include "type_support.h"
+
+/* BNLM ISP parameters */
+struct sh_css_isp_bnlm_params {
+	int32_t	rad_enable;
+	int32_t rad_x_origin;
+	int32_t rad_y_origin;
+	uint32_t avg_min_th;
+	uint32_t avg_max_th;
+};
+
+#endif /* __IA_CSS_BNLM_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
new file mode 100644
index 0000000..5ed737a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
@@ -0,0 +1,40 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BNLM_TYPES_H
+#define __IA_CSS_BNLM_TYPES_H
+
+#include "type_support.h" /* int32_t */
+
+/**
+ * \brief BNLM public parameters.
+ * \details Struct with all parameters for the BNLM kernel that can be set
+ * from the CSS API.
+ */
+struct ia_css_bnlm_config {
+	int32_t	rad_enable;
+	int32_t rad_x_origin;
+	int32_t rad_y_origin;
+	uint32_t avg_min_th;
+	uint32_t avg_max_th;
+};
+
+#endif /* __IA_CSS_BNLM_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
index 3b48556..b3bb509 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
@@ -25,12 +25,167 @@
 #endif
 
 #include "type_support.h"
+#include "assert_support.h"
 
 #include "ia_css_eed1_8.host.h"
 
+/* WARNING: Number of inv points should be less or equal to 16,
+ * due to implementation limitation. See kernel design document
+ * for more details.
+ */
+#define NUMBER_OF_CHGRINV_POINTS 15
+#define NUMBER_OF_TCINV_POINTS 9
+#define NUMBER_OF_FCINV_POINTS 9
+
+const int16_t chgrinv_x[NUMBER_OF_CHGRINV_POINTS] = {
+0, 16, 64, 144, 272, 448, 672, 976,
+1376, 1888, 2528, 3312, 4256, 5376, 6688};
+
+const int16_t chgrinv_a[NUMBER_OF_CHGRINV_POINTS] = {
+-7171, -256, -29, -3456, -1071, -475, -189, -102,
+-48, -38, -10, -9, -7, -6, 0};
+
+const int16_t chgrinv_b[NUMBER_OF_CHGRINV_POINTS] = {
+8191, 1021, 256, 114, 60, 37, 24, 17,
+12, 9, 6, 5, 4, 3, 2};
+
+const int16_t chgrinv_c[NUMBER_OF_CHGRINV_POINTS] = {
+1, 1, 1, 0, 0, 0, 0, 0,
+0, 0, 0, 0, 0, 0, 0};
+
+const int16_t tcinv_x[NUMBER_OF_TCINV_POINTS] = {
+0, 4, 11, 23, 42, 68, 102, 148, 205};
+
+const int16_t tcinv_a[NUMBER_OF_TCINV_POINTS] = {
+-6364, -631, -126, -34, -13, -6, -4452, -2156, 0};
+
+const int16_t tcinv_b[NUMBER_OF_TCINV_POINTS] = {
+8191, 1828, 726, 352, 197, 121, 80, 55, 40};
+
+const int16_t tcinv_c[NUMBER_OF_TCINV_POINTS] = {
+1, 1, 1, 1, 1, 1, 0, 0, 0};
+
+const int16_t fcinv_x[NUMBER_OF_FCINV_POINTS] = {
+0, 80, 216, 456, 824, 1344, 2040, 2952, 4096};
+
+const int16_t fcinv_a[NUMBER_OF_FCINV_POINTS] = {
+-5244, -486, -86, -2849, -961, -400, -180, -86, 0};
+
+const int16_t fcinv_b[NUMBER_OF_FCINV_POINTS] = {
+8191, 1637, 607, 287, 159, 98, 64, 44, 32};
+
+const int16_t fcinv_c[NUMBER_OF_FCINV_POINTS] = {
+1, 1, 1, 0, 0, 0, 0, 0, 0};
+
+
+void
+ia_css_eed1_8_vmem_encode(
+	struct ia_css_isp_eed1_8_vmem_params *to,
+	const struct ia_css_eed1_8_config *from,
+	size_t size)
+{
+	unsigned i, j, base;
+	const unsigned total_blocks = 4;
+	const unsigned shuffle_block = 16;
+
+	(void)size;
+
+	/* Init */
+	for (i = 0; i < ISP_VEC_NELEMS; i++) {
+		to->e_cuedge_x[0][i] = 0;
+		to->e_cuedge_a[0][i] = 0;
+		to->e_cuedge_b[0][i] = 0;
+		to->chgrinv_x[0][i] = 0;
+		to->chgrinv_a[0][i] = 0;
+		to->chgrinv_b[0][i] = 0;
+		to->chgrinv_c[0][i] = 0;
+		to->tcinv_x[0][i] = 0;
+		to->tcinv_a[0][i] = 0;
+		to->tcinv_b[0][i] = 0;
+		to->tcinv_c[0][i] = 0;
+		to->fcinv_x[0][i] = 0;
+		to->fcinv_a[0][i] = 0;
+		to->fcinv_b[0][i] = 0;
+		to->fcinv_c[0][i] = 0;
+	}
+
+	/* Constraints on dew_enhance_seg_x and dew_enhance_seg_y:
+	 * - values should be greater or equal to 0.
+	 * - values should be ascending.
+	 * - value of index zero is equal to 0.
+	 */
+
+	/* Checking constraints: */
+	/* TODO: investigate if an assert is the right way to report that
+	 * the constraints are violated.
+	 */
+	for (j = 0; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
+		assert(from->dew_enhance_seg_x[j] > -1);
+		assert(from->dew_enhance_seg_y[j] > -1);
+	}
+
+	for (j = 1; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
+		assert(from->dew_enhance_seg_x[j] > from->dew_enhance_seg_x[j-1]);
+		assert(from->dew_enhance_seg_y[j] > from->dew_enhance_seg_y[j-1]);
+	}
+
+	assert(from->dew_enhance_seg_x[0] == 0);
+	assert(from->dew_enhance_seg_y[0] == 0);
+
+	/* The implementation of the calulating 1/x is based on the availability
+	 * of the OP_vec_shuffle16 operation.
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* TODO: guard this code with above assumptions */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block * i;
+
+		for (j = 0; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
+			to->e_cuedge_x[0][base + j] = from->dew_enhance_seg_x[j];
+			to->e_cuedge_b[0][base + j] = from->dew_enhance_seg_y[j];
+		}
+
+		/* TODO: the calculation of the slope is not included in the KFS.
+		 * Till implementation is available the result of the slope calculation is
+		 * mulitplied with 1024 (just to increase the precision of the slope, since
+		 * the slopes for the default set of x and y is between 0 and 3.
+		 */
+		for (j = 1; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
+			to->e_cuedge_a[0][base + j - 1] = 1024 * (from->dew_enhance_seg_y[j] - from->dew_enhance_seg_y[j - 1]) / (from->dew_enhance_seg_x[j] - from->dew_enhance_seg_x[j - 1]);
+		}
+
+		/* Hard-coded to 0, see KFS for more details */
+		to->e_cuedge_a[0][base + IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1] = 0;
+
+		for (j = 0; j < NUMBER_OF_CHGRINV_POINTS; j++) {
+			to->chgrinv_x[0][base + j] = chgrinv_x[j];
+			to->chgrinv_a[0][base + j] = chgrinv_a[j];
+			to->chgrinv_b[0][base + j] = chgrinv_b[j];
+			to->chgrinv_c[0][base + j] = chgrinv_c[j];
+		}
+
+		for (j = 0; j < NUMBER_OF_TCINV_POINTS; j++) {
+			to->tcinv_x[0][base + j] = tcinv_x[j];
+			to->tcinv_a[0][base + j] = tcinv_a[j];
+			to->tcinv_b[0][base + j] = tcinv_b[j];
+			to->tcinv_c[0][base + j] = tcinv_c[j];
+		}
+
+		for (j = 0; j < NUMBER_OF_FCINV_POINTS; j++) {
+			to->fcinv_x[0][base + j] = fcinv_x[j];
+			to->fcinv_a[0][base + j] = fcinv_a[j];
+			to->fcinv_b[0][base + j] = fcinv_b[j];
+			to->fcinv_c[0][base + j] = fcinv_c[j];
+		}
+	}
+}
+
+
 void
 ia_css_eed1_8_encode(
-	struct ia_css_isp_eed1_8_params *to,
+	struct ia_css_isp_eed1_8_dmem_params *to,
 	const struct ia_css_eed1_8_config *from,
 	size_t size)
 {
@@ -53,23 +208,27 @@ ia_css_eed1_8_encode(
 
 	to->derel_thres0 = from->derel_thres0;
 	to->derel_gain0 = from->derel_gain0;
-	to->derel_thres1 = from->derel_thres1;
-	to->derel_gain1 = from->derel_gain1;
+	to->derel_thres_diff = (from->derel_thres1 - from->derel_thres0);
+	to->derel_gain_diff = (from->derel_gain1 - from->derel_gain0);
 
 	to->coring_pos0 = from->coring_pos0;
 	to->coring_pos_diff = (from->coring_pos1 - from->coring_pos0);
 	to->coring_neg0 = from->coring_neg0;
 	to->coring_neg_diff = (from->coring_neg1 - from->coring_neg0);
 
-	to->gain = (1 << from->gain_exp);
+	/* Note: (ISP_VEC_ELEMBITS -1)
+	 * TODO: currently the testbench does not support to use
+	 * ISP_VEC_ELEMBITS. Investigate how to fix this
+	 */
+	to->gain_exp = (13 - from->gain_exp);
 	to->gain_pos0 = from->gain_pos0;
 	to->gain_pos_diff = (from->gain_pos1 - from->gain_pos0);
 	to->gain_neg0 = from->gain_neg0;
 	to->gain_neg_diff = (from->gain_neg1 - from->gain_neg0);
 
-	to->pos_margin0 = from->pos_margin0;
+	to->margin_pos0 = from->pos_margin0;
 	to->margin_pos_diff = (from->pos_margin1 - from->pos_margin0);
-	to->neg_margin0 = from->neg_margin0;
+	to->margin_neg0 = from->neg_margin0;
 	to->margin_neg_diff = (from->neg_margin1 - from->neg_margin0);
 
 	for (i = 0; i < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; i++) {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
index 053bd1e..50c9424 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
@@ -27,8 +27,14 @@
 #include "ia_css_eed1_8_default.host.h"
 
 void
+ia_css_eed1_8_vmem_encode(
+	struct ia_css_isp_eed1_8_vmem_params *to,
+	const struct ia_css_eed1_8_config *from,
+	size_t size);
+
+void
 ia_css_eed1_8_encode(
-	struct ia_css_isp_eed1_8_params *to,
+	struct ia_css_isp_eed1_8_dmem_params *to,
 	const struct ia_css_eed1_8_config *from,
 	size_t size);
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
index 11282c8..ce93a84 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
@@ -23,14 +23,34 @@
 #define __IA_CSS_EED1_8_PARAM_H
 
 #include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
 
 #include "ia_css_eed1_8_types.h" /* IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS */
 
+
+/* Configuration parameters: */
+
+/* Enable median for false color correction
+ * 0: Do not use median
+ * 1: Use median
+ * Default: 1
+ */
+#define EED1_8_FC_ENABLE_MEDIAN		1
+
+/* Coring Threshold minima
+ * Used in Tint color suppression.
+ * Default: ??
+ */
+/* TODO: Find propper value for this parameter.
+ * KFS currently does not specify this.
+ */
+#define EED1_8_CORINGTHMIN	1024
+
 /* Define size of the state..... TODO: check if this is the correct place */
 /* 4 planes : GR, R, B, GB */
 #define NUM_PLANES	4
-/* 5 lines state per color plane input_line_state */
-#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(4 * NUM_PLANES)
+/* 6 lines state per color plane input_line_state */
+#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(5 * NUM_PLANES)
 
 /* ToDo: Move this to testsetup */
 #define MAX_FRAME_SIMDWIDTH	30
@@ -38,10 +58,35 @@
 /* Each plane has width equal to half frame line */
 #define EED1_8_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
+/* 2 lines state per color plane LD_H state */
+#define EED1_8_STATE_LD_H_HEIGHT	(2 * NUM_PLANES)
+#define EED1_8_STATE_LD_H_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+/* 2 lines stater per color plane LD_V state */
+#define EED1_8_STATE_LD_V_HEIGHT	(2 * NUM_PLANES)
+#define EED1_8_STATE_LD_V_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+/* 2 lines (single plane) state for D_Hr state */
+#define EED1_8_STATE_D_HR_HEIGHT	1
+#define EED1_8_STATE_D_HR_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+/* 3 lines (single plane) state for D_Hb state */
+#define EED1_8_STATE_D_HB_HEIGHT	2
+#define EED1_8_STATE_D_HB_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+/* 3 lines (single plane) state for D_Vr state */
+#define EED1_8_STATE_D_VR_HEIGHT	2
+#define EED1_8_STATE_D_VR_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
+/* 2 lines (single plane) state for D_Vb state */
+#define EED1_8_STATE_D_VB_HEIGHT	1
+#define EED1_8_STATE_D_VB_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
+
 /* 3 lines state for R and B (= 2 planes) rb_zipped_state */
 #define EED1_8_STATE_RB_ZIPPED_HEIGHT	(2 * 2)
 #define EED1_8_STATE_RB_ZIPPED_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
+#if EED1_8_FC_ENABLE_MEDIAN
 /* 1 full input line (GR-R color line) for Yc state */
 #define EED1_8_STATE_YC_HEIGHT	1
 #define EED1_8_STATE_YC_WIDTH	MAX_FRAME_SIMDWIDTH
@@ -57,10 +102,28 @@
 /* 1 full input line (GR-R color line) for AbsK state */
 #define EED1_8_STATE_ABSK_HEIGHT	1
 #define EED1_8_STATE_ABSK_WIDTH		MAX_FRAME_SIMDWIDTH
-
+#endif
+
+struct ia_css_isp_eed1_8_vmem_params {
+	VMEM_ARRAY(e_cuedge_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cuedge_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_cuedge_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(chgrinv_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(chgrinv_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(chgrinv_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(chgrinv_c, ISP_VEC_NELEMS);
+	VMEM_ARRAY(fcinv_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(fcinv_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(fcinv_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(fcinv_c, ISP_VEC_NELEMS);
+	VMEM_ARRAY(tcinv_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(tcinv_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(tcinv_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(tcinv_c, ISP_VEC_NELEMS);
+};
 
 /* EED (Edge Enhancing Demosaic) ISP parameters */
-struct ia_css_isp_eed1_8_params {
+struct ia_css_isp_eed1_8_dmem_params {
 	int32_t rbzp_strength;
 
 	int32_t fcstrength;
@@ -76,23 +139,23 @@ struct ia_css_isp_eed1_8_params {
 
 	int32_t derel_thres0;
 	int32_t derel_gain0;
-	int32_t derel_thres1;
-	int32_t derel_gain1;
+	int32_t derel_thres_diff;
+	int32_t derel_gain_diff;
 
 	int32_t coring_pos0;
 	int32_t coring_pos_diff;
 	int32_t coring_neg0;
 	int32_t coring_neg_diff;
 
-	int32_t gain;
+	int32_t gain_exp;
 	int32_t gain_pos0;
 	int32_t gain_pos_diff;
 	int32_t gain_neg0;
 	int32_t gain_neg_diff;
 
-	int32_t pos_margin0;
+	int32_t margin_pos0;
 	int32_t margin_pos_diff;
-	int32_t neg_margin0;
+	int32_t margin_neg0;
 	int32_t margin_neg_diff;
 
 	int32_t dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
index 6acce37..6a1771c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/eed1_8/ia_css_eed1_8_state.h
@@ -29,11 +29,19 @@
 
 struct ia_css_isp_eed1_8_vmem_state {
 	VMEM_ARRAY(eed1_8_input_lines[EED1_8_STATE_INPUT_BUFFER_HEIGHT], EED1_8_STATE_INPUT_BUFFER_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(eed1_8_LD_H[EED1_8_STATE_LD_H_HEIGHT], EED1_8_STATE_LD_H_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(eed1_8_LD_V[EED1_8_STATE_LD_V_HEIGHT], EED1_8_STATE_LD_V_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(eed1_8_D_Hr[EED1_8_STATE_D_HR_HEIGHT], EED1_8_STATE_D_HR_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(eed1_8_D_Hb[EED1_8_STATE_D_HB_HEIGHT], EED1_8_STATE_D_HB_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(eed1_8_D_Vr[EED1_8_STATE_D_VR_HEIGHT], EED1_8_STATE_D_VR_WIDTH*ISP_NWAY);
+	VMEM_ARRAY(eed1_8_D_Vb[EED1_8_STATE_D_VB_HEIGHT], EED1_8_STATE_D_VB_WIDTH*ISP_NWAY);
 	VMEM_ARRAY(eed1_8_rb_zipped[EED1_8_STATE_RB_ZIPPED_HEIGHT], EED1_8_STATE_RB_ZIPPED_WIDTH*ISP_NWAY);
+#if EED1_8_FC_ENABLE_MEDIAN
 	VMEM_ARRAY(eed1_8_Yc[EED1_8_STATE_YC_HEIGHT], EED1_8_STATE_YC_WIDTH*ISP_NWAY);
 	VMEM_ARRAY(eed1_8_Cg[EED1_8_STATE_CG_HEIGHT], EED1_8_STATE_CG_WIDTH*ISP_NWAY);
 	VMEM_ARRAY(eed1_8_Co[EED1_8_STATE_CO_HEIGHT], EED1_8_STATE_CO_WIDTH*ISP_NWAY);
 	VMEM_ARRAY(eed1_8_AbsK[EED1_8_STATE_ABSK_HEIGHT], EED1_8_STATE_ABSK_WIDTH*ISP_NWAY);
+#endif
 };
 
 #endif /* __IA_CSS_EED1_8_STATE_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
index 3cb5e35..da84966 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.c
@@ -37,10 +37,10 @@ ia_css_bds_encode(
 
 void
 ia_css_bds_dump(
-	const struct sh_css_isp_bds_params *raw,
+	const struct sh_css_isp_bds_params *bds,
 	unsigned level)
 {
-	(void)raw;
+	(void)bds;
 	(void)level;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
index 560e7b4..a86b223 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h
@@ -33,7 +33,7 @@ ia_css_bds_encode(
 
 void
 ia_css_bds_dump(
-	const struct sh_css_isp_bds_params *raw,
+	const struct sh_css_isp_bds_params *bds,
 	unsigned level);
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c
index 4df820a..3602f8d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.c
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141129_0200 */
-/* Release Version: irci_master_20141129_0200 */
+/* Release Version: irci_master_20150107_1500 */
+/* Release Version: irci_master_20150107_1500 */
 /*
  * INTEL CONFIDENTIAL
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h
index c612448..cfb1994 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr.host.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141129_0200 */
-/* Release Version: irci_master_20141129_0200 */
+/* Release Version: irci_master_20150107_1500 */
+/* Release Version: irci_master_20150107_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h
index 7a3fa16..6251b89 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_param.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141129_0200 */
-/* Release Version: irci_master_20141129_0200 */
+/* Release Version: irci_master_20150107_1500 */
+/* Release Version: irci_master_20150107_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h
index 9682816..ae19a69 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/hdr/ia_css_hdr_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20141129_0200 */
-/* Release Version: irci_master_20141129_0200 */
+/* Release Version: irci_master_20150107_1500 */
+/* Release Version: irci_master_20150107_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
index 1a90419..924a520 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
@@ -28,7 +28,7 @@
  */
 void
 ia_css_iefd2_6_vmem_encode(
-	struct ia_css_isp_iefd2_6_vmem_params *to,
+	struct iefd2_6_vmem_params *to,
 	const struct ia_css_iefd2_6_config *from,
 	size_t size)
 {
@@ -72,52 +72,52 @@ ia_css_iefd2_6_vmem_encode(
 
 		to->e_cued_x[0][base] = 0;
 		to->e_cued_a[0][base] = 0;
-		to->e_cued_b[0][base] = from->cu_ed_slopes_b[1];
+		to->e_cued_b[0][base] = from->cu_ed_slopes_b[0];
 
 		to->e_cu_dir_x[0][base] = 0;
 		to->e_cu_dir_a[0][base] = 0;
-		to->e_cu_dir_b[0][base] = from->cu_dir_sharp_slopes_b[1];
+		to->e_cu_dir_b[0][base] = from->cu_dir_sharp_slopes_b[0];
 
 		to->e_cu_non_dir_x[0][base] = 0;
 		to->e_cu_non_dir_a[0][base] = 0;
-		to->e_cu_non_dir_b[0][base] = from->cu_non_dir_sharp_slopes_b[1];
+		to->e_cu_non_dir_b[0][base] = from->cu_non_dir_sharp_slopes_b[0];
 
 		to->e_curad_x[0][base] = 0;
 		to->e_curad_a[0][base] = 0;
-		to->e_curad_b[0][base] = from->cu_radial_slopes_b[1];
+		to->e_curad_b[0][base] = from->cu_radial_slopes_b[0];
 
 		for (j = 1; j < 4; j++) {
-			to->e_cu_dir_a[0][base+j] = from->cu_dir_sharp_slopes_a[j];
-			to->e_cu_dir_b[0][base+j] = from->cu_dir_sharp_slopes_b[j];
-			to->e_cu_non_dir_a[0][base+j] = from->cu_non_dir_sharp_slopes_a[j];
-			to->e_cu_non_dir_b[0][base+j] = from->cu_non_dir_sharp_slopes_b[j];
+			to->e_cu_dir_a[0][base+j] = from->cu_dir_sharp_slopes_a[j-1];
+			to->e_cu_dir_b[0][base+j] = from->cu_dir_sharp_slopes_b[j-1];
+			to->e_cu_non_dir_a[0][base+j] = from->cu_non_dir_sharp_slopes_a[j-1];
+			to->e_cu_non_dir_b[0][base+j] = from->cu_non_dir_sharp_slopes_b[j-1];
 		}
 
 		for (j = 1; j < 5; j++) {
-			to->e_cu_dir_x[0][base+j] = from->cu_dir_sharp_points_x[j];
-			to->e_cu_non_dir_x[0][base+j] = from->cu_non_dir_sharp_points_x[j];
+			to->e_cu_dir_x[0][base+j] = from->cu_dir_sharp_points_x[j-1];
+			to->e_cu_non_dir_x[0][base+j] = from->cu_non_dir_sharp_points_x[j-1];
 		}
 
 
 		for (j = 1; j < 6; j++) {
-			to->e_cued_x[0][base+j] = from->cu_ed_points_x[j];
-			to->e_cued_a[0][base+j] = from->cu_ed_slopes_a[j];
-			to->e_cued_b[0][base+j] = from->cu_ed_slopes_b[j];
+			to->e_cued_x[0][base+j] = from->cu_ed_points_x[j-1];
+			to->e_cued_a[0][base+j] = from->cu_ed_slopes_a[j-1];
+			to->e_cued_b[0][base+j] = from->cu_ed_slopes_b[j-1];
 		}
-		to->e_cued_x[0][base+6] = from->cu_ed_points_x[j];
+		to->e_cued_x[0][base+6] = from->cu_ed_points_x[5];
 
 		for (j = 1; j < 6; j++) {
-			to->e_curad_x[0][base+j] = from->cu_radial_points_x[j];
-			to->e_curad_a[0][base+j] = from->cu_radial_slopes_a[j];
-			to->e_curad_b[0][base+j] = from->cu_radial_slopes_b[j];
+			to->e_curad_x[0][base+j] = from->cu_radial_points_x[j-1];
+			to->e_curad_a[0][base+j] = from->cu_radial_slopes_a[j-1];
+			to->e_curad_b[0][base+j] = from->cu_radial_slopes_b[j-1];
 		}
-		to->e_curad_x[0][base+6] = from->cu_radial_points_x[j];
+		to->e_curad_x[0][base+6] = from->cu_radial_points_x[5];
 	}
 }
 
 void
 ia_css_iefd2_6_encode(
-	struct ia_css_isp_iefd2_6_dmem_params *to,
+	struct iefd2_6_dmem_params *to,
 	const struct ia_css_iefd2_6_config *from,
 	size_t size)
 {
@@ -145,10 +145,10 @@ ia_css_iefd2_6_encode(
 	to->rad_cu_dir_sharp_x1		= from->rad_cu_dir_sharp_x1;
 	to->rad_cu_non_dir_sharp_x1	= from->rad_cu_non_dir_sharp_x1;
 	to->rad_dir_far_sharp_weight	= from->rad_dir_far_sharp_weight;
-	to->shrpn_nega_lmt_txt		= from->shrpn_nega_lmt_txt;
-	to->shrpn_posi_lmt_txt		= from->shrpn_posi_lmt_txt;
-	to->shrpn_nega_lmt_dir		= from->shrpn_nega_lmt_dir;
-	to->shrpn_posi_lmt_dir		= from->shrpn_posi_lmt_dir;
+	to->sharp_nega_lmt_txt		= from->sharp_nega_lmt_txt;
+	to->sharp_posi_lmt_txt		= from->sharp_posi_lmt_txt;
+	to->sharp_nega_lmt_dir		= from->sharp_nega_lmt_dir;
+	to->sharp_posi_lmt_dir		= from->sharp_posi_lmt_dir;
 	to->clamp_stitch		= from->clamp_stitch;
 	to->rad_enable			= from->rad_enable;
 	to->rad_x_origin		= from->rad_x_origin;
@@ -166,7 +166,7 @@ ia_css_iefd2_6_encode(
 	/* Setup for configurable units */
 	to->e_cued2_a		= from->cu_ed2_slopes_a;
 	to->e_cu_vssnlm_a	= from->cu_vssnlm_slopes_a;
-	to->e_cued2_b		= ((0-from->cu_ed2_points_x[1]) * from->cu_ed2_slopes_a)>>4;
+	to->e_cued2_b		= from->cu_ed2_points_x[0];
 	to->e_cu_vssnlm_b	= ((0-from->cu_vssnlm_points_x[1]) * from->cu_vssnlm_slopes_a)>>4;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
index 1f83f94..e594257 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
@@ -28,13 +28,13 @@
 
 void
 ia_css_iefd2_6_vmem_encode(
-	struct ia_css_isp_iefd2_6_vmem_params *to,
+	struct iefd2_6_vmem_params *to,
 	const struct ia_css_iefd2_6_config *from,
 	size_t size);
 
 void
 ia_css_iefd2_6_encode(
-	struct ia_css_isp_iefd2_6_dmem_params *to,
+	struct iefd2_6_dmem_params *to,
 	const struct ia_css_iefd2_6_config *from,
 	size_t size);
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
index 2714ce6..4b78e12 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_default.host.c
@@ -42,10 +42,10 @@ const struct ia_css_iefd2_6_config default_iefd2_6_config = {
 	.rad_cu_dir_sharp_x1 = 0,
 	.rad_cu_non_dir_sharp_x1 = 128,
 	.rad_dir_far_sharp_weight = 8,
-	.shrpn_nega_lmt_txt = 1024,
-	.shrpn_posi_lmt_txt = 1024,
-	.shrpn_nega_lmt_dir = 128,
-	.shrpn_posi_lmt_dir = 128,
+	.sharp_nega_lmt_txt = 1024,
+	.sharp_posi_lmt_txt = 1024,
+	.sharp_nega_lmt_dir = 128,
+	.sharp_posi_lmt_dir = 128,
 	.clamp_stitch = 0,
 	.rad_enable = true,
 	.rad_x_origin = 0,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
index d630a5b..afeb5f19 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
@@ -25,7 +25,7 @@
 #include "type_support.h"
 #include "vmem.h" /* needed for VMEM_ARRAY */
 
-struct ia_css_isp_iefd2_6_vmem_params {
+struct iefd2_6_vmem_params {
 	VMEM_ARRAY(e_cued_x, ISP_VEC_NELEMS);
 	VMEM_ARRAY(e_cued_a, ISP_VEC_NELEMS);
 	VMEM_ARRAY(e_cued_b, ISP_VEC_NELEMS);
@@ -40,7 +40,7 @@ struct ia_css_isp_iefd2_6_vmem_params {
 	VMEM_ARRAY(e_curad_b, ISP_VEC_NELEMS);
 };
 
-struct ia_css_isp_iefd2_6_dmem_params {
+struct iefd2_6_dmem_params {
 	int32_t horver_diag_coeff;
 	int32_t ed_horver_diag_coeff;
 	bool dir_smooth_enable;
@@ -61,10 +61,10 @@ struct ia_css_isp_iefd2_6_dmem_params {
 	int32_t rad_cu_dir_sharp_x1;
 	int32_t rad_cu_non_dir_sharp_x1;
 	int32_t rad_dir_far_sharp_weight;
-	int32_t shrpn_nega_lmt_txt;
-	int32_t shrpn_posi_lmt_txt;
-	int32_t shrpn_nega_lmt_dir;
-	int32_t shrpn_posi_lmt_dir;
+	int32_t sharp_nega_lmt_txt;
+	int32_t sharp_posi_lmt_txt;
+	int32_t sharp_nega_lmt_dir;
+	int32_t sharp_posi_lmt_dir;
 	int32_t clamp_stitch;
 	bool rad_enable;
 	int32_t rad_x_origin;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
index a9a3bc5..56fd44f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
@@ -28,9 +28,11 @@
 #include "type_support.h"
 #include "vmem.h" /* for VMEM_ARRAY*/
 #include "iefd2_6_vssnlm.isp.h"
+#include "iefd2_6.isp.h"
 
-struct sh_css_isp_iefd2_6_vmem_state {
-
+struct iefd2_6_vmem_state {
+	/* State buffers required for main IEFD2_6 */
+	VMEM_ARRAY(iefd2_6_input_lines[IEFD2_6_STATE_INPUT_BUFFER_HEIGHT], IEFD2_6_STATE_INPUT_BUFFER_WIDTH*ISP_NWAY);
 	/* State buffers required for VSSNLM sub-kernel */
 	VMEM_ARRAY(vssnlm_input_y[VSSNLM_STATE_INPUT_BUFFER_HEIGHT], VSSNLM_STATE_INPUT_BUFFER_WIDTH*ISP_NWAY);
 	VMEM_ARRAY(vssnlm_input_diff_grad[1], VSSNLM_STATE_INPUT_BUFFER_WIDTH*ISP_NWAY);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
index dc20ff6..0c821ca 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
@@ -80,14 +80,14 @@ struct ia_css_iefd2_6_config {
 						u9.0, [0,511], default 128, ineffective 0 */
 	int32_t rad_dir_far_sharp_weight;  /**< Weight of wide direct sharpening.
 						u1.12, [0,4096], default 8, ineffective 0 */
-	int32_t shrpn_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
+	int32_t sharp_nega_lmt_txt;	   /**< Sharpening limit for negative overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t shrpn_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
+	int32_t sharp_posi_lmt_txt;	   /**< Sharpening limit for positive overshoots for texture.
 						u13.0, [0,8191], default 1024, ineffective 0 */
-	int32_t shrpn_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
+	int32_t sharp_nega_lmt_dir;	   /**< Sharpening limit for negative overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
-	int32_t shrpn_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
+	int32_t sharp_posi_lmt_dir;	   /**< Sharpening limit for positive overshoots for direction
 						(edge).
 						u13.0, [0,8191], default 128, ineffective 0 */
 	int32_t clamp_stitch;		   /**< Slope to stitch between clamped and unclamped edge values.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/io_ls/bayer_io_ls/ia_css_bayer_io_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/io_ls/bayer_io_ls/ia_css_bayer_io_param.h
new file mode 100644
index 0000000..7af12b7
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/io_ls/bayer_io_ls/ia_css_bayer_io_param.h
@@ -0,0 +1,35 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_BAYER_IO_PARAM
+#define __IA_CSS_BAYER_IO_PARAM
+
+struct bayer_io_configuration {
+	unsigned base_address;
+	unsigned width;
+	unsigned height;
+	unsigned stride;
+	unsigned ddr_elems_per_word;
+	unsigned dma_channel;
+};
+
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
index e28e5cb..89ffc87 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
@@ -31,25 +31,6 @@
 
 #include "ia_css_raw.host.h"
 
-void
-ia_css_raw_encode(
-	struct sh_css_isp_raw_params *to,
-	const struct ia_css_aa_config *from,
-	unsigned size)
-{
-	(void)size;
-	to->baf_strength = from->strength;
-}
-
-void
-ia_css_raw_dump(
-	const struct sh_css_isp_raw_params *raw,
-	unsigned level)
-{
-	(void)raw;
-	(void)level;
-}
-
 static inline unsigned
 sh_css_elems_bytes_from_info (unsigned raw_bit_depth)
 {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
index dbc6501..305cdca 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.h
@@ -28,17 +28,6 @@
 #include "ia_css_raw_param.h"
 
 void
-ia_css_raw_encode(
-	struct sh_css_isp_raw_params *to,
-	const struct ia_css_aa_config *from,
-	unsigned size);
-
-void
-ia_css_raw_dump(
-	const struct sh_css_isp_raw_params *raw,
-	unsigned level);
-
-void
 ia_css_raw_config(
 	struct sh_css_isp_raw_isp_config      *to,
 	const struct ia_css_raw_configuration *from,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
index ecda79d..5a31437 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
@@ -26,11 +26,6 @@
 
 #include "dma.h"
 
-/* RAW (Optical Black) */
-struct sh_css_isp_raw_params {
-	int baf_strength;
-};
-
 /* Raw channel */
 struct sh_css_isp_raw_isp_config {
 	uint32_t width_a_over_b;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
index c5f079a..32300e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
@@ -105,7 +105,9 @@ ia_css_xnr3_encode(
 	unsigned size)
 {
 	int kernel_size = XNR_FILTER_SIZE;
-	int adjust_factor = 2 * (kernel_size - 1);
+	/* The adjust factor is the next power of 2
+	   w.r.t. the kernel size*/
+	int adjust_factor = ceil_pow2(kernel_size);
 
 	int32_t alpha_y0 = compute_alpha(from->sigma.y0);
 	int32_t alpha_y1 = compute_alpha(from->sigma.y1);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h
index 2c32974..1bccdc1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_param.h
@@ -34,12 +34,16 @@
 #define XNR_CORING_SCALE_LOG2       (ISP_VEC_ELEMBITS-1)
 #define XNR_CORING_SCALE_FACTOR     (1 << XNR_CORING_SCALE_LOG2)
 
-/* XNR3 filter size. Must be 5x5 or 9x9. */
+/* XNR3 filter size. Must be 11x11, 9x9 or 5x5. */
 #ifdef FLT_KERNEL_9x9
 #define XNR_FILTER_SIZE             9
 #else
+#ifdef FLT_KERNEL_11x11
+#define XNR_FILTER_SIZE             11
+#else
 #define XNR_FILTER_SIZE             5
 #endif
+#endif
 
 /* XNR3 alpha (1/sigma) parameters on the ISP, expressed as a base (0) value
  * for dark areas, and a scaled diff towards the value for bright areas. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.c
new file mode 100644
index 0000000..cea4444
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.c
@@ -0,0 +1,54 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+#include "ia_css_types.h"
+#include "sh_css_defs.h"
+#ifndef IA_CSS_NO_DEBUG
+#include "ia_css_debug.h"
+#endif
+#include "sh_css_frac.h"
+
+#include "ia_css_xnr4.host.h"
+
+const struct ia_css_xnr4_config default_xnr4_config = {
+	{ 123, 106, 64, 23}, /* down sample filter coefficients -luma */
+	{ 204, 154} /* down sample filter coefficients -chroma */
+};
+
+void
+ia_css_xnr4_encode(
+	struct sh_css_isp_xnr4_params *to,
+	const struct ia_css_xnr4_config *from,
+	unsigned size)
+{
+	(void)size;
+	to->m_ds4_coeffs[0] = from->m_ds4_coeffs[0];
+	to->m_ds4_coeffs[1] = from->m_ds4_coeffs[1];
+	to->m_ds4_coeffs[2] = from->m_ds4_coeffs[2];
+	to->m_ds4_coeffs[3] = from->m_ds4_coeffs[3];
+	to->m_ds2_coeffs[0] = from->m_ds2_coeffs[0];
+	to->m_ds2_coeffs[1] = from->m_ds2_coeffs[1];
+}
+
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.h
new file mode 100644
index 0000000..bfc19f4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4.host.h
@@ -0,0 +1,38 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef __IA_CSS_XNR4_HOST_H
+#define __IA_CSS_XNR4_HOST_H
+
+#include "ia_css_xnr4_types.h"
+#include "ia_css_xnr4_param.h"
+
+extern const struct ia_css_xnr4_config default_xnr4_config;
+
+void
+ia_css_xnr4_encode(
+	struct sh_css_isp_xnr4_params *to,
+	const struct ia_css_xnr4_config *from,
+	unsigned size);
+
+#endif /* __IA_CSS_XNR4_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_common_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_common_param.h
new file mode 100644
index 0000000..f1e4090
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_common_param.h
@@ -0,0 +1,36 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef __IA_CSS_XNR4_COMMON_PARAM_H
+#define __IA_CSS_XNR4_COMMON_PARAM_H
+
+#include "type_support.h"
+/* XNR4 (eXtreme Noise Reduction */
+
+/* XNR4 Algorithm Configuration */
+#define MSD_INP_BPP             (16)
+#define MSD_INP_BPP_U		(MSD_INP_BPP - 1)
+#define XNR4_STRIPE_SIZE	(2560)
+
+
+#endif /* __IA_CSS_XNR4_COMMON_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_param.h
new file mode 100644
index 0000000..751042e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_param.h
@@ -0,0 +1,45 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef __IA_CSS_XNR4_DOWNSAMPLE_PARAM_H
+#define __IA_CSS_XNR4_DOWNSAMPLE_PARAM_H
+
+#include "isp/kernels/xnr/xnrvideo4/ia_css_xnr4_common_param.h"
+
+/* XNR4 Algorithm Configuration */
+#define XNR4_LUMA_FILTER_TAP    (7)
+#define XNR4_CHROMA_FILTER_TAP  (3)
+#define XNR4_LUMA_DS_FACTOR     (4)
+#define XNR4_CHROMA_DS_FACTOR   (2)
+#define MSD_DS_IN_PREC          (MSD_INP_BPP - 1)
+#define MSD_DS_IN_PREC_MAX_VAL  ((1<<MSD_DS_IN_PREC)-1)
+#define MSD_DS_COEF_PREC        (9)
+
+
+/* XNR4 DS Parameters */
+struct sh_css_isp_xnr4_params {
+	uint8_t m_ds4_coeffs[(XNR4_LUMA_FILTER_TAP/2)+1];
+	uint8_t m_ds2_coeffs[(XNR4_CHROMA_FILTER_TAP/2)+1];
+};
+
+#endif /* __IA_CSS_XNR4_DOWNSAMPLE_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_types.h
new file mode 100644
index 0000000..75539d0
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_types.h
@@ -0,0 +1,44 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef __IA_CSS_XNR4_DOWNSAMPLE_TYPES_H
+#define __IA_CSS_XNR4_DOWNSAMPLE_TYPES_H
+
+#include "ia_css_xnr4_downsample_param.h"
+
+/** @file
+* CSS-API header file for XNR4 parameters.
+*/
+
+
+/** XNR4 configuration .  */
+struct ia_css_xnr4_config {
+	uint8_t m_ds4_coeffs[(XNR4_LUMA_FILTER_TAP/2)+1]; /** < Down sample filter coefficients,
+				       used for symmetric 7tab filtering of luma
+				       u[integer_bits].[8-integer_bits], [0,255] */
+	uint8_t m_ds2_coeffs[(XNR4_CHROMA_FILTER_TAP/2)+1]; /** < Down sample filter coefficients,
+				       used for symmetric 3tab filtering of chroma
+				       u[integer_bits].[8-integer_bits], [0,255] */
+};
+
+#endif /* __IA_CSS_XNR4_DOWNSAMPLE_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_edge_metric_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_edge_metric_param.h
new file mode 100644
index 0000000..10c164f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_edge_metric_param.h
@@ -0,0 +1,32 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef __IA_CSS_XNR4_EDGE_METRIC_PARAM_H
+#define __IA_CSS_XNR4_EDGE_METRIC_PARAM_H
+
+#include "isp/kernels/xnr/xnrvideo4/ia_css_xnr4_common_param.h"
+
+/* Edge Metric Subkernel Configuration */
+
+
+#endif /* __IA_CSS_XNR4_EDGE_METRIC_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_param.h
new file mode 100644
index 0000000..b7cbebf
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_param.h
@@ -0,0 +1,30 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef __IA_CSS_XNR4_PARAM_H
+#define __IA_CSS_XNR4_PARAM_H
+
+#include "isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_param.h"
+#include "isp/kernels/xnr/xnrvideo4/ia_css_xnr4_edge_metric_param.h"
+
+#endif /* __IA_CSS_XNR4_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_types.h
new file mode 100644
index 0000000..8ec3027
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/kernels/xnr/xnrvideo4/ia_css_xnr4_types.h
@@ -0,0 +1,29 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef __IA_CSS_XNR4_TYPES_H
+#define __IA_CSS_XNR4_TYPES_H
+
+#include "isp/kernels/xnr/xnrvideo4/ia_css_xnr4_downsample_types.h"
+
+#endif /* __IA_CSS_XNR4_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h
index 1f03fb8..c1c819a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_const.h
@@ -70,39 +70,40 @@
 #define SH_CSS_BINARY_ID_PREVIEW_DS               14
 #define SH_CSS_BINARY_ID_PREVIEW_DEC              15
 #define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS125_ISP2 16
-#define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS150_ISP2 17
-#define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS200_ISP2 18
-#define SH_CSS_BINARY_ID_PREVIEW_DZ               19
-#define SH_CSS_BINARY_ID_PREVIEW_DZ_ISP2          20
-#define SH_CSS_BINARY_ID_PRIMARY_DS               21
-#define SH_CSS_BINARY_ID_PRIMARY_VAR              22
-#define SH_CSS_BINARY_ID_PRIMARY_VAR_ISP2         23
-#define SH_CSS_BINARY_ID_PRIMARY_SMALL            24
-#define SH_CSS_BINARY_ID_PRIMARY_STRIPED          25
-#define SH_CSS_BINARY_ID_PRIMARY_STRIPED_ISP2     26
-#define SH_CSS_BINARY_ID_PRIMARY_8MP              27
-#define SH_CSS_BINARY_ID_PRIMARY_14MP             28
-#define SH_CSS_BINARY_ID_PRIMARY_16MP             29
-#define SH_CSS_BINARY_ID_PRIMARY_REF              30
-#define SH_CSS_BINARY_ID_VIDEO_OFFLINE            31
-#define SH_CSS_BINARY_ID_VIDEO_DS                 32
-#define SH_CSS_BINARY_ID_VIDEO_YUV_DS             33
-#define SH_CSS_BINARY_ID_VIDEO_DZ                 34
-#define SH_CSS_BINARY_ID_VIDEO_DZ_2400_ONLY       35
-#define SH_CSS_BINARY_ID_VIDEO_HIGH               36
-#define SH_CSS_BINARY_ID_VIDEO_NODZ               37
-#define SH_CSS_BINARY_ID_VIDEO_CONT_MULTIBDS_ISP2_MIN 38
-#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS_300_600_ISP2_MIN 39
-#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS150_ISP2_MIN   40
-#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS200_ISP2_MIN   41
-#define SH_CSS_BINARY_ID_VIDEO_CONT_NOBDS_ISP2_MIN    42
-#define SH_CSS_BINARY_ID_VIDEO_DZ_ISP2_MIN      43
-#define SH_CSS_BINARY_ID_VIDEO_DZ_ISP2          44
-#define SH_CSS_BINARY_ID_VIDEO_LP_ISP2          45
-#define SH_CSS_BINARY_ID_RESERVED1              46
-#define SH_CSS_BINARY_ID_ACCELERATION           47
-#define SH_CSS_BINARY_ID_PRE_DE_ISP2            48
-#define SH_CSS_BINARY_ID_KERNEL_TEST_LOAD_STORE 49
+#define SH_CSS_BINARY_ID_PREVIEW_CONT_DPC_BDS150_ISP2 17
+#define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS150_ISP2 18
+#define SH_CSS_BINARY_ID_PREVIEW_CONT_BDS200_ISP2 19
+#define SH_CSS_BINARY_ID_PREVIEW_DZ               20
+#define SH_CSS_BINARY_ID_PREVIEW_DZ_ISP2          21
+#define SH_CSS_BINARY_ID_PRIMARY_DS               22
+#define SH_CSS_BINARY_ID_PRIMARY_VAR              23
+#define SH_CSS_BINARY_ID_PRIMARY_VAR_ISP2         24
+#define SH_CSS_BINARY_ID_PRIMARY_SMALL            25
+#define SH_CSS_BINARY_ID_PRIMARY_STRIPED          26
+#define SH_CSS_BINARY_ID_PRIMARY_STRIPED_ISP2     27
+#define SH_CSS_BINARY_ID_PRIMARY_8MP              28
+#define SH_CSS_BINARY_ID_PRIMARY_14MP             29
+#define SH_CSS_BINARY_ID_PRIMARY_16MP             30
+#define SH_CSS_BINARY_ID_PRIMARY_REF              31
+#define SH_CSS_BINARY_ID_VIDEO_OFFLINE            32
+#define SH_CSS_BINARY_ID_VIDEO_DS                 33
+#define SH_CSS_BINARY_ID_VIDEO_YUV_DS             34
+#define SH_CSS_BINARY_ID_VIDEO_DZ                 35
+#define SH_CSS_BINARY_ID_VIDEO_DZ_2400_ONLY       36
+#define SH_CSS_BINARY_ID_VIDEO_HIGH               37
+#define SH_CSS_BINARY_ID_VIDEO_NODZ               38
+#define SH_CSS_BINARY_ID_VIDEO_CONT_MULTIBDS_ISP2_MIN 39
+#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS_300_600_ISP2_MIN 40
+#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS150_ISP2_MIN   41
+#define SH_CSS_BINARY_ID_VIDEO_CONT_BDS200_ISP2_MIN   42
+#define SH_CSS_BINARY_ID_VIDEO_CONT_NOBDS_ISP2_MIN    43
+#define SH_CSS_BINARY_ID_VIDEO_DZ_ISP2_MIN      44
+#define SH_CSS_BINARY_ID_VIDEO_DZ_ISP2          45
+#define SH_CSS_BINARY_ID_VIDEO_LP_ISP2          46
+#define SH_CSS_BINARY_ID_RESERVED1              47
+#define SH_CSS_BINARY_ID_ACCELERATION           48
+#define SH_CSS_BINARY_ID_PRE_DE_ISP2            49
+#define SH_CSS_BINARY_ID_KERNEL_TEST_LOAD_STORE 50
 
 /* skycam product pipelines */
 #define SH_CSS_BINARY_ID_SC_PREVIEW_B0			    100
@@ -172,11 +173,11 @@
 #define SH_CSS_BINARY_ID_IF_TO_BNR                          207
 #define SH_CSS_BINARY_ID_IF_TO_DM_WO_ANR_STATS              208
 #define SH_CSS_BINARY_ID_IF_TO_DM_3A_WO_ANR                 209
-#define SH_CSS_BINARY_ID_IF_TO_RGB                          210
+#define SH_CSS_BINARY_ID_IF_TO_RGBPP                        210
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1                        211
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_WO_ANR                 212
 #define SH_CSS_BINARY_ID_IF_TO_DM_WO_STATS                  213
-#define SH_CSS_BINARY_ID_IF_TO_DM_3A                        214
+#define SH_CSS_BINARY_ID_IF_TO_DM                           214
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2                        215
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_C0                     216
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_ANR_VIA_ISP            217
@@ -226,6 +227,18 @@
 #define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_C0                261
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1_C0                     262
 #define SH_CSS_BINARY_ID_IF_TO_XNR_PRIMARY                  263
+#define SH_CSS_BINARY_ID_IF_TO_XNR_PRIMARY_STRIPED          264
+#define SH_CSS_BINARY_ID_IF_TO_ANR                          265
+#define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_DVS_STAT_C0         266
+#define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_LACE_STAT_C0        267
+#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR                  268
+#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_STRIPED          269
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_STRIPED           270
+#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_DVS_STRIPED      271
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_NO_TNR     272
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_NO_TNR_STRIPED 273
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS            274
+#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_STRIPED    275
 
 #define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
 #define XMEM_SHORTS_PER_WORD         (HIVE_ISP_DDR_WORD_BITS/16)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_defaults.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_defaults.h
index b9d8753..c23c113 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_defaults.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/isp_defaults.h
@@ -114,10 +114,6 @@
 #define ENABLE_LIN            0
 #endif
 
-#if !defined(ENABLE_DP)
-#define ENABLE_DP		1
-#endif
-
 #if !defined(ENABLE_DPC)
 #define ENABLE_DPC		1
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/timer.isp.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/timer.isp.h
new file mode 100644
index 0000000..2ab3011
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/timer.isp.h
@@ -0,0 +1,38 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+
+/*
+ * Timer routines: init a HW timer and read its values.
+ */
+
+#ifndef _TIMER_ISP_H
+#define _TIMER_ISP_H
+
+#include "ia_css_err.h"
+#include "ia_css_timer.h"
+
+enum ia_css_err tmr_clock_init(void);
+inline clock_value_t tmr_clock_read(void);
+
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/trace.isp.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/trace.isp.h
new file mode 100644
index 0000000..9b6c16a
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/isp/modes/interface/trace.isp.h
@@ -0,0 +1,176 @@
+/*
+ * INTEL CONFIDENTIAL
+ *
+ * Copyright (C) 2010 - 2014 Intel Corporation.
+ * All Rights Reserved.
+ *
+ * The source code contained or described herein and all documents
+ * related to the source code ("Material") are owned by Intel Corporation
+ * or licensors. Title to the Material remains with Intel
+ * Corporation or its licensors. The Material contains trade
+ * secrets and proprietary and confidential information of Intel or its
+ * licensors. The Material is protected by worldwide copyright
+ * and trade secret laws and treaty provisions. No part of the Material may
+ * be used, copied, reproduced, modified, published, uploaded, posted,
+ * transmitted, distributed, or disclosed in any way without Intel's prior
+ * express written permission.
+ *
+ * No License under any patent, copyright, trade secret or other intellectual
+ * property right is granted to or conferred upon you by disclosure or
+ * delivery of the Materials, either expressly, by implication, inducement,
+ * estoppel or otherwise. Any license under such intellectual property rights
+ * must be express and approved by Intel in writing.
+ */
+#ifndef _TRACE_ISP_H_
+#define _TRACE_ISP_H_
+
+#include "css_trace.h"
+
+#if !TRACE_ENABLE_ISP
+#define DBG_init(buff_add, buff_size)
+#define DBG_trace(verb_level, major, minor)
+#define DBG_trace_value(verb_level, major, minor, value, format)
+#define DBG_trace_value_24bit(verb_level, major, value, format)
+#define DBG_trace_clock(verb_level, major, format)
+#define DBG_trace_clock_delta(verb_level, major, format)
+#else
+
+#include <hrt/master_port.h>
+#include "timer.isp.h"
+
+/* tracer constants */
+
+extern volatile int cur_loc;
+extern volatile unsigned short counter;
+extern volatile int started, verbosity;
+extern volatile unsigned int major_masks;
+extern volatile hrt_address trace_buff_add;
+extern volatile unsigned int max_tp;
+extern volatile unsigned int last_time;
+
+/* initialize the tracer to all 0s and init the header.
+   use 32bit writes to avoid the double-write problem. */
+static inline void DBG_init(unsigned int buff_add, unsigned int buff_size)
+{
+	int i;
+	hrt_address trace_header = 0;
+	hrt_address trace_data = 0;
+
+	trace_buff_add = (hrt_address)buff_add;
+	max_tp = (buff_size - TRACE_ISP_HEADER_SIZE) / TRACE_ISP_ITEM_SIZE;
+
+	trace_header = trace_buff_add;
+	trace_data = trace_header + TRACE_ISP_HEADER_SIZE;
+
+	/* set header 1st DWORD: version & sizes */
+	_hrt_master_port_store_32(trace_header, ((TRACER_VER) | (max_tp << 16)));
+
+	/* zero all trace points */
+	for (i = 0; i < max_tp; i++)
+	{
+		_hrt_master_port_store_32(trace_data + (TRACE_ISP_ITEM_SIZE * i), 0);
+	}
+
+	/* init control vars */
+	cur_loc = started = counter = 0;
+
+}
+
+
+/* /////////////////////////////////////////////////////////////////////////////// */
+/*  The FW enters the major/minor of the last locations the FW was lately.
+    The "next" location is always zeroed, and can tell where the buffer started. */
+/* ////////////////////////////////////////////////////////////////////////////// */
+
+/* logging routine: set the current position, advance the pointer and zero the next location.
+   increment the index only if different than prev maj/min. If not, only increment counter.
+   Note: do not put major/minor = 0 ! */
+static inline void DBG_trace(int verb_level, unsigned char major, unsigned char minor)
+{
+	unsigned int dummy = 0;
+	hrt_address trace_data = trace_buff_add + TRACE_ISP_HEADER_SIZE;
+
+	if (((unsigned int)(1 << major) & major_masks) == 0)
+		return;
+
+	if (verb_level < verbosity)
+		return;
+
+	counter++;
+	if (started) {
+		hrt_address prev_address = trace_data + (TRACE_ISP_ITEM_SIZE * DBG_PREV_ITEM(cur_loc, max_tp));
+		dummy = _hrt_master_port_load_32(prev_address);
+		if ((FIELD_MAJOR_UNPACK(dummy) == major) && (FIELD_MINOR_UNPACK(dummy) ==  minor)) {
+			_hrt_master_port_store_32(prev_address,	PACK_TRACEPOINT(TRACE_DUMP_FORMAT_POINT, major, minor, counter));
+			return;
+		}
+	}
+	started = 1;
+	_hrt_master_port_store_32(trace_data + (TRACE_ISP_ITEM_SIZE * cur_loc), PACK_TRACEPOINT(TRACE_DUMP_FORMAT_POINT, major, minor, counter));
+	cur_loc = DBG_NEXT_ITEM(cur_loc, max_tp);
+	_hrt_master_port_store_32(trace_data + (TRACE_ISP_ITEM_SIZE * cur_loc), 0);
+}
+
+
+/* log a tracepoint with a 16-bit value */
+static inline void DBG_trace_value(
+	int verb_level, 
+	unsigned char major, 
+	unsigned char minor,
+	unsigned short value, 
+	TRACE_DUMP_FORMAT format)
+{
+	hrt_address trace_data = trace_buff_add + TRACE_ISP_HEADER_SIZE;
+
+	if (verb_level < verbosity)
+		return;
+
+	_hrt_master_port_store_32(
+			trace_data + (TRACE_ISP_ITEM_SIZE * cur_loc),
+			PACK_TRACEPOINT(format, major, minor, value));
+	cur_loc = DBG_NEXT_ITEM(cur_loc, max_tp);
+	_hrt_master_port_store_32(trace_data + (TRACE_ISP_ITEM_SIZE * cur_loc), 0);
+}
+
+/* log a tracepoint with a 24-bit value */
+static inline void DBG_trace_value_24bit(int verb_level, unsigned char major, unsigned int value, TRACE_DUMP_FORMAT format)
+{
+	hrt_address trace_data = trace_buff_add + TRACE_ISP_HEADER_SIZE;
+
+	if (verb_level < verbosity)
+		return;
+
+	_hrt_master_port_store_32(
+			trace_data + (TRACE_ISP_ITEM_SIZE * cur_loc),
+			PACK_TRACE_VALUE24(format, major, value));
+	cur_loc = DBG_NEXT_ITEM(cur_loc, max_tp);
+	_hrt_master_port_store_32(trace_data + (TRACE_ISP_ITEM_SIZE * cur_loc), 0);
+}
+
+/* trace a clock value */
+static inline void DBG_trace_clock(int verb_level, unsigned char major, TRACE_DUMP_FORMAT format)
+{
+	volatile unsigned int clock_value = tmr_clock_read();
+
+	if (verb_level < verbosity)
+		return;
+
+	DBG_trace_value_24bit(verb_level, major, clock_value, format);
+	last_time = clock_value;
+}
+
+/* trace a clock delta value */
+static inline void DBG_trace_clock_delta(int verb_level, unsigned char major, TRACE_DUMP_FORMAT format)
+{
+	unsigned int clock_value = tmr_clock_read();
+	if (verb_level < verbosity)
+		return;
+
+	DBG_trace_value_24bit(verb_level, major, clock_value - last_time, format);
+	last_time = clock_value;
+
+}
+
+#endif /*  !TRACE_ENABLE_ISP */
+
+#endif /* _TRACE_ISP_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/interface/ia_css_binary.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/interface/ia_css_binary.h
index 7c873e7..97bd2d4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/interface/ia_css_binary.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/interface/ia_css_binary.h
@@ -98,6 +98,7 @@ struct ia_css_binary_descr {
 	bool enable_dz;
 	bool enable_xnr;
 	bool enable_fractional_ds;
+	bool enable_dpc;
 	struct ia_css_resolution dvs_env;
 	enum ia_css_stream_format stream_format;
 	struct ia_css_frame_info *in_info;		/* the info of the input-frame with the
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c
index 0f95ebd..111f824 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/binary/src/binary.c
@@ -340,9 +340,6 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 
 	dvs_info = &info->dvs_grid;
 
-	info->isp_in_width = binary->internal_frame_info.res.width;
-	info->isp_in_height = binary->internal_frame_info.res.height;
-
 	/* for DIS, we use a division instead of a ceil_div. If this is smaller
 	 * than the 3a grid size, it indicates that the outer values are not
 	 * valid for DIS.
@@ -360,17 +357,8 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 	assert(pipe != NULL);
 	dvs_info->enable            = binary->info->sp.enable.dvs_stats;
 #endif
-
-#if defined(HAS_VAMEM_VERSION_2)
-	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
-#elif defined(HAS_VAMEM_VERSION_1)
-	info->vamem_type = IA_CSS_VAMEM_TYPE_1;
-#else
-#error "Unknown VAMEM version"
-#endif
 }
 
-
 void
 ia_css_binary_3a_grid_info(const struct ia_css_binary *binary,
 			   struct ia_css_grid_info *info,
@@ -383,8 +371,6 @@ ia_css_binary_3a_grid_info(const struct ia_css_binary *binary,
 	assert(info != NULL);
 	s3a_info = &info->s3a_grid;
 
-	info->isp_in_width = binary->internal_frame_info.res.width;
-	info->isp_in_height = binary->internal_frame_info.res.height;
 
 #if !defined(IS_ISP_2500_SYSTEM)
 	/* 3A statistics grid */
@@ -412,16 +398,6 @@ ia_css_binary_3a_grid_info(const struct ia_css_binary *binary,
 
 	ia_css_3a_stat_grid_calculate(s3a_info, pipe);
 
-	s3a_info->af_grd_info       = *get_af_grid_config(pipe);
-	s3a_info->awb_fr_grd_info   = *get_awb_fr_grid_config(pipe);
-	s3a_info->awb_grd_info      = *get_awb_grid_config(pipe);
-#endif
-#if defined(HAS_VAMEM_VERSION_2)
-	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
-#elif defined(HAS_VAMEM_VERSION_1)
-	info->vamem_type = IA_CSS_VAMEM_TYPE_1;
-#else
-#error "Unknown VAMEM version"
 #endif
 }
 
@@ -675,9 +651,12 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 	binary->info = xinfo;
 	if (!accelerator) {
 		/* binary->css_params has been filled by accelerator itself. */
-		ia_css_isp_param_allocate_isp_parameters(
+		err = ia_css_isp_param_allocate_isp_parameters(
 			&binary->mem_params, &binary->css_params,
 			&info->mem_initializers);
+		if (err != IA_CSS_SUCCESS) {
+			return err;
+		}
 	}
 	for (i = 0; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++) {
 		if (out_info[i] && (out_info[i]->res.width != 0)) {
@@ -713,7 +692,7 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 		binary->internal_frame_info.format = bin_out_info->format;
 	/* } */
 	binary->internal_frame_info.res.width       = isp_internal_width;
-	binary->internal_frame_info.padded_width    = isp_internal_width;
+	binary->internal_frame_info.padded_width    = CEIL_MUL(isp_internal_width, 2*ISP_VEC_NELEMS);
 	binary->internal_frame_info.res.height      = isp_internal_height;
 	binary->internal_frame_info.raw_bit_depth   = bits_per_pixel;
 
@@ -773,8 +752,14 @@ ia_css_binary_fill_info(const struct ia_css_binary_xinfo *xinfo,
 #ifndef IS_ISP_2500_SYSTEM
 	if (vf_info && (vf_info->res.width != 0)) {
 		err = ia_css_vf_configure(binary, bin_out_info, (struct ia_css_frame_info *)vf_info, &vf_log_ds);
-		if (err != IA_CSS_SUCCESS)
+		if (err != IA_CSS_SUCCESS) {
+			if (!accelerator) {
+				ia_css_isp_param_destroy_isp_parameters(
+					&binary->mem_params,
+					&binary->css_params);
+			}
 			return err;
+		}
 	}
 #else
 	(void)err;
@@ -922,7 +907,7 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 				       *req_vf_info;
 
 	struct ia_css_binary_xinfo *xcandidate;
-	bool need_ds, need_dz, need_dvs, need_xnr;
+	bool need_ds, need_dz, need_dvs, need_xnr, need_dpc;
 	bool striped;
 	bool enable_yuv_ds;
 	bool enable_high_speed;
@@ -962,6 +947,7 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 	need_ds = descr->enable_fractional_ds;
 	need_dz = false;
 	need_dvs = false;
+	need_dpc = descr->enable_dpc;
 	enable_yuv_ds = descr->enable_yuv_ds;
 	enable_high_speed = descr->enable_high_speed;
 	enable_dvs_6axis  = descr->enable_dvs_6axis;
@@ -1217,6 +1203,14 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 			continue;
 		}
 
+		if (!candidate->enable.dpc && need_dpc) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
+				__LINE__, candidate->enable.dpc,
+				descr->enable_dpc);
+			continue;
+		}
+
 
 		/* reconfigure any variable properties of the binary */
 		err = ia_css_binary_fill_info(xcandidate, online, two_ppc,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h
index 8c5bd5c..b7ae8c5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/interface/ia_css_debug.h
@@ -408,6 +408,12 @@ void ia_css_debug_dump_stream_config(
 	const struct ia_css_stream_config *config,
 	int num_pipes);
 
+/*! @brief Dump the state of the SP tagger
+ * Dumps the internal state of the SP tagger
+ * @return	None
+ */
+void ia_css_debug_tagger_state(void);
+
 /**
  * @brief Initialize the debug mode.
  *
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c
index b1ddd29..5338be1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/debug/src/ia_css_debug.c
@@ -70,6 +70,9 @@
 #include "input_system.h"	/* input_formatter_reg_load */
 #include "gp_device.h"		/* gp_device_reg_load */
 #endif
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+#include "ia_css_tagger_common.h"
+#endif
 
 #include "sh_css_internal.h"
 #if !defined(HAS_NO_INPUT_SYSTEM)
@@ -2288,6 +2291,9 @@ void ia_css_debug_dump_debug_info(const char *context)
 #if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2401)
 	ia_css_debug_dump_isys_state();
 #endif
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+	ia_css_debug_tagger_state();
+#endif
 	return;
 }
 
@@ -3152,7 +3158,12 @@ ia_css_debug_dump_pipe_config(
 {
 	unsigned int i;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "%s()\n", __func__);
+	IA_CSS_ENTER_PRIVATE("config = %p", config);
+	if (!config) {
+		IA_CSS_ERROR("NULL input parameter");
+		IA_CSS_LEAVE_PRIVATE("");
+		return;
+	}
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "mode: %d\n", config->mode);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "isp_pipe_version: %d\n",
 			config->isp_pipe_version);
@@ -3180,6 +3191,7 @@ ia_css_debug_dump_pipe_config(
 			config->acc_num_execs);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "enable_dz: %d\n",
 			config->enable_dz);
+	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void
@@ -3332,34 +3344,62 @@ ia_css_debug_dump_stream_config(
 	byte 1:   minor
 	byte 2-3: data
 */
-
-#define TRACE_MAX_SIZE     4096			/* max points - sanity check */
-
-static void debug_dump_one_trace(const char *text, uint32_t start_addr)
+#if TRACE_ENABLE_SP0 || TRACE_ENABLE_SP1 || TRACE_ENABLE_ISP
+static void debug_dump_one_trace(TRACE_CORE_ID proc_id)
 {
-#if !defined(HAS_TRACER_V1)
-	(void) text;
-	(void) start_addr;
-#else
+#if defined(HAS_TRACER_V2)
+	uint32_t start_addr;
+	uint32_t start_addr_data;
+	uint32_t item_size;
 	uint32_t tmp;
-	int i, j, point_num, limit = -1;
+	int i, j, max_trace_points, point_num, limit = -1;
 	/* using a static buffer here as the driver has issues allocating memory */
-	static uint32_t trace_read_buf[TRACE_MAX_SIZE];
+	static uint32_t trace_read_buf[TRACE_BUFF_SIZE];
+
 	/* read the header and parse it */
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "~~~ Tracer ");
+	switch (proc_id)
+	{
+	case TRACE_SP0_ID:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP0");
+		start_addr = TRACE_SP0_ADDR;
+		start_addr_data = TRACE_SP0_DATA_ADDR;
+		item_size = TRACE_SP0_ITEM_SIZE;
+		max_trace_points = TRACE_SP0_MAX_POINTS;
+		break;
+	case TRACE_SP1_ID:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "SP1");
+		start_addr = TRACE_SP1_ADDR;
+		start_addr_data = TRACE_SP1_DATA_ADDR;
+		item_size = TRACE_SP1_ITEM_SIZE;
+		max_trace_points = TRACE_SP1_MAX_POINTS;
+		break;
+	case TRACE_ISP_ID:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ISP");
+		start_addr = TRACE_ISP_ADDR;
+		start_addr_data = TRACE_ISP_DATA_ADDR;
+		item_size = TRACE_ISP_ITEM_SIZE;
+		max_trace_points = TRACE_ISP_MAX_POINTS;
+		break;
+	default:
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\t\ttraces are not supported for this processor ID - exiting\n");
+		return;
+	}
 	tmp = ia_css_device_load_uint32(start_addr);
 	point_num = (tmp >> 16) & 0xFFFF;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "~~~ Tracer %s ver %d %d points\n", text, tmp & 0xFF, point_num);
-	if ((tmp & 0xFF) != 1) {
+
+	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, " ver %d %d points\n", tmp & 0xFF, point_num);
+	if ((tmp & 0xFF) != TRACER_VER) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\t\tUnknown version - exiting\n");
 		return;
 	}
-	if (point_num > TRACE_MAX_SIZE) {
+	if (point_num > max_trace_points) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\t\tToo many points - exiting\n");
 		return;
 	}
 	/* copy the TPs and find the first 0 */
 	for (i = 0; i < point_num; i++) {
-		trace_read_buf[i] = ia_css_device_load_uint32(start_addr + sizeof(struct trace_header_t) + i * sizeof(struct trace_item_t));
+		trace_read_buf[i] = ia_css_device_load_uint32(start_addr_data + (i * item_size));
 		if ((limit == (-1)) && (trace_read_buf[i] == 0))
 			limit = i;
 	}
@@ -3375,24 +3415,106 @@ static void debug_dump_one_trace(const char *text, uint32_t start_addr)
 	/* overrun: limit is the first non-zero after the first zero */
 	else
 		limit++;
+
 	/* print the TPs */
 	for (i = 0; i < point_num; i++) {
 		j = (limit + i) % point_num;
 		if (trace_read_buf[j])
-			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "\t\t%d %d:%d %d\n",
-								j,
-								trace_read_buf[j] & 0xFF,
-								(trace_read_buf[j] >> 8) & 0xFF,
-								(trace_read_buf[j] >> 16) & 0xFFFF);
+		{
+			TRACE_DUMP_FORMAT dump_format = FIELD_FORMAT_UNPACK(trace_read_buf[j]);
+			switch (dump_format)
+			{
+			case TRACE_DUMP_FORMAT_POINT:
+				ia_css_debug_dtrace(
+						IA_CSS_DEBUG_TRACE,	"\t\t%d %d:%d value - %d\n",
+						j, FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+						FIELD_MINOR_UNPACK(trace_read_buf[j]),
+						FIELD_VALUE_UNPACK(trace_read_buf[j]));
+				break;
+			case TRACE_DUMP_FORMAT_VALUE24_HEX:
+				ia_css_debug_dtrace(
+						IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, 24bit value %x H\n",
+						j,
+						FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+						FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+				break;
+			case TRACE_DUMP_FORMAT_VALUE24_DEC:
+				ia_css_debug_dtrace(
+						IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, 24bit value %d D\n",
+						j,
+						FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+						FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+				break;
+			case TRACE_DUMP_FORMAT_VALUE24_TIMING:
+				ia_css_debug_dtrace(
+						IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, timing %x\n",
+						j,
+						FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+						FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+				break;
+			case TRACE_DUMP_FORMAT_VALUE24_TIMING_DELTA:
+				ia_css_debug_dtrace(
+						IA_CSS_DEBUG_TRACE,	"\t\t%d, %d, timing delta %x\n",
+						j,
+						FIELD_MAJOR_UNPACK(trace_read_buf[j]),
+						FIELD_VALUE_24_UNPACK(trace_read_buf[j]));
+				break;
+			default:
+				ia_css_debug_dtrace(
+						IA_CSS_DEBUG_TRACE,
+						"no such trace dump format %d",
+						FIELD_FORMAT_UNPACK(trace_read_buf[j]));
+				break;
+			}
+		}
 	}
-#endif /* IS_ISP_2500_SYSTEM */
+#else
+	(void)proc_id;
+#endif /* HAS_TRACER_V2 */
 }
+#endif /* TRACE_ENABLE_SP0 || TRACE_ENABLE_SP1 || TRACE_ENABLE_ISP */
 
 void ia_css_debug_dump_trace(void)
 {
-	debug_dump_one_trace("SP0", TRACE_BUFF_ADDR);
-	debug_dump_one_trace("SP1", TRACE_BUFF_ADDR + SP1_TRACER_OFFSET);
+#if TRACE_ENABLE_SP0
+	debug_dump_one_trace(TRACE_SP0_ID);
+#endif
+#if TRACE_ENABLE_SP1
+	debug_dump_one_trace(TRACE_SP1_ID);
+#endif
+#if TRACE_ENABLE_ISP
+	debug_dump_one_trace(TRACE_ISP_ID);
+#endif
+}
+
+#if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
+/* Tagger state dump function. The tagger is only available when the CSS
+ * contains an input system (2400 or 2401). */
+void ia_css_debug_tagger_state(void)
+{
+	unsigned int i;
+	unsigned int HIVE_ADDR_tagger_frames;
+	ia_css_tagger_buf_sp_elem_t tbuf_frames[MAX_CB_ELEMS_FOR_TAGGER];
+
+	HIVE_ADDR_tagger_frames = sh_css_sp_fw.info.sp.tagger_frames_addr;
+
+	/* This variable is not used in crun */
+	(void)HIVE_ADDR_tagger_frames;
+
+	/* 2400 and 2401 only have 1 SP, so the tagger lives on SP0 */
+	sp_dmem_load(SP0_ID,
+		     (unsigned int)sp_address_of(tagger_frames),
+		     tbuf_frames,
+		     sizeof(tbuf_frames));
+
+	ia_css_debug_dtrace(2, "Tagger Info:\n");
+	for (i = 0; i < MAX_CB_ELEMS_FOR_TAGGER; i++) {
+		ia_css_debug_dtrace(2, "\t tagger frame[%d]: exp_id=%d, marked=%d, locked=%d\n",
+				i, tbuf_frames[i].exp_id, tbuf_frames[i].mark, tbuf_frames[i].lock);
+	}
+
 }
+#endif /* defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401) */
 
 #if defined(HRT_SCHED) || defined(SH_CSS_DEBUG_SPMEM_DUMP_SUPPORT)
 #include "spmem_dump.c"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/event/src/event.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/event/src/event.c
index 6948a63..6b2360e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/event/src/event.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/event/src/event.c
@@ -105,6 +105,7 @@ void ia_css_event_decode(
 		break;
 
 	case SH_CSS_SP_EVENT_ACC_STAGE_COMPLETE:
+	case SH_CSS_SP_EVENT_TIMER:
 	case SH_CSS_SP_EVENT_FRAME_TAGGED:
 	case SH_CSS_SP_EVENT_FW_WARNING:
 	case SH_CSS_SP_EVENT_FW_ASSERT:
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c
index 43f2c59..5738822 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/frame/src/frame.c
@@ -434,12 +434,13 @@ void ia_css_frame_info_set_width(struct ia_css_frame_info *info,
 {
 	unsigned int align;
 
-	assert(info != NULL);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"ia_css_frame_info_set_width() enter: "
-		"width=%d, min_padded_width=%d\n",
-		width, min_padded_width);
-
+	IA_CSS_ENTER_PRIVATE("info = %p,width = %d, minimum padded width = %d",
+			     info, width, min_padded_width);
+	if (info == NULL) {
+		IA_CSS_ERROR("NULL input parameter");
+		IA_CSS_LEAVE_PRIVATE("");
+		return;
+	}
 	if (min_padded_width > width)
 		align = min_padded_width;
 	else
@@ -465,6 +466,7 @@ void ia_css_frame_info_set_width(struct ia_css_frame_info *info,
 	else {
 		info->padded_width = CEIL_MUL(align, HIVE_ISP_DDR_WORD_BYTES);
 	}
+	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void ia_css_frame_info_set_format(struct ia_css_frame_info *info,
@@ -482,17 +484,17 @@ void ia_css_frame_info_init(struct ia_css_frame_info *info,
 	enum ia_css_frame_format format,
 	unsigned int aligned)
 {
-	assert(info != NULL);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"ia_css_frame_info_init() enter: "
-		"width=%d, height=%d, format=%d, aligned=%d\n",
-		width, height, format, aligned);
-
+	IA_CSS_ENTER_PRIVATE("info = %p, width = %d, height = %d, format = %d, aligned = %d",
+			     info, width, height, format, aligned);
+	if (info == NULL) {
+		IA_CSS_ERROR("NULL input parameter");
+		IA_CSS_LEAVE_PRIVATE("");
+		return;
+	}
 	info->res.height = height;
 	info->format     = format;
 	ia_css_frame_info_set_width(info, width, aligned);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"ia_css_frame_info_init() leave: return_void\n");
+	IA_CSS_LEAVE_PRIVATE("");
 }
 
 void ia_css_frame_free_multiple(unsigned int num_frames,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/interface/ia_css_isp_param_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/interface/ia_css_isp_param_types.h
index c0ed1ac..d0119e9 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/interface/ia_css_isp_param_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/interface/ia_css_isp_param_types.h
@@ -46,8 +46,8 @@ enum ia_css_param_class {
 
 /** ISP parameter descriptor */
 struct ia_css_isp_parameter {
-	uint16_t offset; /* Offset in isp_<mem>)parameters, etc. */
-	uint16_t size;   /* Disabled if 0 */
+	uint32_t offset; /* Offset in isp_<mem>)parameters, etc. */
+	uint32_t size;   /* Disabled if 0 */
 };
 
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/src/isp_param.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/src/isp_param.c
index 89a51c6..7c846bc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/src/isp_param.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isp_param/src/isp_param.c
@@ -126,17 +126,24 @@ ia_css_isp_param_allocate_isp_parameters(
 			css_params->params[pclass][mem].address = 0x0;
 			if (size) {
 				mem_params->params[pclass][mem].address = sh_css_calloc(1, size);
-				if (!mem_params->params[pclass][mem].address)
-					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+				if (!mem_params->params[pclass][mem].address) {
+					err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+					goto cleanup;
+				}
 				if (pclass != IA_CSS_PARAM_CLASS_PARAM) {
 					css_params->params[pclass][mem].address = mmgr_malloc(size);
-					if (!css_params->params[pclass][mem].address)
-						return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+					if (!css_params->params[pclass][mem].address) {
+						err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+						goto cleanup;
+					}
 				}
 			}
 		}
 	}
 	return err;
+cleanup:
+	ia_css_isp_param_destroy_isp_parameters(mem_params, css_params);
+	return err;
 }
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/isys_init.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/isys_init.c
index 7633bf5..170d470 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/isys_init.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/isys_init.c
@@ -27,6 +27,7 @@
 
 #ifdef USE_INPUT_SYSTEM_VERSION_2401
 #include "isys_dma.h"		/* isys2401_dma_set_max_burst_size() */
+#include "isys_irq.h"
 #endif
 
 #if defined(USE_INPUT_SYSTEM_VERSION_2)
@@ -105,6 +106,11 @@ input_system_error_t ia_css_isys_init(void)
 	isys2401_dma_set_max_burst_size(ISYS2401_DMA0_ID,
 		1 /* Non Burst DMA transactions */);
 
+	/* Enable 2401 input system IRQ status for driver to retrieve */
+	isys_irqc_status_enable(ISYS_IRQ0_ID);
+	isys_irqc_status_enable(ISYS_IRQ1_ID);
+	isys_irqc_status_enable(ISYS_IRQ2_ID);
+
 	return error;
 }
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c
index 13e9108..f5c3ea6 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/isys/src/rx.c
@@ -498,16 +498,8 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 	/* AM: Check whether this is a problem with multiple
 	 * streams. MS: This is the case. */
 
-	/* Must turn off all ports because of the 2ppc setting */
-#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
-	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++) {
-		port_enabled[port] = is_receiver_port_enabled(RX0_ID, port);
-		receiver_port_enable(RX0_ID, port, false);
-	}
-#else
 	port = config->port;
 	receiver_port_enable(RX0_ID, port, false);
-#endif
 
 	port = config->port;
 
@@ -574,13 +566,7 @@ void ia_css_isys_rx_configure(const rx_cfg_t *config,
 		receiver_reg_store(RX0_ID, _HRT_CSS_RECEIVER_BE_TWO_PPC_REG_IDX,
 				   config->is_two_ppc);
 	}
-#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
-	/* enable the selected port(s) */
-	for (port = (mipi_port_ID_t) 0; port < N_MIPI_PORT_ID; port++)
-		receiver_port_enable(RX0_ID, port, port_enabled[port]);
-#else
 	receiver_port_enable(RX0_ID, port, true);
-#endif
 	/* TODO: JB: need to add the beneath used define to mizuchi */
 	/* sh_css_sw_hive_isp_css_2400_system_20121224_0125\css
 	 *                      \hrt\input_system_defs.h
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/pipeline/src/pipeline.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/pipeline/src/pipeline.c
index 5cc7a55..e43c05f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/pipeline/src/pipeline.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/pipeline/src/pipeline.c
@@ -470,14 +470,17 @@ bool ia_css_pipeline_is_mapped(unsigned int key)
 {
 	bool ret = false;
 
-	assert(key < IA_CSS_PIPELINE_NUM_MAX);
-	assert(key < IA_CSS_PIPE_ID_NUM);
+	IA_CSS_ENTER_PRIVATE("key = %d", key);
 
-	IA_CSS_ENTER("key=%d", key);
+	if ((key >= IA_CSS_PIPELINE_NUM_MAX) || (key >= IA_CSS_PIPE_ID_NUM)) {
+		IA_CSS_ERROR("Invalid key!!");
+		IA_CSS_LEAVE_PRIVATE("return = %d", false);
+		return false;
+	}
 
 	ret = (bool)(pipeline_num_to_sp_thread_map[key] != (unsigned)PIPELINE_NUM_UNMAPPED);
 
-	IA_CSS_LEAVE("return=%d", ret);
+	IA_CSS_LEAVE_PRIVATE("return = %d", ret);
 	return ret;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/queue/src/queue.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/queue/src/queue.c
index 4bb82ec..6ca13f4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/queue/src/queue.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/queue/src/queue.c
@@ -383,6 +383,9 @@ int ia_css_queue_is_empty(
 	}
 
 	return EINVAL;
+#if defined(IS_ISP_2500_SYSTEM) && defined(__SP)
+#pragma hivecc section = "critical"
+#endif
 }
 
 int ia_css_queue_get_size(
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/tagger/interface/ia_css_tagger_common.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/tagger/interface/ia_css_tagger_common.h
new file mode 100644
index 0000000..fdd2e6c
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/runtime/tagger/interface/ia_css_tagger_common.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ *
+ * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA.
+ *
+ */
+
+#ifndef __IA_CSS_TAGGER_COMMON_H__
+#define __IA_CSS_TAGGER_COMMON_H__
+
+#include <system_local.h>
+#include <type_support.h>
+
+/**
+ * @brief The tagger's circular buffer.
+ *
+ * Should be one less than NUM_CONTINUOUS_FRAMES in sh_css_internal.h
+ */
+#if defined(HAS_SP_2400)
+#define MAX_CB_ELEMS_FOR_TAGGER 14
+#else
+#define MAX_CB_ELEMS_FOR_TAGGER 9
+#endif
+
+/**
+ * @brief Data structure for the tagger buffer element.
+ */
+typedef struct {
+	uint32_t frame;	/* the frame value stored in the element */
+	uint32_t param;	/* the param value stored in the element */
+	uint8_t mark;	/* the mark on the element */
+	uint8_t lock;	/* the lock on the element */
+	uint8_t exp_id; /* exp_id of frame, for debugging only */
+} ia_css_tagger_buf_sp_elem_t;
+
+#endif /* __IA_CSS_TAGGER_COMMON_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c
index a7d1288..5bdd734 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css.c
@@ -103,6 +103,9 @@ static int thread_alive;
 
 #include "isp/modes/interface/input_buf.isp.h"
 
+#if defined(HAS_RES_MGR)
+#include "components/acc_cluster/gen/host/acc_cluster.host.h"
+#endif
 
 /* Name of the sp program: should not be built-in */
 #define SP_PROG_NAME "sp"
@@ -275,8 +278,8 @@ alloc_continuous_frames(
 static void
 pipe_global_init(void);
 
-static uint8_t
-pipe_generate_pipe_num(const struct ia_css_pipe *pipe);
+static enum ia_css_err
+pipe_generate_pipe_num(const struct ia_css_pipe *pipe, unsigned int *pipe_number);
 
 static void
 pipe_release_pipe_num(unsigned int pipe_num);
@@ -451,33 +454,6 @@ verify_copy_out_frame_format(struct ia_css_pipe *pipe)
 	return IA_CSS_SUCCESS;
 }
 
-/* next function takes care of getting the settings from kernel
- * commited to hmm / isp
- * TODO: see if needs to be made public
- */
-static enum ia_css_err
-sh_css_commit_isp_config(struct ia_css_pipe *pipe)
-{
-	enum ia_css_err err = IA_CSS_SUCCESS;
-	struct ia_css_pipeline_stage *stage;
-	struct ia_css_pipeline *pipeline;
-
-	pipeline = &pipe->pipeline;
-	if (pipeline) {
-		/* walk through pipeline and commit settings */
-		/* TODO: check if this is needed (s3a is handled through this */
-		for (stage = pipeline->stages; stage; stage = stage->next) {
-			if (stage && stage->binary) {
-				err = sh_css_params_write_to_ddr(pipe,
-								 stage);
-				if (err != IA_CSS_SUCCESS)
-					return err;
-			}
-		}
-	}
-	return err;
-}
-
 unsigned int
 ia_css_stream_input_format_bits_per_pixel(struct ia_css_stream *stream)
 {
@@ -1297,13 +1273,6 @@ start_binary(struct ia_css_pipe *pipe,
 	(void)stream;
 #endif
 
-#ifdef THIS_CODE_IS_NO_LONGER_NEEDED_FOR_DUAL_STREAM
-#if !defined(HAS_NO_INPUT_SYSTEM)
-	if (stream && stream->reconfigure_css_rx)
-		ia_css_isys_rx_disable();
-#endif
-#endif
-
 	if (binary)
 		sh_css_metrics_start_binary(&binary->metrics);
 
@@ -1318,8 +1287,6 @@ start_binary(struct ia_css_pipe *pipe,
 		sh_binary_running = true;
 #endif
 
-	/* sh_css_sp_start_isp(); */
-
 #if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
 	if (stream->reconfigure_css_rx) {
 		ia_css_isys_rx_configure(&pipe->stream->csi_rx_config,
@@ -1351,8 +1318,6 @@ start_copy_on_sp(struct ia_css_pipe *pipe,
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	sh_css_sp_start_binary_copy(ia_css_pipe_get_pipe_num(pipe), out_frame, pipe->stream->config.pixels_per_clock == 2);
 
-	//sh_css_sp_start_isp();
-
 #if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
 	if (pipe->stream->reconfigure_css_rx) {
 		ia_css_isys_rx_configure(&pipe->stream->csi_rx_config, pipe->stream->config.mode);
@@ -1380,36 +1345,19 @@ void sh_css_binary_args_reset(struct sh_css_binary_args *args)
 	args->vf_downscale_log2 = 0;
 }
 
-
-static void
-pipe_start(struct ia_css_pipe *pipe)
-{
-	struct ia_css_pipeline_stage *stage;
-	assert(pipe != NULL);
-	stage = pipe->pipeline.stages;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"pipe_start() enter:\n");
-	if (!stage)
-		return;
-	pipe->pipeline.current_stage = stage;
-
-	start_binary(pipe, stage->binary);
-}
-
-static enum ia_css_err start_pipe(
+static void start_pipe(
 	struct ia_css_pipe *me,
 	enum sh_css_pipe_config_override copy_ovrd,
 	enum ia_css_input_mode input_mode)
 {
-	enum ia_css_err err = IA_CSS_SUCCESS;
-	assert(me != NULL);
-
 #if defined(HAS_NO_INPUT_SYSTEM)
 	(void)input_mode;
 #endif
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"start_pipe() enter:\n");
+	IA_CSS_ENTER_PRIVATE("me = %p, copy_ovrd = %d, input_mode = %d",
+			     me, copy_ovrd, input_mode);
+
+	assert(me != NULL); /* all callers are in this file and call with non null argument */
 
 	sh_css_sp_init_pipeline(&me->pipeline,
 				me->mode,
@@ -1430,15 +1378,15 @@ static enum ia_css_err start_pipe(
 #endif
 				);
 
-	if (me->config.mode != IA_CSS_PIPE_MODE_COPY){
-		/* prepare update of params to ddr */
-		err = sh_css_commit_isp_config(me);
-		if (err == IA_CSS_SUCCESS)
-			pipe_start(me);
+	if (me->config.mode != IA_CSS_PIPE_MODE_COPY) {
+		struct ia_css_pipeline_stage *stage;
+		stage = me->pipeline.stages;
+		if (stage) {
+			me->pipeline.current_stage = stage;
+			start_binary(me, stage->binary);
+		}
 	}
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"start_pipe() leave: return (%d)\n", err);
-	return err;
+	IA_CSS_LEAVE_PRIVATE("void");
 }
 
 void
@@ -1620,7 +1568,6 @@ ia_css_load_firmware(const struct ia_css_env *env,
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_load_firmware() leave \n");
 	return err;
-
 }
 
 enum ia_css_err
@@ -1843,6 +1790,7 @@ ia_css_init(const struct ia_css_env *env,
 	if(ia_css_isys_init() != INPUT_SYSTEM_ERR_NO_ERROR)
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 #endif
+
 	IA_CSS_LEAVE_ERR(err);
 	return err;
 }
@@ -1970,7 +1918,8 @@ static enum ia_css_err
 map_sp_threads(struct ia_css_stream *stream, bool map)
 {
 	struct ia_css_pipe *main_pipe = NULL;
-	struct ia_css_pipe *copy_pipe = NULL, *capture_pipe = NULL;
+	struct ia_css_pipe *copy_pipe = NULL;
+	struct ia_css_pipe *capture_pipe = NULL;
 	struct ia_css_pipe *acc_pipe = NULL;
 	enum ia_css_err err = IA_CSS_SUCCESS;
 	enum ia_css_pipe_id pipe_id;
@@ -1983,7 +1932,7 @@ map_sp_threads(struct ia_css_stream *stream, bool map)
 		return IA_CSS_ERR_INVALID_ARGUMENTS;
 	}
 
-	main_pipe	= stream->last_pipe;
+	main_pipe = stream->last_pipe;
 	pipe_id	= main_pipe->mode;
 
 	ia_css_pipeline_map(main_pipe->pipe_num, map);
@@ -2019,7 +1968,7 @@ map_sp_threads(struct ia_css_stream *stream, bool map)
 		ia_css_pipeline_map(copy_pipe->pipe_num, map);
 	}
 	/* DH regular multi pipe - not continuous mode: map the next pipes too */
-	if ((!stream->config.continuous) && stream->num_pipes > 1) {
+	if (!stream->config.continuous) {
 		int i;
 		for (i = 1; i < stream->num_pipes; i++)
 			ia_css_pipeline_map(stream->pipes[i]->pipe_num, map);
@@ -2050,7 +1999,6 @@ create_host_pipeline_structure(struct ia_css_stream *stream)
 		return IA_CSS_ERR_INVALID_ARGUMENTS;
 	}
 
-
 	main_pipe	= stream->last_pipe;
 	assert(main_pipe != NULL);
 	if (main_pipe == NULL) {
@@ -2115,14 +2063,14 @@ create_host_pipeline_structure(struct ia_css_stream *stream)
 	}
 
 	/* DH regular multi pipe - not continuous mode: create the next pipelines too */
- 	if ((!stream->config.continuous) && stream->num_pipes > 1) {
+ 	if (!stream->config.continuous) {
 		int i;
 		for (i = 1; i < stream->num_pipes && IA_CSS_SUCCESS == err; i++) {
 			main_pipe = stream->pipes[i];
 			err = ia_css_pipeline_create(&main_pipe->pipeline,
-									main_pipe->mode,
-									main_pipe->pipe_num,
-									main_pipe->dvs_frame_delay);
+							main_pipe->mode,
+							main_pipe->pipe_num,
+							main_pipe->dvs_frame_delay);
 		}
 	}
 
@@ -2142,10 +2090,11 @@ create_host_pipeline(struct ia_css_stream *stream)
 	enum ia_css_err err = IA_CSS_SUCCESS;
 	unsigned max_input_width = 0;
 
-	assert(stream != NULL);
-
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"create_host_pipeline() enter:\n");
+	IA_CSS_ENTER_PRIVATE("stream = %p", stream);
+	if (stream == NULL) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	main_pipe	= stream->last_pipe;
 	pipe_id	= main_pipe->mode;
@@ -2252,9 +2201,9 @@ create_host_pipeline(struct ia_css_stream *stream)
 	}
 
 	/* DH regular multi pipe - not continuous mode: create the next pipelines too */
-	if (!stream->config.continuous && stream->num_pipes > 1) {
+	if (!stream->config.continuous) {
 		int i;
-		for (i = 1; i < stream->num_pipes; i++) {
+		for (i = 1; i < stream->num_pipes && IA_CSS_SUCCESS == err; i++) {
 			switch (stream->pipes[i]->mode) {
 			case IA_CSS_PIPE_ID_PREVIEW:
 				err = create_host_preview_pipeline(stream->pipes[i]);
@@ -2280,8 +2229,7 @@ create_host_pipeline(struct ia_css_stream *stream)
 	}
 
 ERR:
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"create_host_pipeline() leave: return (%d)\n", err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
@@ -2296,7 +2244,10 @@ init_pipe_defaults(enum ia_css_pipe_mode mode,
 	static struct ia_css_video_settings   video = IA_CSS_DEFAULT_VIDEO_SETTINGS;
 	static struct ia_css_yuvpp_settings   yuvpp = IA_CSS_DEFAULT_YUVPP_SETTINGS;
 
-	assert(pipe != NULL);
+	if (pipe == NULL) {
+		IA_CSS_ERROR("NULL pipe parameter");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	/* Initialize pipe to pre-defined defaults */
 	*pipe = default_pipe;
@@ -2347,14 +2298,17 @@ pipe_global_init(void)
 	}
 }
 
-static uint8_t
-pipe_generate_pipe_num(const struct ia_css_pipe *pipe)
+static enum ia_css_err
+pipe_generate_pipe_num(const struct ia_css_pipe *pipe, unsigned int *pipe_number)
 {
 	const uint8_t INVALID_PIPE_NUM = (uint8_t)~(0);
 	uint8_t pipe_num = INVALID_PIPE_NUM;
 	uint8_t i;
 
-	assert(pipe != NULL);
+	if (pipe == NULL) {
+		IA_CSS_ERROR("NULL pipe parameter");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	/* Assign a new pipe_num .... search for empty place */
 	for (i = 0; i < IA_CSS_PIPELINE_NUM_MAX; i++) {
@@ -2365,13 +2319,18 @@ pipe_generate_pipe_num(const struct ia_css_pipe *pipe)
 			break;
 		}
 	}
-	assert(pipe_num != INVALID_PIPE_NUM);
+	if (pipe_num == INVALID_PIPE_NUM) {
+		/* Max number of pipes already allocated */
+		IA_CSS_ERROR("Max number of pipes already created");
+		return IA_CSS_ERR_RESOURCE_EXHAUSTED;
+	}
+
 	my_css.pipe_counter++;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"pipe_generate_pipe_num (%d)\n", pipe_num);
+	IA_CSS_LOG("pipe_num (%d)", pipe_num);
 
-	return pipe_num;
+	*pipe_number = pipe_num;
+	return IA_CSS_SUCCESS;
 }
 
 static void
@@ -2389,20 +2348,29 @@ create_pipe(enum ia_css_pipe_mode mode,
 	    bool copy_pipe)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
-	struct ia_css_pipe *me = sh_css_malloc(sizeof(*me));
+	struct ia_css_pipe *me;
 
-	assert(pipe != NULL);
+	if (pipe == NULL) {
+		IA_CSS_ERROR("NULL pipe parameter");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
+	me = sh_css_malloc(sizeof(*me));
 	if (!me)
 		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
 
 	err = init_pipe_defaults(mode, me, copy_pipe);
 	if (err != IA_CSS_SUCCESS) {
 		sh_css_free(me);
-		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		return err;
+	}
+
+	err = pipe_generate_pipe_num(me, &(me->pipe_num));
+	if (err != IA_CSS_SUCCESS) {
+		sh_css_free(me);
+		return err;
 	}
 
-	me->pipe_num = pipe_generate_pipe_num(me);
 	*pipe = me;
 	return IA_CSS_SUCCESS;
 }
@@ -2772,8 +2740,12 @@ alloc_continuous_frames(
 	uint8_t raw_binning = 0;
 	struct ia_css_pipe *capture_pipe = NULL;
 
-	assert(pipe != NULL);
-	assert(pipe->stream != NULL);
+	IA_CSS_ENTER_PRIVATE("pipe = %p, init_time = %d", pipe, init_time);
+
+	if ((pipe == NULL) || (pipe->stream == NULL)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	pipe_id = pipe->mode;
 	continuous = pipe->stream->config.continuous;
@@ -2801,7 +2773,7 @@ alloc_continuous_frames(
 	}
 	else {
 		/* should not happen */
-		assert(false);
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INTERNAL_ERROR);
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	}
 
@@ -2836,12 +2808,12 @@ alloc_continuous_frames(
 		capture_pipe = pipe->pipe_settings.video.capture_pipe;
 	} else {
 		/* should not happen */
-		assert(false);
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INTERNAL_ERROR);
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	}
 
 	if (init_time)
-	    idx = 0;
+		idx = 0;
 	else
 		idx = pipe->stream->config.init_num_cont_raw_buf;
 
@@ -2861,13 +2833,16 @@ alloc_continuous_frames(
 			err = ia_css_frame_allocate_from_info(
 				&pipe->continuous_frames[i],
 				&ref_info);
-			if (err != IA_CSS_SUCCESS)
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
+			}
 			/* allocate metadata buffer */
 			pipe->cont_md_buffers[i] = ia_css_metadata_allocate(
 					&pipe->stream->info.metadata_info);
 		}
 	}
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
 	return IA_CSS_SUCCESS;
 }
 
@@ -2973,7 +2948,7 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 	 * then the preview binary selection is done again.
 	 */
 	if (need_vf_pp &&
-	    (pipe->pipe_settings.preview.preview_binary.out_frame_info[0].format != IA_CSS_FRAME_FORMAT_YUV_LINE)) {
+		(pipe->pipe_settings.preview.preview_binary.out_frame_info[0].format != IA_CSS_FRAME_FORMAT_YUV_LINE)) {
 
 		/* Preview step 2 */
 		if (pipe->vf_yuv_ds_input_info.res.width)
@@ -2982,7 +2957,7 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 			prev_vf_info = *pipe_out_info;
 
 		ia_css_frame_info_set_format(&prev_vf_info,
-					     IA_CSS_FRAME_FORMAT_YUV_LINE);
+			IA_CSS_FRAME_FORMAT_YUV_LINE);
 
 		err = ia_css_pipe_get_preview_binarydesc(
 				pipe,
@@ -2994,7 +2969,7 @@ load_preview_binaries(struct ia_css_pipe *pipe)
 		if (err != IA_CSS_SUCCESS)
 			return err;
 		err = ia_css_binary_find(&preview_descr,
-					 &pipe->pipe_settings.preview.preview_binary);
+				&pipe->pipe_settings.preview.preview_binary);
 		if (err != IA_CSS_SUCCESS)
 			return err;
 	}
@@ -3044,17 +3019,21 @@ ia_css_binary_unload(struct ia_css_binary *binary)
 	ia_css_binary_destroy_isp_parameters(binary);
 }
 
-static void
+static enum ia_css_err
 unload_preview_binaries(struct ia_css_pipe *pipe)
 {
-	IA_CSS_ENTER_PRIVATE("");
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
 
-	assert(pipe->mode == IA_CSS_PIPE_ID_PREVIEW);
+	if ((pipe == NULL) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	ia_css_binary_unload(&pipe->pipe_settings.preview.copy_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.preview.preview_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.preview.vf_pp_binary);
 
-	IA_CSS_LEAVE_PRIVATE("");
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
 }
 
 static const struct ia_css_fw_info *last_output_firmware(
@@ -3466,8 +3445,6 @@ ia_css_get_crop_offsets (
 }
 #endif
 
-
-
 static enum ia_css_err
 init_in_frameinfo_memory_defaults(struct ia_css_pipe *pipe,
 	struct ia_css_frame *frame, enum ia_css_frame_format format)
@@ -3575,7 +3552,7 @@ static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
 	struct ia_css_frame *in_frame = NULL;
 	struct ia_css_frame *out_frame;
 	struct ia_css_frame *out_frames[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
-	struct ia_css_frame *vf_frame;
+	struct ia_css_frame *vf_frame = NULL;
 	enum ia_css_err err = IA_CSS_SUCCESS;
 	bool need_copy   = false;
 	bool need_vf_pp  = false;
@@ -3586,18 +3563,13 @@ static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
 	unsigned int i, num_yuv_scaler;
 	bool *is_output_stage = NULL;
 
-	IA_CSS_ENTER_PRIVATE("");
-	assert(pipe != NULL);
-	assert(pipe->stream != NULL);
-	assert(pipe->mode == IA_CSS_PIPE_ID_VIDEO);
-
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if ((pipe == NULL) || (pipe->stream == NULL) || (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	ia_css_pipe_util_create_output_frames(out_frames);
-	in_frame = &pipe->in_frame_struct;
 	out_frame = &pipe->out_frame_struct;
-	vf_frame = &pipe->vf_frame_struct;
-
-	pipe->out_frame_struct.data = 0;
-	pipe->vf_frame_struct.data = 0;
 
 	/* pipeline already created as part of create_host_pipeline_structure */
 	me = &pipe->pipeline;
@@ -3617,11 +3589,10 @@ static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
 
 	/* Construct in_frame info (only in case we have dynamic input */
 	if (need_in_frameinfo_memory) {
+		in_frame = &pipe->in_frame_struct;
 		err = init_in_frameinfo_memory_defaults(pipe, in_frame, IA_CSS_FRAME_FORMAT_RAW);
 		if (err != IA_CSS_SUCCESS)
 			goto ERR;
-	} else {
-		in_frame = NULL;
 	}
 
 	out_frame->data = 0;
@@ -3629,10 +3600,8 @@ static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
 	if (err != IA_CSS_SUCCESS)
 		goto ERR;
 
-	if (!pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {
-		/* These situations don't support viewfinder output */
-		vf_frame = NULL;
-	} else {
+	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0]) {
+		vf_frame = &pipe->vf_frame_struct;
 		vf_frame->data = 0;
 		err = init_vf_frameinfo_defaults(pipe, vf_frame, 0);
 		if (err != IA_CSS_SUCCESS)
@@ -3722,13 +3691,20 @@ static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
 	if (!need_vf_pp && video_stage && pipe->config.acc_extension &&
 		 (pipe->config.acc_extension->info.isp.type == IA_CSS_ACC_OUTPUT))
 	{
-		struct ia_css_frame *out = video_stage->args.out_frame[0];
+		struct ia_css_frame *out = NULL;
 		struct ia_css_frame *in = NULL;
 
-		err = ia_css_frame_allocate_from_info(&in, &(pipe->output_info[0]));
-		if (err != IA_CSS_SUCCESS)
-			goto ERR;
-		video_stage->args.out_frame[0] = in;
+		if ((pipe->config.acc_extension->info.isp.sp.enable.output) &&
+		    (pipe->config.acc_extension->info.isp.sp.enable.in_frame) &&
+		    (pipe->config.acc_extension->info.isp.sp.enable.out_frame)) {
+
+			/* In/Out Frame mapping to support output frame extension.*/
+			out = video_stage->args.out_frame[0];
+			err = ia_css_frame_allocate_from_info(&in, &(pipe->output_info[0]));
+			if (err != IA_CSS_SUCCESS)
+				goto ERR;
+			video_stage->args.out_frame[0] = in;
+		}
 
 		err = add_firmwares( me, video_binary, pipe->output_stage,
 					last_output_firmware(pipe->output_stage),
@@ -3752,8 +3728,10 @@ static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
 						   NULL,
 						   &yuv_scaler_binary[i],
 						   &post_stage);
-			if (err != IA_CSS_SUCCESS)
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
+			}
 			/* we use output port 1 as internal output port */
 			tmp_in_frame = post_stage->args.out_frame[1];
 		}
@@ -3763,8 +3741,7 @@ static enum ia_css_err create_host_video_pipeline(struct ia_css_pipe *pipe)
 	ia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);
 
 ERR:
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"create_host_video_pipeline() leave: return (%x)\n", err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
@@ -3774,11 +3751,11 @@ create_host_acc_pipeline(struct ia_css_pipe *pipe)
 	enum ia_css_err err = IA_CSS_SUCCESS;
 	unsigned int i;
 
-	assert(pipe != NULL);
-	assert(pipe->stream != NULL);
-
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"create_host_acc_pipeline() enter\n");
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if ((pipe == NULL) || (pipe->stream == NULL)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	pipe->pipeline.num_execs = pipe->config.acc_num_execs;
 	/* Reset pipe_qos_config to default disable all QOS extension stages */
@@ -3804,8 +3781,7 @@ create_host_acc_pipeline(struct ia_css_pipe *pipe)
 	ia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);
 
 ERR:
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"create_host_acc_pipeline() leave: return(%d)\n", err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
@@ -3830,10 +3806,11 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 	bool continuous = false;
 #endif
 
-	IA_CSS_ENTER_PRIVATE("");
-	assert(pipe != NULL);
-	assert(pipe->stream != NULL);
-	assert(pipe->mode == IA_CSS_PIPE_ID_PREVIEW);
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if ((pipe == NULL) || (pipe->stream == NULL) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 
 	ia_css_pipe_util_create_output_frames(out_frames);
@@ -3936,8 +3913,7 @@ create_host_preview_pipeline(struct ia_css_pipe *pipe)
 	ia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);
 
 ERR:
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-		"create_host_preview_pipeline() leave: return(%d)\n", err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
@@ -3972,10 +3948,11 @@ preview_start(struct ia_css_pipe *pipe)
 	enum sh_css_pipe_config_override copy_ovrd;
 	enum ia_css_input_mode preview_pipe_input_mode;
 
-	IA_CSS_ENTER_PRIVATE("");
-	assert(pipe != NULL);
-	assert(pipe->stream != NULL);
-	assert(pipe->mode == IA_CSS_PIPE_ID_PREVIEW);
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if ((pipe == NULL) || (pipe->stream == NULL) || (pipe->mode != IA_CSS_PIPE_ID_PREVIEW)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	me = &pipe->pipeline;
 
@@ -4073,13 +4050,12 @@ preview_start(struct ia_css_pipe *pipe)
 			);
 	}
 
-	err = start_pipe(pipe, copy_ovrd, preview_pipe_input_mode);
+	start_pipe(pipe, copy_ovrd, preview_pipe_input_mode);
 
 #if defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401)
 ERR:
 #endif
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"preview_start() leave: return (%d)\n", err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
@@ -4151,7 +4127,6 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	}
 
-	//ia_css_pipeline_get_sp_thread_id(pipe_id, &thread_id);
 	ret_err = ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
 	if (!ret_err) {
 		IA_CSS_LEAVE_ERR(IA_CSS_ERR_INVALID_ARGUMENTS);
@@ -4246,8 +4221,6 @@ ia_css_pipe_enqueue_buffer(struct ia_css_pipe *pipe,
 #endif
 	}
 
-
-
 	/* start of test for using rmgr for acq/rel memory */
 	p_vbuf.vptr = 0;
 	p_vbuf.count = 0;
@@ -4536,7 +4509,6 @@ ia_css_pipe_dequeue_buffer(struct ia_css_pipe *pipe,
 		}
 	}
 
-
 	/*
 	 * Tell the SP which queues are not full,
 	 * by sending the software event.
@@ -4582,6 +4554,7 @@ static enum ia_css_event_type convert_event_sp_to_host_domain[] = {
 	IA_CSS_EVENT_TYPE_METADATA_DONE,	/**< Metadata ready. */
 	IA_CSS_EVENT_TYPE_LACE_STATISTICS_DONE,	/**< Indication that LACE statistics are available. */
 	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE,	/**< Extension stage executed. */
+	IA_CSS_EVENT_TYPE_TIMER,		/**< Timing measurement data. */
 	IA_CSS_EVENT_TYPE_PORT_EOF,		/**< End Of Frame event, sent when in buffered sensor mode. */
 	IA_CSS_EVENT_TYPE_FW_ERROR,		/**< Unrecoverable error encountered by FW. */
 	IA_CSS_EVENT_TYPE_FW_WARNING,		/**< Performance warning encountered by FW */
@@ -4639,7 +4612,47 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	event->fw_error = IA_CSS_FW_SUCCESS;
 	event->fw_warning = IA_CSS_FW_WARNING_NONE;
 	event->fw_handle = 0;
-
+	event->timer_data = 0;
+	event->timer_code = 0;
+	event->timer_subcode = 0;
+
+	if (event->type == IA_CSS_EVENT_TYPE_TIMER) {
+		/* timer event  get the 2nd event and decode the data into the event struct */
+		uint32_t tmp_data;
+		/* 1st event: LSB 16-bit timer data and code */
+		event->timer_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));
+		event->timer_code = payload[2];
+		payload[0] = payload[1] = payload[2] = payload[3] = 0;
+		ret_err = ia_css_bufq_dequeue_psys_event(payload);
+		if (ret_err != IA_CSS_SUCCESS) {
+			/* no 2nd event  an error */
+			/* Putting IA_CSS_ERROR is resulting in failures in
+			 * Merrifield smoke testing  */
+			IA_CSS_WARNING("Timer: Error de-queuing the 2nd TIMER event!!!\n");
+			return ret_err;
+		}
+		ia_css_bufq_enqueue_psys_event(
+			IA_CSS_PSYS_SW_EVENT_EVENT_DEQUEUED, 0, 0, 0);
+		event->type = convert_event_sp_to_host_domain[payload[0]];
+		 /* It's a timer */
+		if (event->type == IA_CSS_EVENT_TYPE_TIMER) {
+			/* 2nd event data: MSB 16-bit timer and subcode */
+			tmp_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));
+			event->timer_data |= (tmp_data << 16);
+			event->timer_subcode = payload[2];
+		}
+		/* It's a non timer event. So clear first half of the timer event data.
+		* If the second part of the TIMER event is not recieved, we discard
+		* the first half of the timer data and process the non timer event without
+		* affecting the flow. So the non timer event falls through
+		* the code. */
+		else {
+			event->timer_data = 0;
+			event->timer_code = 0;
+			event->timer_subcode = 0;
+			IA_CSS_ERROR("Missing 2nd timer event. Timer event discarded");
+		}
+	}
 	if (event->type == IA_CSS_EVENT_TYPE_PORT_EOF) {
 		event->port = (enum ia_css_csi2_port)payload[1];
 		event->exp_id = payload[3];
@@ -4655,7 +4668,7 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 		event->fw_assert_module_id = payload[1]; /* module */
 		event->fw_assert_line_no = (payload[2] << 8) + payload[3];
 		/* payload[2] is line_no>>8, payload[3] is line_no&0xff */
-	} else {
+	} else if (event->type != IA_CSS_EVENT_TYPE_TIMER) {
 		/* pipe related events.
 		 * payload[1] contains the pipe_num,
 		 * payload[2] contains the pipe_id. These are different. */
@@ -4739,13 +4752,13 @@ ia_css_dequeue_isys_event(struct ia_css_event *event)
 	return err;
 }
 
-static enum ia_css_err
+static void
 acc_start(struct ia_css_pipe *pipe)
 {
 	assert(pipe != NULL);
 	assert(pipe->stream != NULL);
 
-	return start_pipe(pipe, SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD,
+	start_pipe(pipe, SH_CSS_PIPE_CONFIG_OVRD_NO_OVRD,
 			pipe->stream->config.mode);
 }
 
@@ -4758,19 +4771,23 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 	enum ia_css_pipe_id pipe_id;
 	unsigned int thread_id;
 
-	assert(stream != NULL);
+	IA_CSS_ENTER_PRIVATE("stream = %p", stream);
+
+	if (stream == NULL) {
+		IA_CSS_LEAVE_ERR(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	pipe = stream->last_pipe;
-	assert(pipe != NULL);
+	if (pipe == NULL) {
+		IA_CSS_LEAVE_ERR(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	pipe_id = pipe->mode;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"sh_css_pipe_start() enter: pipe_id=%d\n", pipe_id);
 
 	if(stream->started == true) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			"Cannot start stream that is already started\n");
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			"sh_css_pipe_start() leave: return_err=%d\n", err);
+		IA_CSS_WARNING("Cannot start stream that is already started");
+		IA_CSS_LEAVE_ERR(err);
 		return err;
 	}
 
@@ -4790,13 +4807,13 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 		err = yuvpp_start(pipe);
 		break;
 	case IA_CSS_PIPE_ID_ACC:
-		err = acc_start(pipe);
+		acc_start(pipe);
 		break;
 	default:
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 	}
 	/* DH regular multi pipe - not continuous mode: start the next pipes too */
-	if ((err == IA_CSS_SUCCESS) && (!stream->config.continuous) && (stream->num_pipes > 1)) {
+	if (!stream->config.continuous) {
 		int i;
 		for (i = 1; i < stream->num_pipes && IA_CSS_SUCCESS == err ; i++) {
 			switch (stream->pipes[i]->mode) {
@@ -4818,7 +4835,7 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 				break;
 			case IA_CSS_PIPE_ID_ACC:
 				stream->pipes[i]->stop_requested = false;
-				err = acc_start(stream->pipes[i]);
+				acc_start(stream->pipes[i]);
 				break;
 			default:
 				err = IA_CSS_ERR_INVALID_ARGUMENTS;
@@ -4839,8 +4856,10 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 		sh_css_invalidate_params(stream);
 		err = sh_css_param_update_isp_params(pipe,
 							stream->isp_params_configs, true, NULL);
-		if (err != IA_CSS_SUCCESS)
+		if (err != IA_CSS_SUCCESS) {
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
+		}
 	}
 
 	ia_css_debug_pipe_graph_dump_epilogue();
@@ -4848,9 +4867,7 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 	ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(pipe), &thread_id);
 
 	if (!sh_css_sp_is_running()) {
-		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
-			"sh_css_pipe_start() leaving:"
-			"queue unavailable\n");
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_RESOURCE_NOT_AVAILABLE);
 		/* SP is not running. The queues are not valid */
 		return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
 	}
@@ -4858,16 +4875,16 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 				       (uint8_t)thread_id, 0, 0);
 
 	/* DH regular multi pipe - not continuous mode: enqueue event to the next pipes too */
-	if ((stream->num_pipes > 1) && (!stream->config.continuous)) {
-			int i;
-			for (i = 1; i < stream->num_pipes; i++) {
-				ia_css_pipeline_get_sp_thread_id(
-								ia_css_pipe_get_pipe_num(stream->pipes[i]),
-								&thread_id);
-				ia_css_bufq_enqueue_psys_event(
-					IA_CSS_PSYS_SW_EVENT_START_STREAM,
-					(uint8_t)thread_id, 0, 0);
-			}
+	if (!stream->config.continuous) {
+		int i;
+		for (i = 1; i < stream->num_pipes; i++) {
+			ia_css_pipeline_get_sp_thread_id(
+							ia_css_pipe_get_pipe_num(stream->pipes[i]),
+							&thread_id);
+			ia_css_bufq_enqueue_psys_event(
+				IA_CSS_PSYS_SW_EVENT_START_STREAM,
+				(uint8_t)thread_id, 0, 0);
+		}
 	}
 
 	/* in case of continuous capture mode, we also start capture thread and copy thread*/
@@ -4879,9 +4896,10 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 		else if (pipe_id == IA_CSS_PIPE_ID_VIDEO)
 			copy_pipe = pipe->pipe_settings.video.copy_pipe;
 
-		assert(copy_pipe != NULL);
-		if (copy_pipe == NULL)
+		if (copy_pipe == NULL) {
+			IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INTERNAL_ERROR);
 			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
 		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(copy_pipe), &thread_id);
 		 /* by the time we reach here q is initialized and handle is available.*/
 		ia_css_bufq_enqueue_psys_event(
@@ -4895,9 +4913,10 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 		else if (pipe_id == IA_CSS_PIPE_ID_VIDEO)
 			capture_pipe = pipe->pipe_settings.video.capture_pipe;
 
-		assert(capture_pipe != NULL);
-		if (capture_pipe == NULL)
+		if (capture_pipe == NULL) {
+			IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INTERNAL_ERROR);
 			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
 		ia_css_pipeline_get_sp_thread_id(ia_css_pipe_get_pipe_num(capture_pipe), &thread_id);
 		 /* by the time we reach here q is initialized and handle is available.*/
 		ia_css_bufq_enqueue_psys_event(
@@ -4921,7 +4940,7 @@ sh_css_pipe_start(struct ia_css_stream *stream)
 
 	stream->started = true;
 
-	IA_CSS_LEAVE_ERR(err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
@@ -5007,12 +5026,18 @@ static enum ia_css_err sh_css_pipe_configure_output(
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	assert(pipe != NULL);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_configure_output() enter:\n");
+	IA_CSS_ENTER_PRIVATE("pipe = %p, width = %d, height = %d, paddaed width = %d, format = %d, idx = %d",
+			     pipe, width, height, padded_width, format, idx);
+	if (pipe == NULL) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	err = ia_css_util_check_res(width, height);
-	if (err != IA_CSS_SUCCESS)
+	if (err != IA_CSS_SUCCESS) {
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
+	}
 	if (pipe->output_info[idx].res.width != width ||
 	    pipe->output_info[idx].res.height != height ||
 	    pipe->output_info[idx].format != format)
@@ -5024,6 +5049,7 @@ static enum ia_css_err sh_css_pipe_configure_output(
 				format,
 				padded_width);
 	}
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
 	return IA_CSS_SUCCESS;
 }
 
@@ -5088,6 +5114,20 @@ sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
 	else
 		memset(&info->dvs_grid, 0, sizeof(info->dvs_grid));
 
+	if (binary != NULL) {
+		/* copy pipe does not have ISP binary*/
+		info->isp_in_width = binary->internal_frame_info.res.width;
+		info->isp_in_height = binary->internal_frame_info.res.height;
+	}
+
+#if defined(HAS_VAMEM_VERSION_2)
+	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
+#elif defined(HAS_VAMEM_VERSION_1)
+	info->vamem_type = IA_CSS_VAMEM_TYPE_1;
+#else
+#error "Unknown VAMEM version"
+#endif
+
 	return err;
 }
 
@@ -5206,8 +5246,13 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 				&cas_scaler_descr.vf_info[i]);
 			err = ia_css_binary_find(&yuv_scaler_descr,
 						&mycs->yuv_scaler_binary[i]);
-			if (err != IA_CSS_SUCCESS)
+			if (err != IA_CSS_SUCCESS) {
+				if (mycs->is_output_stage != NULL) {
+					sh_css_free(mycs->is_output_stage);
+					mycs->is_output_stage = NULL;
+				}
 				return err;
+			}
 		}
 		ia_css_pipe_destroy_cas_scaler_desc(&cas_scaler_descr);
 	}
@@ -5266,6 +5311,9 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 
 			ia_css_frame_info_set_format(video_vf_info,
 					IA_CSS_FRAME_FORMAT_YUV_LINE);
+
+			ia_css_binary_destroy_isp_parameters(&mycs->video_binary);
+
 			err = ia_css_binary_find(&video_descr,
 						&mycs->video_binary);
 
@@ -5389,14 +5437,16 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	return IA_CSS_SUCCESS;
 }
 
-static void
+static enum ia_css_err
 unload_video_binaries(struct ia_css_pipe *pipe)
 {
 	unsigned int i;
-	IA_CSS_ENTER_PRIVATE("");
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
 
-	assert(pipe != NULL);
-	assert(pipe->mode == IA_CSS_PIPE_ID_VIDEO);
+	if ((pipe == NULL) || (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	ia_css_binary_unload(&pipe->pipe_settings.video.copy_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.video.video_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.video.vf_pp_binary);
@@ -5410,7 +5460,8 @@ unload_video_binaries(struct ia_css_pipe *pipe)
 	sh_css_free(pipe->pipe_settings.video.yuv_scaler_binary);
 	pipe->pipe_settings.video.yuv_scaler_binary = NULL;
 
-	IA_CSS_LEAVE_PRIVATE("");
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
 }
 
 static enum ia_css_err video_start(struct ia_css_pipe *pipe)
@@ -5422,9 +5473,11 @@ static enum ia_css_err video_start(struct ia_css_pipe *pipe)
 	enum ia_css_input_mode video_pipe_input_mode;
 
 
-	IA_CSS_ENTER_PRIVATE("");
-	assert(pipe != NULL);
-	assert(pipe->mode == IA_CSS_PIPE_ID_VIDEO);
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if ((pipe == NULL) || (pipe->mode != IA_CSS_PIPE_ID_VIDEO)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	video_pipe_input_mode = pipe->stream->config.mode;
 
@@ -5498,7 +5551,7 @@ static enum ia_css_err video_start(struct ia_css_pipe *pipe)
 			);
 	}
 
-	err = start_pipe(pipe, copy_ovrd, video_pipe_input_mode);
+	start_pipe(pipe, copy_ovrd, video_pipe_input_mode);
 
 	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
@@ -5542,15 +5595,19 @@ sh_css_pipe_configure_viewfinder(struct ia_css_pipe *pipe, unsigned int width,
 				 unsigned int idx)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
-	assert(pipe != NULL);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"sh_css_pipe_configure_viewfinder() enter: \
-		width=%d, height=%d format=%d\n",
-		width, height, format);
+
+	IA_CSS_ENTER_PRIVATE("pipe = %p, width = %d, height = %d, min_width = %d, format = %d, idx = %d\n",
+			     pipe, width, height, min_width, format, idx);
+
+	if (pipe == NULL) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
 
 	err = ia_css_util_check_res(width, height);
 	if (err != IA_CSS_SUCCESS) {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_configure_viewfinder() leave: return_err=%d\n",err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
 	}
 	if (pipe->vf_output_info[idx].res.width != width ||
@@ -5559,7 +5616,7 @@ sh_css_pipe_configure_viewfinder(struct ia_css_pipe *pipe, unsigned int width,
 		ia_css_frame_info_init(&pipe->vf_output_info[idx], width, height,
 				       format, min_width);
 	}
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_configure_viewfinder() leave: return_err=%d\n",IA_CSS_SUCCESS);
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
 	return IA_CSS_SUCCESS;
 }
 
@@ -6163,13 +6220,16 @@ static enum ia_css_err load_capture_binaries(
 	return err;
 }
 
-static void
+static enum ia_css_err
 unload_capture_binaries(struct ia_css_pipe *pipe)
 {
 	unsigned int i;
-	IA_CSS_ENTER_PRIVATE("");
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
 
-	assert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE || pipe->mode == IA_CSS_PIPE_ID_COPY);
+	if ((pipe == NULL) || ((pipe->mode != IA_CSS_PIPE_ID_CAPTURE) && (pipe->mode != IA_CSS_PIPE_ID_COPY))) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	ia_css_binary_unload(&pipe->pipe_settings.capture.copy_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.primary_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.pre_isp_binary);
@@ -6186,7 +6246,8 @@ unload_capture_binaries(struct ia_css_pipe *pipe)
 	sh_css_free(pipe->pipe_settings.capture.yuv_scaler_binary);
 	pipe->pipe_settings.capture.yuv_scaler_binary = NULL;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "unload_capture_binaries() leave:\n");
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
 }
 
 static bool
@@ -6482,7 +6543,6 @@ static enum ia_css_err ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pi
 				descr->vf_info[i].res.height = 0;
 				descr->vf_info[i].padded_width = 0;
 			}
-			//descr->vf_info[i].format = tmp_vf_out_info[j]->format;
 			j++;
 		} else {
 			descr->is_output_stage[i] = false;
@@ -6561,12 +6621,6 @@ load_yuvpp_binaries(struct ia_css_pipe *pipe)
 
 	need_scaler = need_yuv_scaler_stage(pipe);
 
-	/* we use the vf output info to get the primary/capture_pp binary
-	   configured for vf_veceven. It will select the closest downscaling
-	   factor. */
-	//vf_info = pipe->vf_output_info;
-	//ia_css_frame_info_set_format(&vf_info, IA_CSS_FRAME_FORMAT_YUV_LINE);
-
 	/* we build up the pipeline starting at the end */
 	/* Capture post-processing */
 	if (need_scaler) {
@@ -6717,13 +6771,16 @@ ERR:
 	return err;
 }
 
-static void
+static enum ia_css_err
 unload_yuvpp_binaries(struct ia_css_pipe *pipe)
 {
 	unsigned int i;
-	IA_CSS_ENTER_PRIVATE("");
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
 
-	assert(pipe->mode == IA_CSS_PIPE_ID_YUVPP);
+	if ((pipe == NULL) || (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	ia_css_binary_unload(&pipe->pipe_settings.yuvpp.copy_binary);
 	for (i = 0; i < pipe->pipe_settings.yuvpp.num_yuv_scaler; i++) {
 		ia_css_binary_unload(&pipe->pipe_settings.yuvpp.yuv_scaler_binary[i]);
@@ -6738,7 +6795,8 @@ unload_yuvpp_binaries(struct ia_css_pipe *pipe)
 	sh_css_free(pipe->pipe_settings.yuvpp.vf_pp_binary);
 	pipe->pipe_settings.yuvpp.vf_pp_binary = NULL;
 
-	IA_CSS_LEAVE_PRIVATE("");
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
+	return IA_CSS_SUCCESS;
 }
 
 static enum ia_css_err yuvpp_start(struct ia_css_pipe *pipe)
@@ -6748,10 +6806,11 @@ static enum ia_css_err yuvpp_start(struct ia_css_pipe *pipe)
 	enum sh_css_pipe_config_override copy_ovrd;
 	enum ia_css_input_mode yuvpp_pipe_input_mode;
 
-	IA_CSS_ENTER_PRIVATE("");
-	assert(pipe != NULL);
-	assert(pipe->mode == IA_CSS_PIPE_ID_YUVPP);
-
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if ((pipe == NULL) || (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	yuvpp_pipe_input_mode = pipe->stream->config.mode;
 
@@ -6763,8 +6822,10 @@ static enum ia_css_err yuvpp_start(struct ia_css_pipe *pipe)
 
 #if !defined(HAS_NO_INPUT_SYSTEM) && ( defined(USE_INPUT_SYSTEM_VERSION_2) || defined(USE_INPUT_SYSTEM_VERSION_2401) )
 	err = send_mipi_frames(pipe);
-	if (err != IA_CSS_SUCCESS)
+	if (err != IA_CSS_SUCCESS) {
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
+	}
 #endif
 
 	{
@@ -6774,40 +6835,46 @@ static enum ia_css_err yuvpp_start(struct ia_css_pipe *pipe)
 		copy_ovrd = 1 << thread_id;
 	}
 
-	err = start_pipe(pipe, copy_ovrd, yuvpp_pipe_input_mode);
+	start_pipe(pipe, copy_ovrd, yuvpp_pipe_input_mode);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"video_start() leave: return (%d)\n", err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
-static void
+static enum ia_css_err
 sh_css_pipe_unload_binaries(struct ia_css_pipe *pipe)
 {
-	assert(pipe != NULL);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_binaries() enter:\n");
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
 
+	if (pipe == NULL) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	/* PIPE_MODE_COPY has no binaries, but has output frames to outside*/
-	if (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)
-		return;
+	if (pipe->config.mode == IA_CSS_PIPE_MODE_COPY) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
+		return IA_CSS_SUCCESS;
+	}
 
 	switch (pipe->mode) {
 	case IA_CSS_PIPE_ID_PREVIEW:
-		unload_preview_binaries(pipe);
+		err = unload_preview_binaries(pipe);
 		break;
 	case IA_CSS_PIPE_ID_VIDEO:
-		unload_video_binaries(pipe);
+		err = unload_video_binaries(pipe);
 		break;
 	case IA_CSS_PIPE_ID_CAPTURE:
-		unload_capture_binaries(pipe);
+		err = unload_capture_binaries(pipe);
 		break;
 	case IA_CSS_PIPE_ID_YUVPP:
-		unload_yuvpp_binaries(pipe);
+		err = unload_yuvpp_binaries(pipe);
 		break;
 	default:
 		break;
 	}
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_binaries() leave:\n");
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
+	return err;
 }
 
 static enum ia_css_err
@@ -6842,7 +6909,7 @@ sh_css_pipe_load_binaries(struct ia_css_pipe *pipe)
 		break;
 	}
 	if (err != IA_CSS_SUCCESS)
-		sh_css_pipe_unload_binaries(pipe);
+		err = sh_css_pipe_unload_binaries(pipe);
 	return err;
 }
 
@@ -6873,11 +6940,11 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 	bool continuous = false;
 #endif
 
-	IA_CSS_ENTER_PRIVATE("");
-	assert(pipe != NULL);
-	assert(pipe->stream != NULL);
-	assert(pipe->mode == IA_CSS_PIPE_ID_YUVPP);
-
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if ((pipe == NULL) || (pipe->stream == NULL) || (pipe->mode != IA_CSS_PIPE_ID_YUVPP)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 	me = &pipe->pipeline;
 	ia_css_pipeline_clean(me);
 	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
@@ -6948,8 +7015,11 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 		err = init_in_frameinfo_memory_defaults(pipe,
 			&me->in_frame,
 			in_frame_format);
-		if (err != IA_CSS_SUCCESS)
+
+		if (err != IA_CSS_SUCCESS) {
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
+		}
 
 		in_frame = &me->in_frame;
 	} else {
@@ -6960,16 +7030,20 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 		assert(i < IA_CSS_PIPE_MAX_OUTPUT_STAGE);
 		if (pipe->output_info[i].res.width != 0) {
 			err = init_out_frameinfo_defaults(pipe, &me->out_frame[i], i);
-			if (err != IA_CSS_SUCCESS)
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
+			}
 			out_frame[i] = &me->out_frame[i];
 		}
 
 		/* Construct vf_frame info (only in case we have VF) */
 		if (pipe->vf_output_info[i].res.width != 0) {
 			err = init_vf_frameinfo_defaults(pipe, &me->vf_frame[i], i);
-			if (err != IA_CSS_SUCCESS)
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
+			}
 			vf_frame[i] = &me->vf_frame[i];
 		}
 	}
@@ -7002,8 +7076,10 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 		err = ia_css_pipeline_create_and_add_stage(me,
 			&stage_desc,
 			&post_stage);
-		if (err != IA_CSS_SUCCESS)
+		if (err != IA_CSS_SUCCESS) {
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
+		}
 
 		if (post_stage) {
 			/* if we use yuv scaler binary, vf output should be from there */
@@ -7034,16 +7110,20 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 						   NULL,
 						   &yuv_scaler_binary[i],
 						   &post_stage);
-			if (err != IA_CSS_SUCCESS)
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				return err;
+			}
 			/* we use output port 1 as internal output port */
 			tmp_in_frame = post_stage->args.out_frame[1];
 			if (pipe->pipe_settings.yuvpp.is_output_stage[i] == true) {
 				if (tmp_vf_frame && (tmp_vf_frame->info.res.width != 0)) {
 					err = add_vf_pp_stage(pipe, tmp_vf_frame, &vf_pp_binary[j],
 						      post_stage, &vf_pp_stage);
-					if (err != IA_CSS_SUCCESS)
+					if (err != IA_CSS_SUCCESS) {
+						IA_CSS_LEAVE_ERR_PRIVATE(err);
 						return err;
+					}
 				}
 				j++;
 			}
@@ -7053,14 +7133,15 @@ create_host_yuvpp_pipeline(struct ia_css_pipe *pipe)
 			err = add_vf_pp_stage(pipe, vf_frame[0], &vf_pp_binary[0],
 				      post_stage, &vf_pp_stage);
 		}
-		if (err != IA_CSS_SUCCESS)
+		if (err != IA_CSS_SUCCESS) {
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
+		}
 	}
 
 	ia_css_pipeline_finalize_stages(&pipe->pipeline, pipe->stream->config.continuous);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"create_host_yuvpp_pipeline() leave:\n");
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
 
 	return IA_CSS_SUCCESS;
 }
@@ -7425,18 +7506,18 @@ create_host_capture_pipeline(struct ia_css_pipe *pipe)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"create_host_capture_pipeline() enter:\n");
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
 
 	if (pipe->config.mode == IA_CSS_PIPE_MODE_COPY)
 		err = create_host_isyscopy_capture_pipeline(pipe);
 	else
 		err = create_host_regular_capture_pipeline(pipe);
-	if (err != IA_CSS_SUCCESS)
+	if (err != IA_CSS_SUCCESS) {
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
+	}
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"create_host_capture_pipeline() leave:\n");
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 
 	return err;
 }
@@ -7449,29 +7530,38 @@ static enum ia_css_err capture_start(
 	enum ia_css_err err = IA_CSS_SUCCESS;
 	enum sh_css_pipe_config_override copy_ovrd;
 
-	assert(pipe != NULL);
+	IA_CSS_ENTER_PRIVATE("pipe = %p", pipe);
+	if (pipe == NULL) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	me = &pipe->pipeline;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "capture_start() enter:\n");
 
 	if ((pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_RAW   ||
 	     pipe->config.default_capture_config.mode == IA_CSS_CAPTURE_MODE_BAYER   ) &&
 		(pipe->config.mode != IA_CSS_PIPE_MODE_COPY)) {
 		if (copy_on_sp(pipe)) {
-			return start_copy_on_sp(pipe, &me->out_frame[0]);
+			err = start_copy_on_sp(pipe, &me->out_frame[0]);
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
+			return err;
 		}
 	}
 
 #if defined(USE_INPUT_SYSTEM_VERSION_2)
 	/* old isys: need to send_mipi_frames() in all pipe modes */
 	err = send_mipi_frames(pipe);
-	if (err != IA_CSS_SUCCESS)
+	if (err != IA_CSS_SUCCESS) {
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
+	}
 #elif defined(USE_INPUT_SYSTEM_VERSION_2401)
 	if (pipe->config.mode != IA_CSS_PIPE_MODE_COPY) {
 		err = send_mipi_frames(pipe);
-		if (err != IA_CSS_SUCCESS)
+		if (err != IA_CSS_SUCCESS) {
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
+		}
 	}
 
 #endif
@@ -7483,7 +7573,7 @@ static enum ia_css_err capture_start(
 		copy_ovrd = 1 << thread_id;
 
 	}
-	err = start_pipe(pipe, copy_ovrd, pipe->stream->config.mode);
+	start_pipe(pipe, copy_ovrd, pipe->stream->config.mode);
 
 #if !defined(HAS_NO_INPUT_SYSTEM) && !defined(USE_INPUT_SYSTEM_VERSION_2401)
 	/*
@@ -7497,8 +7587,7 @@ static enum ia_css_err capture_start(
 	}
 #endif
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
-		"capture_start() leave: return (%d)\n", err);
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 
 }
@@ -7609,12 +7698,17 @@ ia_css_stream_end_input_frame(const struct ia_css_stream *stream)
 static void
 append_firmware(struct ia_css_fw_info **l, struct ia_css_fw_info *firmware)
 {
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "append_firmware() enter:\n");
+	IA_CSS_ENTER_PRIVATE("l = %p, firmware = %p", l , firmware);
+	if (l == NULL) {
+		IA_CSS_ERROR("NULL fw_info");
+		IA_CSS_LEAVE_PRIVATE("");
+		return;
+	}
 	while (*l)
 		l = &(*l)->next;
 	*l = firmware;
 	/*firmware->next = NULL;*/ /* when multiple acc extensions are loaded, 'next' can be not NULL */
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "append_firmware() leave:\n");
+	IA_CSS_LEAVE_PRIVATE("");
 }
 
 static void
@@ -7634,7 +7728,14 @@ remove_firmware(struct ia_css_fw_info **l, struct ia_css_fw_info *firmware)
 static enum ia_css_err
 upload_isp_code(struct ia_css_fw_info *firmware)
 {
-	hrt_vaddress binary = firmware->info.isp.xmem_addr;
+	hrt_vaddress binary;
+
+	if (firmware == NULL) {
+		IA_CSS_ERROR("NULL input parameter");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	binary = firmware->info.isp.xmem_addr;
+
 	if (!binary) {
 		unsigned size = firmware->blob.size;
 		const unsigned char *blob;
@@ -7704,17 +7805,32 @@ ia_css_pipe_load_extension(struct ia_css_pipe *pipe,
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	assert(firmware != NULL);
-	assert(pipe != NULL);
+	IA_CSS_ENTER_PRIVATE("fw = %p pipe = %p", firmware, pipe);
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_load_extension() enter:\n");
-	if (firmware->info.isp.type == IA_CSS_ACC_OUTPUT)
-		append_firmware(&pipe->output_stage, firmware);
+	if ((firmware == NULL) || (pipe == NULL)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	if (firmware->info.isp.type == IA_CSS_ACC_OUTPUT) {
+		if (&pipe->output_stage != NULL)
+			append_firmware(&pipe->output_stage, firmware);
+		else {
+			IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INTERNAL_ERROR);
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
+	}
 	else if (firmware->info.isp.type == IA_CSS_ACC_VIEWFINDER) {
-		append_firmware(&pipe->vf_stage, firmware);
+		if (&pipe->vf_stage != NULL)
+			append_firmware(&pipe->vf_stage, firmware);
+		else {
+			IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INTERNAL_ERROR);
+			return IA_CSS_ERR_INTERNAL_ERROR;
+		}
 	}
 	err = acc_load_extension(firmware);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_load_extension() leave:\n");
+
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
 	return err;
 }
 
@@ -7723,15 +7839,21 @@ static void
 ia_css_pipe_unload_extension(struct ia_css_pipe *pipe,
 			     struct ia_css_fw_info *firmware)
 {
-	assert(firmware != NULL);
-	assert(pipe != NULL);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() enter:\n");
+	IA_CSS_ENTER_PRIVATE("fw = %p pipe = %p", firmware, pipe);
+
+	if ((firmware == NULL) || (pipe == NULL)) {
+		IA_CSS_ERROR("NULL input parameters");
+		IA_CSS_LEAVE_PRIVATE("");
+		return;
+	}
+
 	if (firmware->info.isp.type == IA_CSS_ACC_OUTPUT)
 		remove_firmware(&pipe->output_stage, firmware);
 	else if (firmware->info.isp.type == IA_CSS_ACC_VIEWFINDER)
 		remove_firmware(&pipe->vf_stage, firmware);
 	acc_unload_extension(firmware);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_pipe_unload_extension() leave:\n");
+
+	IA_CSS_LEAVE_PRIVATE("");
 }
 
 bool
@@ -7973,7 +8095,10 @@ void ia_css_pipe_config_defaults(struct ia_css_pipe_config *pipe_config)
 void
 ia_css_pipe_extra_config_defaults(struct ia_css_pipe_extra_config *extra_config)
 {
-	assert(extra_config != NULL);
+	if (extra_config == NULL) {
+		IA_CSS_ERROR("NULL input parameter");
+		return;
+	}
 
 	extra_config->enable_raw_binning = false;
 	extra_config->enable_yuv_ds = false;
@@ -8002,14 +8127,17 @@ ia_css_acc_pipe_create(struct ia_css_pipe *pipe)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	assert(pipe != NULL);
+	if (pipe == NULL) {
+		IA_CSS_ERROR("NULL input parameter");
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
 
 	/* There is not meaning for num_execs = 0 semantically. Run atleast once. */
 	if (pipe->config.acc_num_execs == 0)
 		pipe->config.acc_num_execs = 1;
 
 	if (pipe->config.acc_extension) {
-		ia_css_pipe_load_extension(pipe, pipe->config.acc_extension);
+		err = ia_css_pipe_load_extension(pipe, pipe->config.acc_extension);
 	}
 
 	return err;
@@ -8035,16 +8163,27 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 	struct ia_css_pipe *internal_pipe = NULL;
 	unsigned int i;
 
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_pipe_create()\n");
-	ia_css_debug_dump_pipe_config(config);
-	ia_css_debug_dump_pipe_extra_config(extra_config);
+	IA_CSS_ENTER_PRIVATE("config = %p, extra_config = %p and pipe = %p", config, extra_config, pipe);
 
-	if (pipe == NULL)
+	/* do not allow to create more than the maximum limit */
+	if (my_css.pipe_counter >= IA_CSS_PIPELINE_NUM_MAX) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_RESOURCE_EXHAUSTED);
 		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	if ((pipe == NULL) || (config == NULL)) {
+		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+
+	ia_css_debug_dump_pipe_config(config);
+	ia_css_debug_dump_pipe_extra_config(extra_config);
 
 	err = create_pipe(config->mode, &internal_pipe, false);
-	if (internal_pipe == NULL)
-		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+	if (err != IA_CSS_SUCCESS) {
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
+		return err;
+	}
 
 	/* now we have a pipe structure to fill */
 	internal_pipe->config = *config;
@@ -8061,6 +8200,7 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 		if (!internal_pipe->config.acc_extension &&
 			internal_pipe->config.num_acc_stages == 0){ /* if no acc binary and no standalone stage */
 			*pipe = NULL;
+			IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
 			return IA_CSS_SUCCESS;
 		}
 		return ia_css_acc_pipe_create(internal_pipe);
@@ -8134,8 +8274,7 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 					internal_pipe->config.output_info[i].format,
 					i);
 			if (err != IA_CSS_SUCCESS) {
-				ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_pipe_create: "
-								"invalid output info\n");
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				sh_css_free(internal_pipe);
 				internal_pipe = NULL;
 				return err;
@@ -8153,8 +8292,7 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 					internal_pipe->config.vf_output_info[i].format,
 					i);
 			if (err != IA_CSS_SUCCESS) {
-				ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, "ia_css_pipe_create: "
-								"invalid vf output info\n");
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
 				sh_css_free(internal_pipe);
 				internal_pipe = NULL;
 				return err;
@@ -8162,14 +8300,20 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 		}
 	}
 	if (internal_pipe->config.acc_extension) {
-		ia_css_pipe_load_extension(internal_pipe,
+		err = ia_css_pipe_load_extension(internal_pipe,
 			internal_pipe->config.acc_extension);
+		if (err != IA_CSS_SUCCESS) {
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
+			sh_css_free(internal_pipe);
+			return err;
+		}
 	}
 	/* set all info to zeroes first */
 	memset(&internal_pipe->info, 0, sizeof(internal_pipe->info));
 
 	/* all went well, return the pipe */
 	*pipe = internal_pipe;
+	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
 	return IA_CSS_SUCCESS;
 }
 
@@ -8652,6 +8796,13 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		if (err != IA_CSS_SUCCESS)
 			goto ERR;
 
+#if defined(HAS_RES_MGR)
+		/* update acc configuration - striping info is ready */
+		err = ia_css_update_cfg_stripe_info(curr_pipe);
+		if (err != IA_CSS_SUCCESS)
+			goto ERR;
+#endif
+
 		/* handle each pipe */
 		pipe_info = &curr_pipe->info;
 		for (j = 0; j < IA_CSS_PIPE_MAX_OUTPUT_STAGE; j++) {
@@ -8738,10 +8889,10 @@ ia_css_stream_destroy(struct ia_css_stream *stream)
 	int i;
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
-	IA_CSS_ENTER("");
+	IA_CSS_ENTER_PRIVATE("stream = %p", stream);
 	if (stream == NULL) {
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
-		IA_CSS_LEAVE("stream is NULL: return_err=%d", err);
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
 		return err;
 	}
 
@@ -8795,7 +8946,7 @@ ia_css_stream_destroy(struct ia_css_stream *stream)
 
 		err = map_sp_threads(stream, false);
 		if (err != IA_CSS_SUCCESS) {
-			IA_CSS_LEAVE("map_sp_threads: return_err=%d", err);
+			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
 	}
@@ -8818,7 +8969,7 @@ ia_css_stream_destroy(struct ia_css_stream *stream)
 				IA_CSS_LOG("clearing stream on internal video copy pipe");
 				entry->pipe_settings.video.copy_pipe->stream = NULL;
 			}
-			sh_css_pipe_unload_binaries(entry);
+			err = sh_css_pipe_unload_binaries(entry);
 		}
 	}
 	/* free associated memory of stream struct */
@@ -8899,16 +9050,19 @@ enum ia_css_err
 ia_css_stream_start(struct ia_css_stream *stream)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_start()\n");
-	assert(stream != NULL);
-	assert(stream->last_pipe != NULL);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_start: starting %d\n",
-		stream->last_pipe->mode);
+	IA_CSS_ENTER("stream = %p", stream);
+	if ((stream == NULL) || (stream->last_pipe == NULL)) {
+		IA_CSS_LEAVE_ERR(IA_CSS_ERR_INVALID_ARGUMENTS);
+		return IA_CSS_ERR_INVALID_ARGUMENTS;
+	}
+	IA_CSS_LOG("starting %d", stream->last_pipe->mode);
 
 	/* Create host side pipeline. */
 	err = create_host_pipeline(stream);
-	if (err != IA_CSS_SUCCESS)
+	if (err != IA_CSS_SUCCESS) {
+		IA_CSS_LEAVE_ERR(err);
 		return err;
+	}
 
 #if !defined(HAS_NO_INPUT_SYSTEM)
 #if defined(USE_INPUT_SYSTEM_VERSION_2401)
@@ -8939,7 +9093,9 @@ ia_css_stream_start(struct ia_css_stream *stream)
 	}
 #endif /* !HAS_NO_INPUT_SYSTEM */
 
-	return sh_css_pipe_start(stream);
+	err = sh_css_pipe_start(stream);
+	IA_CSS_LEAVE_ERR(err);
+	return err;
 }
 
 enum ia_css_err
@@ -8953,9 +9109,6 @@ ia_css_stream_stop(struct ia_css_stream *stream)
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_stop: stopping %d\n",
 		stream->last_pipe->mode);
 
-	/* Check if this is the last pipe, if not return else stop everything */
-	//if (pipe_num_counter > 1) return IA_CSS_SUCCESS;
-
 #if !defined(HAS_NO_INPUT_SYSTEM) && defined(USE_INPUT_SYSTEM_VERSION_2)
 	/* De-initialize mipi size checks */
 	if (stream->config.mode == IA_CSS_INPUT_MODE_BUFFERED_SENSOR)
@@ -9731,4 +9884,3 @@ ia_css_pipe_get_qos_ext_state(struct ia_css_pipe *pipe, uint32_t fw_handle, bool
 	IA_CSS_LEAVE("err:%d handle:%u enable:%d", err, fw_handle, *enable);
 	return err;
 }
-
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c
index a9241bd..8f30ff4f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_firmware.c
@@ -54,10 +54,10 @@ struct fw_param {
 /* Warning: same order as SH_CSS_BINARY_ID_* */
 static struct firmware_header *firmware_header;
 
-/* The string STR(irci_master_20141129_0200) is a place holder
+/* The string STR(irci_master_20150107_1500) is a place holder
  * which will be replaced with the actual RELEASE_VERSION
  * during package generation. Please do not modify  */
-static const char *release_version = STR(irci_master_20141129_0200);
+static const char *release_version = STR(irci_master_20150107_1500);
 
 #define MAX_FW_REL_VER_NAME	300
 static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h
index 5691200..ad8f1b3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_internal.h
@@ -235,6 +235,7 @@ enum sh_css_sp_event_type {
 	SH_CSS_SP_EVENT_METADATA_DONE,
 	SH_CSS_SP_EVENT_LACE_STATISTICS_DONE,
 	SH_CSS_SP_EVENT_ACC_STAGE_COMPLETE,
+	SH_CSS_SP_EVENT_TIMER,
 	SH_CSS_SP_EVENT_PORT_EOF,
 	SH_CSS_SP_EVENT_FW_ERROR,
 	SH_CSS_SP_EVENT_FW_WARNING,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c
index 71fb553..f940e3b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.c
@@ -75,6 +75,7 @@
 #include "ctc/ctc_1.0/ia_css_ctc.host.h"
 #include "ob/ob_1.0/ia_css_ob.host.h"
 #include "raw/raw_1.0/ia_css_raw.host.h"
+#include "fixedbds/fixedbds_1.0/ia_css_fixedbds.host.h"
 #include "s3a/s3a_1.0/ia_css_s3a.host.h"
 #include "sc/sc_1.0/ia_css_sc.host.h"
 #include "sdis/sdis_1.0/ia_css_sdis.host.h"
@@ -1257,22 +1258,17 @@ static enum ia_css_err
 free_ia_css_isp_parameter_set_info(hrt_vaddress ptr);
 
 static enum ia_css_err
-sh_css_params_write_to_ddr_pipe_internal(
-		struct ia_css_pipe *pipe,
-		const struct ia_css_pipeline_stage *stage,
-		struct sh_css_ddr_address_map *ddr_map,
-		struct sh_css_ddr_address_map_size *ddr_map_size);
-
-static enum ia_css_err
 sh_css_params_write_to_ddr_internal(
+		struct ia_css_pipe *pipe,
 		unsigned pipe_id,
 		struct ia_css_isp_parameters *params,
 		const struct ia_css_pipeline_stage *stage,
 		struct sh_css_ddr_address_map *ddr_map,
 		struct sh_css_ddr_address_map_size *ddr_map_size);
 
-static struct ia_css_isp_parameters *
-sh_css_create_isp_params(struct ia_css_stream *stream);
+static enum ia_css_err
+sh_css_create_isp_params(struct ia_css_stream *stream,
+			 struct ia_css_isp_parameters **isp_params_out);
 
 static bool
 sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
@@ -2455,8 +2451,8 @@ sh_css_set_baa_config(struct ia_css_isp_parameters *params,
 	IA_CSS_ENTER_PRIVATE("config=%p", config);
 	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 
-	params->raw_config = *config;
-	params->config_changed[IA_CSS_RAW_ID] = true;
+	params->bds_config = *config;
+	params->config_changed[IA_CSS_BDS_ID] = true;
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
@@ -2473,7 +2469,7 @@ sh_css_get_baa_config(const struct ia_css_isp_parameters *params,
 
 	IA_CSS_ENTER_PRIVATE("config=%p", config);
 
-	*config = params->raw_config;
+	*config = params->bds_config;
 
 	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
 	IA_CSS_LEAVE_PRIVATE("void");
@@ -2604,6 +2600,7 @@ enum ia_css_err
 ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
 	struct ia_css_isp_config *config)
 {
+	struct ia_css_pipe *pipe_in = pipe;
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
 	IA_CSS_ENTER("pipe=%p", pipe);
@@ -2613,11 +2610,18 @@ ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config=%p\n", config);
 
-	sh_css_init_isp_params_from_config(pipe, pipe->stream->isp_params_configs, config);
-
-	/* Now commit all changes to the SP */
-	err = sh_css_param_update_isp_params(pipe, pipe->stream->isp_params_configs, sh_css_sp_is_running(), NULL);
+	/* When pipe config and stream configs are seperated the below assignement
+	 * pipe_in = NULL can be removed
+	 */
+	if(pipe->stream->config.continuous)
+		pipe_in = NULL;
 
+#if defined(SH_CSS_ENABLE_PER_FRAME_PARAMS)
+	if (config->output_frame)
+		err = sh_css_set_per_frame_isp_config_on_pipe(pipe->stream, config, pipe);
+	else
+#endif
+		err = sh_css_set_global_isp_config_on_pipe(pipe, config, pipe_in);
 	IA_CSS_LEAVE_ERR(err);
 	return err;
 }
@@ -2667,11 +2671,10 @@ sh_css_set_per_frame_isp_config_on_pipe(
 	*/
 	if (!stream->per_frame_isp_params_configs)
 	{
-		stream->per_frame_isp_params_configs = sh_css_create_isp_params(stream);
-		if (!stream->per_frame_isp_params_configs) {
-			IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_INTERNAL_ERROR);
-			return IA_CSS_ERR_INTERNAL_ERROR;
-		}
+		err = sh_css_create_isp_params(stream,
+					       &stream->per_frame_isp_params_configs);
+		if(err != IA_CSS_SUCCESS)
+			goto exit;
 		per_frame_config_created = true;
 	}
 
@@ -3098,12 +3101,10 @@ ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 #endif
 
 	stream->per_frame_isp_params_configs = NULL;
-	stream->isp_params_configs = sh_css_create_isp_params(stream);
-	if (!stream->isp_params_configs) {
-		IA_CSS_ERROR("out of memory");
-		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
-		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
-	}
+	err = sh_css_create_isp_params(stream,
+				       &stream->isp_params_configs);
+	if(err != IA_CSS_SUCCESS)
+		 goto ERR;
 
 	params = stream->isp_params_configs;
 	sh_css_init_isp_params_from_global(stream, params, true);
@@ -3115,20 +3116,15 @@ ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 	sh_css_set_default_product_specific(stream);
 #endif
 
-	/* now commit to ddr */
-	err = sh_css_param_update_isp_params(stream->pipes[0], params, false, NULL);
-	if (err != IA_CSS_SUCCESS)
-		return err;
-
 	/* create per pipe reference to general ddr_ptrs */
 	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
 		ref_sh_css_ddr_address_map(ddr_ptrs, &params->pipe_ddr_ptrs[i]);
 		params->pipe_ddr_ptrs_size[i] = *ddr_ptrs_size;
 	}
 
-	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
-
-	return IA_CSS_SUCCESS;
+ERR:
+	IA_CSS_LEAVE_ERR_PRIVATE(err);
+	return err;
 }
 
 #if !defined(IS_ISP_2500_SYSTEM)
@@ -3155,13 +3151,15 @@ ia_css_set_sdis2_config(
 }
 #endif
 
-static struct ia_css_isp_parameters *
-sh_css_create_isp_params(struct ia_css_stream *stream)
+static enum ia_css_err
+sh_css_create_isp_params(struct ia_css_stream *stream,
+			 struct ia_css_isp_parameters **isp_params_out)
 {
 	bool succ = true;
 	unsigned i;
 	struct sh_css_ddr_address_map *ddr_ptrs;
 	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
+	enum ia_css_err err = IA_CSS_SUCCESS;
 #if !defined(IS_ISP_2500_SYSTEM)
 	size_t params_size;
 #endif
@@ -3170,8 +3168,11 @@ sh_css_create_isp_params(struct ia_css_stream *stream)
 
 	if (!params)
 	{
-		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
-		return NULL;
+		*isp_params_out = NULL;
+		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		IA_CSS_ERROR("%s:%d error: cannot allocate memory", __FILE__, __LINE__);
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
+		return err;
 	} else {
 		memset(params, 0, sizeof(struct ia_css_isp_parameters));
 	}
@@ -3205,9 +3206,15 @@ sh_css_create_isp_params(struct ia_css_stream *stream)
 				ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
 					mmgr_malloc(sizeof(struct isp_acc_param)));
 	succ &= (ddr_ptrs->acc_cluster_params_for_sp != mmgr_NULL);
-	acc_cluster_set_default_params(stream);
+	err = acc_cluster_set_default_params(stream);
+	if (err != IA_CSS_SUCCESS) {
+		return err;
+	}
 #if defined(HAS_OUTPUT_SYSTEM)
-	ia_css_osys_set_default(stream);
+	err = ia_css_osys_set_default(stream);
+	if (err != IA_CSS_SUCCESS) {
+		return err;
+	}
 #endif
 #else
 	(void)stream;
@@ -3221,7 +3228,8 @@ sh_css_create_isp_params(struct ia_css_stream *stream)
 	succ &= (ddr_ptrs->macc_tbl != mmgr_NULL);
 #endif
 
-	return params;
+	*isp_params_out = params;
+	return err;
 }
 
 static bool
@@ -3329,7 +3337,7 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 			sh_css_set_macc_table(params, &stream_params->macc_table);
 		sh_css_set_gamma_table(params, &stream_params->gc_table);
 		sh_css_set_ctc_table(params, &stream_params->ctc_table);
-		sh_css_set_baa_config(params, &stream_params->raw_config);
+		sh_css_set_baa_config(params, &stream_params->bds_config);
 		sh_css_set_dz_config(params, &stream_params->dz_config);
 /* ------ deprecated(bz675) : from ------ */
 		sh_css_set_shading_settings(params, &stream_params->shading_settings);
@@ -3893,11 +3901,13 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		if (sh_css_acc_cluster_parameters == NULL) {
 			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
 		}
-		err = sh_css_process_acc_cluster_parameters(pipe, sh_css_acc_cluster_parameters, &acc_cluster_params_changed);
-		if (err != IA_CSS_SUCCESS) {
-			IA_CSS_LOG("sh_css_process_acc_cluster_parameters() returned INVALID KERNEL CONFIGURATION\n");
-			IA_CSS_LEAVE_ERR_PRIVATE(err);
-			return err;
+		if (!pipe_in || pipe == pipe_in) {
+			err = sh_css_process_acc_cluster_parameters(pipe, sh_css_acc_cluster_parameters, &acc_cluster_params_changed);
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LOG("sh_css_process_acc_cluster_parameters() returned INVALID KERNEL CONFIGURATION\n");
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
+				return err;
+			}
 		}
 #endif
 
@@ -3931,6 +3941,14 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 			if (err != IA_CSS_SUCCESS)
 			    return err;
 		}
+#else
+		/* check if to actually update the parameters for this pipe */
+		/* When API change is implemented making good distinction between
+		* stream config and pipe config this skipping code can be moved out of the #ifdef */
+		if (pipe_in && (pipe != pipe_in)) {
+			IA_CSS_LOG("skipping pipe %x", pipe);
+			continue;
+		}
 #endif
 
 		/* BZ 125915, should be moved till after "update other buff" */
@@ -3945,15 +3963,8 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 					stage, params,
 					isp_pipe_version, raw_bit_depth);
 
-			err = sh_css_params_write_to_ddr_pipe_internal(
-					pipe,
-					stage,
-					cur_map,
-					cur_map_size);
-			if (err != IA_CSS_SUCCESS)
-				break;
-
 			err = sh_css_params_write_to_ddr_internal(
+					pipe,
 					pipeline->pipe_id,
 					params,
 					stage,
@@ -3995,7 +4006,9 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		}
 #endif
 
-			/* check if to actually update the parameters for this pipe */
+		/* check if to actually update the parameters for this pipe */
+		/* When API change is implemented making good distinction between
+		* stream config and pipe config this skipping code can be removed */
 		if (pipe_in && (pipe != pipe_in)) {
 			IA_CSS_LOG("skipping pipe %x", pipe);
 			continue;
@@ -4085,43 +4098,8 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 }
 
 static enum ia_css_err
-sh_css_params_write_to_ddr_pipe_internal(
-	struct ia_css_pipe *pipe,
-	const struct ia_css_pipeline_stage *stage,
-	struct sh_css_ddr_address_map *ddr_map,
-	struct sh_css_ddr_address_map_size *ddr_map_size)
-{
-#if !defined(IS_ISP_2500_SYSTEM)
-	(void)pipe;
-	(void)stage;
-	(void)ddr_map;
-	(void)ddr_map_size;
-#else
-	enum ia_css_err err;
-	const struct ia_css_binary *binary;
-
-	IA_CSS_ENTER_PRIVATE("");
-	assert(ddr_map != NULL);
-	assert(ddr_map_size != NULL);
-	assert(stage != NULL);
-
-
-	binary = stage->binary;
-	assert(binary != NULL);
-
-	/* pass call to product specific to handle copying of tables to DDR */
-	err = sh_css_params_to_ddr(pipe, binary, ddr_map, ddr_map_size);
-	if (err != IA_CSS_SUCCESS) {
-		IA_CSS_LEAVE_ERR_PRIVATE(err);
-		return err;
-	}
-#endif
-	IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_SUCCESS);
-	return IA_CSS_SUCCESS;
-}
-
-static enum ia_css_err
 sh_css_params_write_to_ddr_internal(
+	struct ia_css_pipe *pipe,
 	unsigned pipe_id,
 	struct ia_css_isp_parameters *params,
 	const struct ia_css_pipeline_stage *stage,
@@ -4138,6 +4116,7 @@ sh_css_params_write_to_ddr_internal(
 #if !defined(IS_ISP_2500_SYSTEM)
 	/* struct is > 128 bytes so it should not be on stack (see checkpatch) */
 	static struct ia_css_macc_table converted_macc_table;
+	(void)pipe;
 #endif
 
 	IA_CSS_ENTER_PRIVATE("void");
@@ -4152,27 +4131,14 @@ sh_css_params_write_to_ddr_internal(
 
 	stage_num = stage->stage_num;
 
-	for (mem = 0; mem < N_IA_CSS_MEMORIES; mem++) {
-		const struct ia_css_isp_data *isp_data =
-			ia_css_isp_param_get_isp_mem_init(&binary->info->sp.mem_initializers, IA_CSS_PARAM_CLASS_PARAM, mem);
-		size_t size = isp_data->size;
-		if (!size)
-			continue;
-		buff_realloced = reallocate_buffer(&ddr_map->isp_mem_param[stage_num][mem],
-			&ddr_map_size->isp_mem_param[stage_num][mem],
-			size,
-			params->isp_mem_params_changed[pipe_id][stage_num][mem],
-			&err);
-		if (err != IA_CSS_SUCCESS) {
-			IA_CSS_LEAVE_ERR_PRIVATE(err);
-			return err;
-		}
-		if (params->isp_mem_params_changed[pipe_id][stage_num][mem] || buff_realloced) {
-			sh_css_update_isp_mem_params_to_ddr(binary,
-				ddr_map->isp_mem_param[stage_num][mem],
-				ddr_map_size->isp_mem_param[stage_num][mem], mem);
-		}
+#if defined(IS_ISP_2500_SYSTEM)
+	/* pass call to product specific to handle copying of tables to DDR */
+	err = sh_css_params_to_ddr(pipe, binary, ddr_map, ddr_map_size);
+	if (err != IA_CSS_SUCCESS) {
+		IA_CSS_LEAVE_ERR_PRIVATE(err);
+		return err;
 	}
+#endif
 
 #if !defined(IS_ISP_2500_SYSTEM)
 	if (binary->info->sp.enable.fpnr) {
@@ -4508,55 +4474,6 @@ sh_css_params_write_to_ddr_internal(
 	return IA_CSS_SUCCESS;
 }
 
-
-/**
- * Currently this function is called from:
- *  - sh_css_commit_isp_config
- *    (loops through the stages in a pipe to reconfigure settings)
- */
-enum ia_css_err
-sh_css_params_write_to_ddr(struct ia_css_pipe *pipe,
-			   struct ia_css_pipeline_stage *stage)
-{
-	int i;
-	enum ia_css_err err = IA_CSS_SUCCESS;
-	struct ia_css_isp_parameters *params;
-	struct ia_css_stream *stream;
-	struct ia_css_pipeline *pipeline;
-
-	IA_CSS_ENTER_PRIVATE("void");
-	assert(pipe != NULL);
-	stream = pipe->stream;
-	params = stream->isp_params_configs;
-
-	pipeline = ia_css_pipe_get_pipeline(pipe);
-	err = sh_css_params_write_to_ddr_pipe_internal(
-			pipe,
-			stage,
-			&params->pipe_ddr_ptrs[pipeline->pipe_id],
-			&params->pipe_ddr_ptrs_size[pipeline->pipe_id]);
-	if (err != IA_CSS_SUCCESS) {
-		IA_CSS_LEAVE_ERR_PRIVATE(err);
-		return err;
-	}
-	for (i = 0; i < stream->num_pipes; i++) {
-		struct ia_css_pipe *pipe = stream->pipes[i];
-		struct ia_css_pipeline *pipeline;
-		pipeline = ia_css_pipe_get_pipeline(pipe);
-		err = sh_css_params_write_to_ddr_internal(
-				pipeline->pipe_id,
-				params,
-				stage,
-				&params->pipe_ddr_ptrs[pipeline->pipe_id],
-				&params->pipe_ddr_ptrs_size[pipeline->pipe_id]);
-		if (err != IA_CSS_SUCCESS)
-			break;
-	}
-
-	IA_CSS_LEAVE_ERR_PRIVATE(err);
-	return err;
-}
-
 const struct ia_css_fpn_table *ia_css_get_fpn_table(struct ia_css_stream *stream)
 {
 	struct ia_css_isp_parameters *params;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.h
index 1414ed1..ad37c87 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_params.h
@@ -102,7 +102,7 @@ struct ia_css_isp_parameters {
 	struct ia_css_macc_config   macc_config;
 	struct ia_css_ctc_config    ctc_config;
 	struct ia_css_aa_config     aa_config;
-	struct ia_css_aa_config     raw_config;
+	struct ia_css_aa_config     bds_config;
 	struct ia_css_aa_config     raa_config;
 	struct ia_css_rgb_gamma_table     r_gamma_table;
 	struct ia_css_rgb_gamma_table     g_gamma_table;
@@ -150,10 +150,6 @@ struct ia_css_isp_parameters {
 	uint32_t isp_parameters_id; /**< Unique ID to track which config was actually applied to a particular frame */
 };
 
-enum ia_css_err
-sh_css_params_write_to_ddr(struct ia_css_pipe *pipe,
-			   struct ia_css_pipeline_stage *stage);
-
 void
 ia_css_params_store_ia_css_host_data(
 	hrt_vaddress ddr_addr,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_sp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_sp.c
index caacddd..d467d61 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_sp.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/sh_css_sp.c
@@ -618,11 +618,14 @@ set_view_finder_buffer(const struct ia_css_frame *frame)
 	switch (frame->info.format) {
 	/* the dual output pin */
 	case IA_CSS_FRAME_FORMAT_NV12:
+	case IA_CSS_FRAME_FORMAT_NV21:
 	case IA_CSS_FRAME_FORMAT_YUYV:
 	case IA_CSS_FRAME_FORMAT_UYVY:
 	case IA_CSS_FRAME_FORMAT_CSI_MIPI_YUV420_8:
 	case IA_CSS_FRAME_FORMAT_CSI_MIPI_LEGACY_YUV420_8:
 	case IA_CSS_FRAME_FORMAT_YUV420:
+	case IA_CSS_FRAME_FORMAT_YV12:
+	case IA_CSS_FRAME_FORMAT_NV12_TILEY:
 
 	/* for vf_veceven */
 	case IA_CSS_FRAME_FORMAT_YUV_LINE:
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c
index 9252649..b9b37c3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2400b0_v21/spmem_dump.c
@@ -29,9 +29,9 @@
 
 #define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
 
-/* function input_system_acquisition_stop: B0E */
+/* function input_system_acquisition_stop: B78 */
 
-/* function longjmp: 6B85 */
+/* function longjmp: 6A6D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SRST_MASK
@@ -45,106 +45,104 @@
 #define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x1CC
 #define HIVE_SIZE_sp_HIVE_IF_SRST_MASK 16
 
-/* function tmpmem_init_dmem: 6938 */
+/* function tmpmem_init_dmem: 6805 */
 
-/* function ia_css_isys_sp_token_map_receive_ack: 6249 */
+/* function ia_css_isys_sp_token_map_receive_ack: 610E */
 
-/* function ia_css_dmaproxy_sp_set_addr_B: 32DF */
+/* function ia_css_dmaproxy_sp_set_addr_B: 31D7 */
 
 /* function debug_buffer_set_ddr_addr: F8 */
 
-/* function receiver_port_reg_load: AF2 */
+/* function receiver_port_reg_load: B5C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_mipi
 #define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_mipi 0x620C
+#define HIVE_ADDR_vbuf_mipi 0x61B4
 #define HIVE_SIZE_vbuf_mipi 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_mipi 0x620C
+#define HIVE_ADDR_sp_vbuf_mipi 0x61B4
 #define HIVE_SIZE_sp_vbuf_mipi 12
 
-/* function ia_css_event_sp_decode: 34F8 */
+/* function ia_css_event_sp_decode: 33BD */
 
-/* function ia_css_queue_get_size: 4A07 */
+/* function ia_css_queue_get_size: 48CC */
 
-/* function ia_css_queue_load: 50D2 */
+/* function ia_css_queue_load: 4F97 */
 
-/* function setjmp: 6B8E */
-
-/* function __dmaproxy_sp_read_write_text: 3404 */
+/* function setjmp: 6A76 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_isys_event_queue
 #define HIVE_MEM_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x462C
+#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x452C
 #define HIVE_SIZE_sem_for_sp2host_isys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x462C
+#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x452C
 #define HIVE_SIZE_sp_sem_for_sp2host_isys_event_queue 20
 
-/* function ia_css_dmaproxy_sp_wait_for_ack: 71BF */
+/* function ia_css_dmaproxy_sp_wait_for_ack: 6FF7 */
 
-/* function ia_css_sp_rawcopy_func: 5326 */
+/* function ia_css_sp_rawcopy_func: 51EB */
 
-/* function ia_css_tagger_buf_sp_pop_marked: 28F8 */
+/* function ia_css_tagger_buf_sp_pop_marked: 28CA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stage
 #define HIVE_MEM_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stage 0x5AF0
+#define HIVE_ADDR_isp_stage 0x5A98
 #define HIVE_SIZE_isp_stage 832
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stage 0x5AF0
+#define HIVE_ADDR_sp_isp_stage 0x5A98
 #define HIVE_SIZE_sp_isp_stage 832
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_raw
 #define HIVE_MEM_vbuf_raw scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_raw 0x2E0
+#define HIVE_ADDR_vbuf_raw 0x2F4
 #define HIVE_SIZE_vbuf_raw 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_raw scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_raw 0x2E0
+#define HIVE_ADDR_sp_vbuf_raw 0x2F4
 #define HIVE_SIZE_sp_vbuf_raw 4
 
-/* function ia_css_sp_bin_copy_func: 5259 */
+/* function ia_css_sp_bin_copy_func: 511E */
 
-/* function ia_css_queue_item_store: 4DA8 */
+/* function ia_css_queue_item_store: 4C6D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49A0
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4948
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x49A0
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4948
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49B4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x495C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x49B4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x495C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 
 /* function sp_start_isp: 501 */
@@ -152,122 +150,110 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_binary_group
 #define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_binary_group 0x5EE0
+#define HIVE_ADDR_sp_binary_group 0x5E88
 #define HIVE_SIZE_sp_binary_group 32
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_binary_group 0x5EE0
+#define HIVE_ADDR_sp_sp_binary_group 0x5E88
 #define HIVE_SIZE_sp_sp_binary_group 32
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sw_state
 #define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sw_state 0x619C
+#define HIVE_ADDR_sp_sw_state 0x6144
 #define HIVE_SIZE_sp_sw_state 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sw_state 0x619C
+#define HIVE_ADDR_sp_sp_sw_state 0x6144
 #define HIVE_SIZE_sp_sp_sw_state 4
 
-/* function ia_css_thread_sp_main: DB2 */
+/* function ia_css_thread_sp_main: E1C */
 
-/* function ia_css_ispctrl_sp_init_internal_buffers: 373F */
+/* function ia_css_ispctrl_sp_init_internal_buffers: 3604 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_psys_event_queue_handle
 #define HIVE_MEM_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x4A54
+#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x49FC
 #define HIVE_SIZE_sp2host_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x4A54
+#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x49FC
 #define HIVE_SIZE_sp_sp2host_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_psys_event_queue
 #define HIVE_MEM_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4640
+#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4540
 #define HIVE_SIZE_sem_for_sp2host_psys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4640
+#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4540
 #define HIVE_SIZE_sp_sem_for_sp2host_psys_event_queue 20
 
-/* function ia_css_tagger_sp_propagate_frame: 2368 */
+/* function ia_css_tagger_sp_propagate_frame: 23AF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_stop_copy_preview
 #define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_stop_copy_preview 0x6180
+#define HIVE_ADDR_sp_stop_copy_preview 0x6128
 #define HIVE_SIZE_sp_stop_copy_preview 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_stop_copy_preview 0x6180
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x6128
 #define HIVE_SIZE_sp_sp_stop_copy_preview 4
 
-/* function input_system_reg_load: B54 */
+/* function input_system_reg_load: BBE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_handles
 #define HIVE_MEM_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_handles 0x6218
+#define HIVE_ADDR_vbuf_handles 0x61C0
 #define HIVE_SIZE_vbuf_handles 960
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_handles 0x6218
+#define HIVE_ADDR_sp_vbuf_handles 0x61C0
 #define HIVE_SIZE_sp_vbuf_handles 960
 
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_max_mm_tracer
-#define HIVE_MEM_max_mm_tracer scalar_processor_2400_dmem
-#define HIVE_ADDR_max_mm_tracer 0x2688
-#define HIVE_SIZE_max_mm_tracer 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_max_mm_tracer scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_max_mm_tracer 0x2688
-#define HIVE_SIZE_sp_max_mm_tracer 4
-
-/* function ia_css_queue_store: 4F4B */
+/* function ia_css_queue_store: 4E10 */
 
-/* function ia_css_sp_flash_register: 2B13 */
+/* function ia_css_sp_flash_register: 2AED */
 
-/* function ia_css_sp_rawcopy_dummy_function: 58B1 */
+/* function ia_css_sp_rawcopy_dummy_function: 5776 */
 
-/* function ia_css_isys_sp_backend_create: 5EA0 */
+/* function ia_css_isys_sp_backend_create: 5D65 */
 
-/* function ia_css_pipeline_sp_init: 17FF */
+/* function ia_css_pipeline_sp_init: 1875 */
 
-/* function ia_css_tagger_sp_configure: 224A */
+/* function ia_css_tagger_sp_configure: 229D */
 
-/* function ia_css_ispctrl_sp_end_binary: 3542 */
+/* function ia_css_ispctrl_sp_end_binary: 3407 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A60
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A08
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A60
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4A08
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 
-/* function receiver_port_reg_store: AF9 */
+/* function receiver_port_reg_store: B63 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_is_pending_mask
@@ -284,123 +270,125 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_frame
 #define HIVE_MEM_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_frame 0x4654
+#define HIVE_ADDR_sp_all_cb_elems_frame 0x4554
 #define HIVE_SIZE_sp_all_cb_elems_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x4654
+#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x4554
 #define HIVE_SIZE_sp_sp_all_cb_elems_frame 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_isys_event_queue_handle
 #define HIVE_MEM_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4A74
+#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4A1C
 #define HIVE_SIZE_sp2host_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4A74
+#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4A1C
 #define HIVE_SIZE_sp_sp2host_isys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_com
 #define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_com 0x40F8
+#define HIVE_ADDR_host_sp_com 0x3FF8
 #define HIVE_SIZE_host_sp_com 220
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_com 0x40F8
+#define HIVE_ADDR_sp_host_sp_com 0x3FF8
 #define HIVE_SIZE_sp_host_sp_com 220
 
-/* function ia_css_queue_get_free_space: 4B5F */
+/* function ia_css_queue_get_free_space: 4A24 */
 
-/* function exec_image_pipe: 74B */
+/* function exec_image_pipe: 767 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_init_dmem_data
 #define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_init_dmem_data 0x61A0
+#define HIVE_ADDR_sp_init_dmem_data 0x6148
 #define HIVE_SIZE_sp_init_dmem_data 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_init_dmem_data 0x61A0
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x6148
 #define HIVE_SIZE_sp_sp_init_dmem_data 24
 
-/* function ia_css_sp_metadata_start: 5C6A */
+/* function ia_css_sp_metadata_start: 5B2F */
 
-/* function ia_css_bufq_sp_init_buffer_queues: 2B8A */
+/* function ia_css_bufq_sp_init_buffer_queues: 2B64 */
 
-/* function ia_css_pipeline_sp_stop: 17E2 */
+/* function ia_css_pipeline_sp_stop: 1858 */
 
-/* function ia_css_tagger_sp_connect_pipes: 26ED */
+/* function ia_css_tagger_sp_connect_pipes: 274E */
 
-/* function sp_isys_copy_wait: 794 */
+/* function sp_isys_copy_wait: 7B0 */
 
 /* function is_isp_debug_buffer_full: 3BC */
 
-/* function ia_css_dmaproxy_sp_configure_channel_from_info: 325C */
+/* function ia_css_dmaproxy_sp_configure_channel_from_info: 3156 */
+
+/* function encode_and_post_timer_event: AAD */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_per_frame_data
 #define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_per_frame_data 0x41D4
+#define HIVE_ADDR_sp_per_frame_data 0x40D4
 #define HIVE_SIZE_sp_per_frame_data 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_per_frame_data 0x41D4
+#define HIVE_ADDR_sp_sp_per_frame_data 0x40D4
 #define HIVE_SIZE_sp_sp_per_frame_data 4
 
-/* function ia_css_rmgr_sp_vbuf_dequeue: 6687 */
+/* function ia_css_rmgr_sp_vbuf_dequeue: 6554 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_psys_event_queue_handle
 #define HIVE_MEM_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4A80
+#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4A28
 #define HIVE_SIZE_host2sp_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4A80
+#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4A28
 #define HIVE_SIZE_sp_host2sp_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_xmem_bin_addr
 #define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_xmem_bin_addr 0x41D8
+#define HIVE_ADDR_xmem_bin_addr 0x40D8
 #define HIVE_SIZE_xmem_bin_addr 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_xmem_bin_addr 0x41D8
+#define HIVE_ADDR_sp_xmem_bin_addr 0x40D8
 #define HIVE_SIZE_sp_xmem_bin_addr 4
 
-/* function tmr_clock_init: ADC */
+/* function tmr_clock_init: B46 */
 
-/* function ia_css_pipeline_sp_run: 146C */
+/* function ia_css_pipeline_sp_run: 14D6 */
 
-/* function memcpy: 6C2E */
+/* function memcpy: 6B16 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_GP_DEVICE_BASE
 #define HIVE_MEM_GP_DEVICE_BASE scalar_processor_2400_dmem
-#define HIVE_ADDR_GP_DEVICE_BASE 0x2EC
+#define HIVE_ADDR_GP_DEVICE_BASE 0x2FC
 #define HIVE_SIZE_GP_DEVICE_BASE 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_GP_DEVICE_BASE scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_GP_DEVICE_BASE 0x2EC
+#define HIVE_ADDR_sp_GP_DEVICE_BASE 0x2FC
 #define HIVE_SIZE_sp_GP_DEVICE_BASE 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -415,51 +403,49 @@
 #define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x1E4
 #define HIVE_SIZE_sp_ia_css_thread_sp_ready_queue 12
 
-/* function input_system_reg_store: B5B */
-
-/* function sp_dma_proxy_set_width_ab: 30F9 */
+/* function input_system_reg_store: BC5 */
 
-/* function ia_css_isys_sp_frontend_start: 60CA */
+/* function ia_css_isys_sp_frontend_start: 5F8F */
 
-/* function ia_css_uds_sp_scale_params: 6952 */
+/* function ia_css_uds_sp_scale_params: 681F */
 
-/* function ia_css_circbuf_increase_size: E97 */
+/* function ia_css_circbuf_increase_size: F01 */
 
-/* function __divu: 6BAC */
+/* function __divu: 6A94 */
 
-/* function ia_css_thread_sp_get_state: CDA */
+/* function ia_css_thread_sp_get_state: D44 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_stop
 #define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_stop 0x4664
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x4564
 #define HIVE_SIZE_sem_for_cont_capt_stop 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x4664
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x4564
 #define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
 
-/* function thread_fiber_sp_main: E90 */
+/* function thread_fiber_sp_main: EFA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_pipe_thread
 #define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pipe_thread 0x47A8
+#define HIVE_ADDR_sp_isp_pipe_thread 0x46A8
 #define HIVE_SIZE_sp_isp_pipe_thread 340
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x47A8
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x46A8
 #define HIVE_SIZE_sp_sp_isp_pipe_thread 340
 
-/* function ia_css_parambuf_sp_handle_parameter_sets: 130D */
+/* function ia_css_parambuf_sp_handle_parameter_sets: 1377 */
 
-/* function ia_css_spctrl_sp_set_state: 5C99 */
+/* function ia_css_spctrl_sp_set_state: 5B5E */
 
-/* function ia_css_thread_sem_sp_signal: 6E04 */
+/* function ia_css_thread_sem_sp_signal: 6CEC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_IRQ_BASE
@@ -485,59 +471,47 @@
 #define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
 #define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
 
-/* function ia_css_isys_sp_isr: 7372 */
+/* function ia_css_isys_sp_isr: 71B5 */
 
-/* function ia_css_isys_sp_generate_exp_id: 647C */
+/* function ia_css_isys_sp_generate_exp_id: 6349 */
 
-/* function ia_css_rmgr_sp_init: 6576 */
+/* function ia_css_rmgr_sp_init: 6443 */
 
-/* function ia_css_thread_sem_sp_init: 6ED7 */
+/* function ia_css_thread_sem_sp_init: 6DBF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_is_isp_requested
 #define HIVE_MEM_is_isp_requested scalar_processor_2400_dmem
-#define HIVE_ADDR_is_isp_requested 0x2F8
+#define HIVE_ADDR_is_isp_requested 0x308
 #define HIVE_SIZE_is_isp_requested 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_is_isp_requested scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_is_isp_requested 0x2F8
+#define HIVE_ADDR_sp_is_isp_requested 0x308
 #define HIVE_SIZE_sp_is_isp_requested 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_frame
 #define HIVE_MEM_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frame 0x4678
+#define HIVE_ADDR_sem_for_reading_cb_frame 0x4578
 #define HIVE_SIZE_sem_for_reading_cb_frame 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x4678
+#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x4578
 #define HIVE_SIZE_sp_sem_for_reading_cb_frame 40
 
-/* function ia_css_dmaproxy_sp_execute: 31B4 */
+/* function ia_css_dmaproxy_sp_execute: 30BB */
 
-/* function ia_css_queue_is_empty: 4A42 */
+/* function ia_css_queue_is_empty: 4907 */
 
-/* function ia_css_pipeline_sp_has_stopped: 17D8 */
+/* function ia_css_pipeline_sp_has_stopped: 184E */
 
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_verbosity
-#define HIVE_MEM_verbosity scalar_processor_2400_dmem
-#define HIVE_ADDR_verbosity 0x2680
-#define HIVE_SIZE_verbosity 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_verbosity scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_verbosity 0x2680
-#define HIVE_SIZE_sp_verbosity 4
+/* function ia_css_circbuf_extract: 100F */
 
-/* function ia_css_circbuf_extract: FA5 */
-
-/* function ia_css_tagger_buf_sp_is_locked_from_start: 2A3C */
+/* function ia_css_tagger_buf_sp_is_locked_from_start: 2A16 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_sp_thread
@@ -551,52 +525,40 @@
 #define HIVE_ADDR_sp_current_sp_thread 0x1E0
 #define HIVE_SIZE_sp_current_sp_thread 4
 
-/* function ia_css_spctrl_sp_get_spid: 5CA0 */
+/* function ia_css_spctrl_sp_get_spid: 5B65 */
 
-/* function ia_css_dmaproxy_sp_read_byte_addr: 71F0 */
+/* function ia_css_dmaproxy_sp_read_byte_addr: 7028 */
 
-/* function ia_css_rmgr_sp_uninit: 656F */
+/* function ia_css_rmgr_sp_uninit: 643C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack
 #define HIVE_MEM_sp_threads_stack scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_stack 0x164
+#define HIVE_ADDR_sp_threads_stack 0x168
 #define HIVE_SIZE_sp_threads_stack 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_stack scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_stack 0x164
+#define HIVE_ADDR_sp_sp_threads_stack 0x168
 #define HIVE_SIZE_sp_sp_threads_stack 28
 
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_trace_buffer_sp
-#define HIVE_MEM_trace_buffer_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_trace_buffer_sp 0x2684
-#define HIVE_SIZE_trace_buffer_sp 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_trace_buffer_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_trace_buffer_sp 0x2684
-#define HIVE_SIZE_sp_trace_buffer_sp 4
+/* function ia_css_circbuf_peek: FEE */
 
-/* function ia_css_circbuf_peek: F84 */
+/* function ia_css_parambuf_sp_wait_for_in_param: 1125 */
 
-/* function ia_css_parambuf_sp_wait_for_in_param: 10BB */
-
-/* function ia_css_isys_sp_token_map_get_exp_id: 6337 */
+/* function ia_css_isys_sp_token_map_get_exp_id: 61FC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_param
 #define HIVE_MEM_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_param 0x46A0
+#define HIVE_ADDR_sp_all_cb_elems_param 0x45A0
 #define HIVE_SIZE_sp_all_cb_elems_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x46A0
+#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x45A0
 #define HIVE_SIZE_sp_sp_all_cb_elems_param 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -614,172 +576,174 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame_desc
 #define HIVE_MEM_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame_desc 0x46B0
+#define HIVE_ADDR_sp_all_cbs_frame_desc 0x45B0
 #define HIVE_SIZE_sp_all_cbs_frame_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x46B0
+#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x45B0
 #define HIVE_SIZE_sp_sp_all_cbs_frame_desc 8
 
-/* function sp_isys_copy_func_v2: 78D */
+/* function sp_isys_copy_func_v2: 7A9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_param
 #define HIVE_MEM_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_param 0x46B8
+#define HIVE_ADDR_sem_for_reading_cb_param 0x45B8
 #define HIVE_SIZE_sem_for_reading_cb_param 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x46B8
+#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x45B8
 #define HIVE_SIZE_sp_sem_for_reading_cb_param 40
 
-/* function ia_css_queue_get_used_space: 4B11 */
+/* function ia_css_queue_get_used_space: 49D6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_start
 #define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_start 0x46E0
+#define HIVE_ADDR_sem_for_cont_capt_start 0x45E0
 #define HIVE_SIZE_sem_for_cont_capt_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x46E0
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x45E0
 #define HIVE_SIZE_sp_sem_for_cont_capt_start 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tmp_heap
 #define HIVE_MEM_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_tmp_heap 0x5F00
+#define HIVE_ADDR_tmp_heap 0x5EA8
 #define HIVE_SIZE_tmp_heap 640
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tmp_heap 0x5F00
+#define HIVE_ADDR_sp_tmp_heap 0x5EA8
 #define HIVE_SIZE_sp_tmp_heap 640
 
-/* function ia_css_rmgr_sp_get_num_vbuf: 688D */
+/* function ia_css_rmgr_sp_get_num_vbuf: 675A */
 
-/* function ia_css_ispctrl_sp_output_compute_dma_info: 3F57 */
+/* function ia_css_ispctrl_sp_output_compute_dma_info: 3E1C */
 
-/* function ia_css_tagger_sp_lock_exp_id: 2057 */
+/* function ia_css_tagger_sp_lock_exp_id: 20C6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4A8C
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4A34
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4A8C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4A34
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 
-/* function ia_css_queue_is_full: 4BAE */
+/* function ia_css_queue_is_full: 4A73 */
 
 /* function debug_buffer_init_isp: 105 */
 
-/* function ia_css_isys_sp_frontend_uninit: 607B */
+/* function ia_css_isys_sp_frontend_uninit: 5F40 */
 
-/* function ia_css_tagger_sp_exp_id_is_locked: 1F9D */
+/* function ia_css_tagger_sp_exp_id_is_locked: 2013 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem
 #define HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x65D8
+#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x6580
 #define HIVE_SIZE_ia_css_rmgr_sp_mipi_frame_sem 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x65D8
+#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x6580
 #define HIVE_SIZE_sp_ia_css_rmgr_sp_mipi_frame_sem 60
 
-/* function ia_css_rmgr_sp_refcount_dump: 6662 */
+/* function ia_css_rmgr_sp_refcount_dump: 652F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4AC8
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4A70
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4AC8
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4A70
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_pipe_threads
 #define HIVE_MEM_sp_pipe_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_pipe_threads 0x150
+#define HIVE_ADDR_sp_pipe_threads 0x154
 #define HIVE_SIZE_sp_pipe_threads 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_pipe_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_pipe_threads 0x150
+#define HIVE_ADDR_sp_sp_pipe_threads 0x154
 #define HIVE_SIZE_sp_sp_pipe_threads 20
 
-/* function sp_event_proxy_func: 7A2 */
+/* function sp_event_proxy_func: 7BE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_isys_event_queue_handle
 #define HIVE_MEM_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4ADC
+#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4A84
 #define HIVE_SIZE_host2sp_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4ADC
+#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4A84
 #define HIVE_SIZE_sp_host2sp_isys_event_queue_handle 12
 
-/* function ia_css_thread_sp_yield: 6D7A */
+/* function ia_css_thread_sp_yield: 6C62 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param_desc
 #define HIVE_MEM_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param_desc 0x46F4
+#define HIVE_ADDR_sp_all_cbs_param_desc 0x45F4
 #define HIVE_SIZE_sp_all_cbs_param_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x46F4
+#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x45F4
 #define HIVE_SIZE_sp_sp_all_cbs_param_desc 8
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb
 #define HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5AE0
+#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5A88
 #define HIVE_SIZE_ia_css_dmaproxy_sp_invalidate_tlb 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5AE0
+#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5A88
 #define HIVE_SIZE_sp_ia_css_dmaproxy_sp_invalidate_tlb 4
 
-/* function ia_css_thread_sp_fork: D67 */
+/* function ia_css_thread_sp_fork: DD1 */
+
+/* function ia_css_tagger_sp_destroy: 2758 */
 
-/* function ia_css_tagger_sp_destroy: 26F7 */
+/* function ia_css_dmaproxy_sp_vmem_read: 305B */
 
-/* function ia_css_dmaproxy_sp_vmem_read: 313D */
+/* function ia_css_ifmtr_sp_init: 639A */
 
-/* function ia_css_ifmtr_sp_init: 64CD */
+/* function initialize_sp_group: 777 */
 
-/* function initialize_sp_group: 75B */
+/* function ia_css_thread_sp_init: DFD */
 
-/* function ia_css_thread_sp_init: D93 */
+/* function ia_css_isys_sp_reset_exp_id: 6341 */
 
-/* function ia_css_ispctrl_sp_set_stream_base_addr: 474F */
+/* function ia_css_ispctrl_sp_set_stream_base_addr: 4614 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_DMEM_BASE
@@ -805,44 +769,44 @@
 #define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
 #define HIVE_SIZE_sp_SP_DMEM_BASE 4
 
-/* function ia_css_dmaproxy_sp_read: 31D5 */
+/* function ia_css_dmaproxy_sp_read: 30D4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_copy_line_count
 #define HIVE_MEM_raw_copy_line_count scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_copy_line_count 0x2B4
+#define HIVE_ADDR_raw_copy_line_count 0x2C8
 #define HIVE_SIZE_raw_copy_line_count 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_copy_line_count scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_copy_line_count 0x2B4
+#define HIVE_ADDR_sp_raw_copy_line_count 0x2C8
 #define HIVE_SIZE_sp_raw_copy_line_count 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_tag_cmd_queue_handle
 #define HIVE_MEM_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4AE8
+#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4A90
 #define HIVE_SIZE_host2sp_tag_cmd_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4AE8
+#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4A90
 #define HIVE_SIZE_sp_host2sp_tag_cmd_queue_handle 12
 
-/* function ia_css_queue_peek: 4A86 */
+/* function ia_css_queue_peek: 494B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_frame_cnt
 #define HIVE_MEM_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x4994
+#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x493C
 #define HIVE_SIZE_ia_css_flash_sp_frame_cnt 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x4994
+#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x493C
 #define HIVE_SIZE_sp_ia_css_flash_sp_frame_cnt 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -858,147 +822,131 @@
 #define HIVE_SIZE_sp_event_can_send_token_mask 44
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_started
-#define HIVE_MEM_started scalar_processor_2400_dmem
-#define HIVE_ADDR_started 0x267C
-#define HIVE_SIZE_started 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_started 0x267C
-#define HIVE_SIZE_sp_started 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_thread
 #define HIVE_MEM_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_thread 0x5E30
+#define HIVE_ADDR_isp_thread 0x5DD8
 #define HIVE_SIZE_isp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_thread 0x5E30
+#define HIVE_ADDR_sp_isp_thread 0x5DD8
 #define HIVE_SIZE_sp_isp_thread 4
 
-/* function encode_and_post_sp_event_non_blocking: A92 */
+/* function encode_and_post_sp_event_non_blocking: AF5 */
 
-/* function ia_css_isys_sp_frontend_destroy: 6163 */
+/* function ia_css_isys_sp_frontend_destroy: 6028 */
 
 /* function is_ddr_debug_buffer_full: 33E */
 
-/* function ia_css_isys_sp_frontend_stop: 6093 */
+/* function ia_css_isys_sp_frontend_stop: 5F58 */
 
-/* function ia_css_isys_sp_token_map_init: 6417 */
-
-/* function sp_dma_proxy_isp_write_addr: 3155 */
+/* function ia_css_isys_sp_token_map_init: 62DC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_fiber
 #define HIVE_MEM_sp_threads_fiber scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_fiber 0x19C
+#define HIVE_ADDR_sp_threads_fiber 0x1A0
 #define HIVE_SIZE_sp_threads_fiber 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_fiber scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_fiber 0x19C
+#define HIVE_ADDR_sp_sp_threads_fiber 0x1A0
 #define HIVE_SIZE_sp_sp_threads_fiber 28
 
-/* function encode_and_post_sp_event: A63 */
+/* function encode_and_post_sp_event: A7E */
 
 /* function debug_enqueue_ddr: 114 */
 
-/* function ia_css_rmgr_sp_refcount_init_vbuf: 661D */
+/* function ia_css_rmgr_sp_refcount_init_vbuf: 64EA */
 
-/* function dmaproxy_sp_read_write: 729D */
+/* function dmaproxy_sp_read_write: 70B3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer
 #define HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5AE4
+#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5A8C
 #define HIVE_SIZE_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5AE4
+#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5A8C
 #define HIVE_SIZE_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 
-/* function ia_css_dmaproxy_sp_ack: 6EFF */
-
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_buffer_queue_handle
 #define HIVE_MEM_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4AF4
+#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4A9C
 #define HIVE_SIZE_host2sp_buffer_queue_handle 480
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4AF4
+#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4A9C
 #define HIVE_SIZE_sp_host2sp_buffer_queue_handle 480
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_in_service
 #define HIVE_MEM_ia_css_flash_sp_in_service scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_in_service 0x321C
+#define HIVE_ADDR_ia_css_flash_sp_in_service 0x30E8
 #define HIVE_SIZE_ia_css_flash_sp_in_service 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_in_service scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x321C
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x30E8
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_service 4
 
-/* function ia_css_dmaproxy_sp_process: 6F2E */
+/* function ia_css_dmaproxy_sp_process: 6DE7 */
 
-/* function ia_css_tagger_buf_sp_mark_from_end: 2AEC */
+/* function ia_css_tagger_buf_sp_mark_from_end: 2AC6 */
 
-/* function ia_css_isys_sp_backend_rcv_acquire_ack: 5D4F */
+/* function ia_css_isys_sp_backend_rcv_acquire_ack: 5C14 */
 
-/* function ia_css_isys_sp_backend_pre_acquire_request: 5D65 */
+/* function ia_css_isys_sp_backend_pre_acquire_request: 5C2A */
 
-/* function ia_css_ispctrl_sp_init_cs: 3648 */
+/* function ia_css_ispctrl_sp_init_cs: 350D */
 
-/* function ia_css_spctrl_sp_init: 5CAE */
+/* function ia_css_spctrl_sp_init: 5B73 */
 
-/* function sp_event_proxy_init: 7B7 */
+/* function sp_event_proxy_init: 7D3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_previous_clock_tick
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_previous_clock_tick scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4CD4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4C7C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_previous_clock_tick 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4CD4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4C7C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_output
 #define HIVE_MEM_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_output 0x41DC
+#define HIVE_ADDR_sp_output 0x40DC
 #define HIVE_SIZE_sp_output 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_output 0x41DC
+#define HIVE_ADDR_sp_sp_output 0x40DC
 #define HIVE_SIZE_sp_sp_output 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4CE8
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4C90
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4CE8
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4C90
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1025,52 +973,52 @@
 #define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
 #define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
 
-/* function sp_dma_proxy_reset_channels: 345C */
+/* function sp_dma_proxy_reset_channels: 3321 */
 
-/* function ia_css_isys_sp_backend_acquire: 5E76 */
+/* function ia_css_isys_sp_backend_acquire: 5D3B */
 
-/* function ia_css_tagger_sp_update_size: 27FF */
+/* function ia_css_tagger_sp_update_size: 283D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_host_sp_queue
 #define HIVE_MEM_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x5008
+#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x4FB0
 #define HIVE_SIZE_ia_css_bufq_host_sp_queue 2008
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x5008
+#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x4FB0
 #define HIVE_SIZE_sp_ia_css_bufq_host_sp_queue 2008
 
-/* function thread_fiber_sp_create: DFF */
+/* function thread_fiber_sp_create: E69 */
 
-/* function ia_css_dmaproxy_sp_set_increments: 32CA */
+/* function ia_css_dmaproxy_sp_set_increments: 31C2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_frame
 #define HIVE_MEM_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_frame 0x46FC
+#define HIVE_ADDR_sem_for_writing_cb_frame 0x45FC
 #define HIVE_SIZE_sem_for_writing_cb_frame 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x46FC
+#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x45FC
 #define HIVE_SIZE_sp_sem_for_writing_cb_frame 20
 
-/* function receiver_reg_store: B07 */
+/* function receiver_reg_store: B71 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_param
 #define HIVE_MEM_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_param 0x4710
+#define HIVE_ADDR_sem_for_writing_cb_param 0x4610
 #define HIVE_SIZE_sem_for_writing_cb_param 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4710
+#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4610
 #define HIVE_SIZE_sp_sem_for_writing_cb_param 20
 
 /* function sp_start_isp_entry: 4F7 */
@@ -1081,63 +1029,49 @@
 #endif
 #define HIVE_ADDR_sp_sp_start_isp_entry 0x4F7
 
-/* function ia_css_tagger_buf_sp_unmark_all: 2A84 */
+/* function ia_css_tagger_buf_sp_unmark_all: 2A5E */
 
-/* function ia_css_tagger_buf_sp_unmark_from_start: 2AC5 */
+/* function ia_css_tagger_buf_sp_unmark_from_start: 2A9F */
 
-/* function ia_css_dmaproxy_sp_channel_acquire: 348B */
+/* function ia_css_dmaproxy_sp_channel_acquire: 3350 */
 
-/* function ia_css_rmgr_sp_add_num_vbuf: 6869 */
+/* function ia_css_rmgr_sp_add_num_vbuf: 6736 */
 
-/* function ia_css_isys_sp_token_map_create: 6463 */
+/* function ia_css_isys_sp_token_map_create: 6328 */
 
-/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 30F0 */
+/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 3024 */
 
-/* function ia_css_tagger_buf_sp_push_marked: 2988 */
-
-/* function ia_css_bufq_sp_is_dynamic_buffer: 2F1D */
+/* function ia_css_bufq_sp_is_dynamic_buffer: 2EF7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_group
 #define HIVE_MEM_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_group 0x41EC
+#define HIVE_ADDR_sp_group 0x40EC
 #define HIVE_SIZE_sp_group 1084
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_group 0x41EC
+#define HIVE_ADDR_sp_sp_group 0x40EC
 #define HIVE_SIZE_sp_sp_group 1084
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_event_proxy_thread
 #define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_event_proxy_thread 0x48FC
+#define HIVE_ADDR_sp_event_proxy_thread 0x47FC
 #define HIVE_SIZE_sp_event_proxy_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_event_proxy_thread 0x48FC
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x47FC
 #define HIVE_SIZE_sp_sp_event_proxy_thread 68
 
-/* function ia_css_thread_sp_kill: D2D */
+/* function ia_css_thread_sp_kill: D97 */
 
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_cur_loc
-#define HIVE_MEM_cur_loc scalar_processor_2400_dmem
-#define HIVE_ADDR_cur_loc 0x2674
-#define HIVE_SIZE_cur_loc 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_cur_loc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_cur_loc 0x2674
-#define HIVE_SIZE_sp_cur_loc 4
+/* function ia_css_tagger_sp_create: 27FE */
 
-/* function ia_css_tagger_sp_create: 27AF */
-
-/* function tmpmem_acquire_dmem: 6919 */
+/* function tmpmem_acquire_dmem: 67E6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_MMU_BASE
@@ -1151,39 +1085,39 @@
 #define HIVE_ADDR_sp_MMU_BASE 0x24
 #define HIVE_SIZE_sp_MMU_BASE 8
 
-/* function ia_css_dmaproxy_sp_channel_release: 3474 */
+/* function ia_css_dmaproxy_sp_channel_release: 3339 */
 
-/* function ia_css_dmaproxy_sp_is_idle: 3447 */
+/* function ia_css_dmaproxy_sp_is_idle: 3319 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_qos_start
 #define HIVE_MEM_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_qos_start 0x4724
+#define HIVE_ADDR_sem_for_qos_start 0x4624
 #define HIVE_SIZE_sem_for_qos_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_qos_start 0x4724
+#define HIVE_ADDR_sp_sem_for_qos_start 0x4624
 #define HIVE_SIZE_sp_sem_for_qos_start 20
 
-/* function isp_hmem_load: B9B */
+/* function isp_hmem_load: C05 */
 
-/* function ia_css_eventq_sp_send: 34D0 */
+/* function ia_css_eventq_sp_send: 3395 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_error_cnt
 #define HIVE_MEM_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x61C4
+#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x616C
 #define HIVE_SIZE_ia_css_isys_sp_error_cnt 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x61C4
+#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x616C
 #define HIVE_SIZE_sp_ia_css_isys_sp_error_cnt 16
 
-/* function ia_css_tagger_buf_sp_unlock_from_start: 29F6 */
+/* function ia_css_tagger_buf_sp_unlock_from_start: 29D0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_debug_buffer_ddr_address
@@ -1197,61 +1131,35 @@
 #define HIVE_ADDR_sp_debug_buffer_ddr_address 0xBC
 #define HIVE_SIZE_sp_debug_buffer_ddr_address 4
 
-/* function sp_isys_copy_request: 79B */
+/* function sp_isys_copy_request: 7B7 */
 
-/* function ia_css_rmgr_sp_refcount_retain_vbuf: 66F7 */
+/* function ia_css_rmgr_sp_refcount_retain_vbuf: 65C4 */
 
-/* function ia_css_thread_sp_set_priority: D25 */
+/* function ia_css_thread_sp_set_priority: D8F */
 
-/* function sizeof_hmem: C51 */
+/* function sizeof_hmem: CBB */
 
-/* function tmpmem_release_dmem: 6906 */
+/* function tmpmem_release_dmem: 67D3 */
 
 /* function cnd_input_system_cfg: 419 */
 
-/* function __ia_css_sp_rawcopy_func_critical: 72FB */
-
-/* function __ia_css_dmaproxy_sp_process_text: 302C */
+/* function __ia_css_sp_rawcopy_func_critical: 713E */
 
-/* function ia_css_dmaproxy_sp_set_width_exception: 32B4 */
+/* function ia_css_dmaproxy_sp_set_width_exception: 31AD */
 
-/* function sp_event_assert: 916 */
+/* function sp_event_assert: 932 */
 
-/* function ia_css_flash_sp_init_internal_params: 2B7F */
+/* function ia_css_flash_sp_init_internal_params: 2B59 */
 
-/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 2824 */
+/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 285B */
 
-/* function __modu: 6BF2 */
+/* function __modu: 6ADA */
 
-/* function ia_css_dmaproxy_sp_init_isp_vector: 310F */
+/* function ia_css_dmaproxy_sp_init_isp_vector: 302D */
 
 /* function isp_vamem_store: 0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_counter
-#define HIVE_MEM_counter scalar_processor_2400_dmem
-#define HIVE_ADDR_counter 0x2678
-#define HIVE_SIZE_counter 2
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_counter scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_counter 0x2678
-#define HIVE_SIZE_sp_counter 2
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_major_masks
-#define HIVE_MEM_major_masks scalar_processor_2400_dmem
-#define HIVE_ADDR_major_masks 0x1B8
-#define HIVE_SIZE_major_masks 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_major_masks scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_major_masks 0x1B8
-#define HIVE_SIZE_sp_major_masks 4
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_GDC_BASE
 #define HIVE_MEM_GDC_BASE scalar_processor_2400_dmem
 #define HIVE_ADDR_GDC_BASE 0x44
@@ -1263,57 +1171,55 @@
 #define HIVE_ADDR_sp_GDC_BASE 0x44
 #define HIVE_SIZE_sp_GDC_BASE 8
 
-/* function ia_css_queue_local_init: 4D82 */
+/* function ia_css_queue_local_init: 4C47 */
 
-/* function sp_event_proxy_callout_func: 6C84 */
-
-/* function ia_css_dmaproxy_sp_deregister_channel_from_port: 30D7 */
+/* function sp_event_proxy_callout_func: 6B6C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_num_ready_threads
 #define HIVE_MEM_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x4988
+#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x4888
 #define HIVE_SIZE_ia_css_thread_sp_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x4988
+#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x4888
 #define HIVE_SIZE_sp_ia_css_thread_sp_num_ready_threads 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack_size
 #define HIVE_MEM_sp_threads_stack_size scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_stack_size 0x180
+#define HIVE_ADDR_sp_threads_stack_size 0x184
 #define HIVE_SIZE_sp_threads_stack_size 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_stack_size scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_stack_size 0x180
+#define HIVE_ADDR_sp_sp_threads_stack_size 0x184
 #define HIVE_SIZE_sp_sp_threads_stack_size 28
 
-/* function ia_css_ispctrl_sp_isp_done_row_striping: 3F3D */
+/* function ia_css_ispctrl_sp_isp_done_row_striping: 3E02 */
 
-/* function __ia_css_isys_sp_isr_text: 618E */
+/* function __ia_css_isys_sp_isr_text: 6053 */
 
-/* function ia_css_queue_dequeue: 4BF6 */
+/* function ia_css_queue_dequeue: 4ABB */
 
-/* function ia_css_dmaproxy_sp_configure_channel: 7207 */
+/* function ia_css_dmaproxy_sp_configure_channel: 703F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_thread_fiber_sp
 #define HIVE_MEM_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_current_thread_fiber_sp 0x4990
+#define HIVE_ADDR_current_thread_fiber_sp 0x4890
 #define HIVE_SIZE_current_thread_fiber_sp 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_thread_fiber_sp 0x4990
+#define HIVE_ADDR_sp_current_thread_fiber_sp 0x4890
 #define HIVE_SIZE_sp_current_thread_fiber_sp 4
 
-/* function ia_css_circbuf_pop: 103D */
+/* function ia_css_circbuf_pop: 10A7 */
 
 /* function irq_raise_set_token: C1 */
 
@@ -1329,119 +1235,117 @@
 #define HIVE_ADDR_sp_GPIO_BASE 0x3C
 #define HIVE_SIZE_sp_GPIO_BASE 4
 
-/* function ia_css_tagger_sp_unlock_exp_id: 1FC2 */
+/* function ia_css_tagger_sp_unlock_exp_id: 2038 */
 
-/* function ia_css_pipeline_acc_stage_enable: 17B8 */
+/* function ia_css_pipeline_acc_stage_enable: 182E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_ph
 #define HIVE_MEM_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_ph 0x61D4
+#define HIVE_ADDR_isp_ph 0x617C
 #define HIVE_SIZE_isp_ph 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_ph 0x61D4
+#define HIVE_ADDR_sp_isp_ph 0x617C
 #define HIVE_SIZE_sp_isp_ph 28
 
-/* function ia_css_isys_sp_token_map_flush: 63A0 */
+/* function ia_css_isys_sp_token_map_flush: 6265 */
 
-/* function ia_css_ispctrl_sp_init_ds: 37E6 */
+/* function ia_css_ispctrl_sp_init_ds: 36AB */
 
-/* function get_xmem_base_addr_raw: 3BA0 */
+/* function get_xmem_base_addr_raw: 3A65 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param
 #define HIVE_MEM_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param 0x4738
+#define HIVE_ADDR_sp_all_cbs_param 0x4638
 #define HIVE_SIZE_sp_all_cbs_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param 0x4738
+#define HIVE_ADDR_sp_sp_all_cbs_param 0x4638
 #define HIVE_SIZE_sp_sp_all_cbs_param 16
 
-/* function ia_css_circbuf_create: 108E */
+/* function ia_css_circbuf_create: 10F8 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp_group
 #define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp_group 0x4748
+#define HIVE_ADDR_sem_for_sp_group 0x4648
 #define HIVE_SIZE_sem_for_sp_group 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp_group 0x4748
+#define HIVE_ADDR_sp_sem_for_sp_group 0x4648
 #define HIVE_SIZE_sp_sem_for_sp_group 20
 
-/* function ia_css_framebuf_sp_wait_for_in_frame: 6894 */
-
-/* function ia_css_tagger_buf_sp_push_unmarked: 2897 */
+/* function ia_css_framebuf_sp_wait_for_in_frame: 6761 */
 
-/* function isp_hmem_clear: B62 */
+/* function isp_hmem_clear: BCC */
 
-/* function ia_css_framebuf_sp_release_in_frame: 68D7 */
+/* function ia_css_framebuf_sp_release_in_frame: 67A4 */
 
-/* function ia_css_isys_sp_backend_snd_acquire_request: 5DC8 */
+/* function ia_css_isys_sp_backend_snd_acquire_request: 5C8D */
 
-/* function ia_css_isys_sp_token_map_is_full: 6215 */
+/* function ia_css_isys_sp_token_map_is_full: 60DA */
 
-/* function input_system_acquisition_run: B30 */
+/* function input_system_acquisition_run: B9A */
 
-/* function ia_css_ispctrl_sp_start_binary: 3626 */
+/* function ia_css_ispctrl_sp_start_binary: 34EB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x57E0
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x5788
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x57E0
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x5788
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 
-/* function ia_css_eventq_sp_recv: 34A2 */
+/* function ia_css_eventq_sp_recv: 3367 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_pool
 #define HIVE_MEM_isp_pool scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_pool 0x2D4
+#define HIVE_ADDR_isp_pool 0x2E8
 #define HIVE_SIZE_isp_pool 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_pool scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pool 0x2D4
+#define HIVE_ADDR_sp_isp_pool 0x2E8
 #define HIVE_SIZE_sp_isp_pool 4
 
-/* function ia_css_rmgr_sp_rel_gen: 65B8 */
+/* function ia_css_rmgr_sp_rel_gen: 6485 */
 
-/* function css_get_frame_processing_time_end: 1F8B */
+/* function css_get_frame_processing_time_end: 2001 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_any_pending_mask
 #define HIVE_MEM_event_any_pending_mask scalar_processor_2400_dmem
-#define HIVE_ADDR_event_any_pending_mask 0x2F0
+#define HIVE_ADDR_event_any_pending_mask 0x300
 #define HIVE_SIZE_event_any_pending_mask 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_event_any_pending_mask scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_event_any_pending_mask 0x2F0
+#define HIVE_ADDR_sp_event_any_pending_mask 0x300
 #define HIVE_SIZE_sp_event_any_pending_mask 8
 
-/* function ia_css_isys_sp_backend_push: 5D79 */
+/* function ia_css_isys_sp_backend_push: 5C3E */
 
 /* function sh_css_decode_tag_descr: 3D7 */
 
 /* function debug_enqueue_isp: 2E9 */
 
-/* function ia_css_spctrl_sp_uninit: 5CA7 */
+/* function ia_css_spctrl_sp_uninit: 5B6C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SWITCH_CODE
@@ -1458,34 +1362,34 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x57F4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x579C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_dis_bufs 140
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x57F4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x579C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_dis_bufs 140
 
-/* function ia_css_tagger_buf_sp_lock_from_start: 2A19 */
+/* function ia_css_tagger_buf_sp_lock_from_start: 29F3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_isp_idle
 #define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_isp_idle 0x475C
+#define HIVE_ADDR_sem_for_isp_idle 0x465C
 #define HIVE_SIZE_sem_for_isp_idle 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_isp_idle 0x475C
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x465C
 #define HIVE_SIZE_sp_sem_for_isp_idle 20
 
-/* function ia_css_dmaproxy_sp_write_byte_addr: 3183 */
+/* function ia_css_dmaproxy_sp_write_byte_addr: 308A */
 
-/* function ia_css_dmaproxy_sp_init: 30A9 */
+/* function ia_css_dmaproxy_sp_init: 2FFE */
 
-/* function ia_css_bufq_sp_release_dynamic_buf_clock_tick: 2C12 */
+/* function ia_css_bufq_sp_release_dynamic_buf_clock_tick: 2BEC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_VAMEM_BASE
@@ -1502,46 +1406,46 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rawcopy_sp_tagger
 #define HIVE_MEM_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x6184
+#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x612C
 #define HIVE_SIZE_ia_css_rawcopy_sp_tagger 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x6184
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x612C
 #define HIVE_SIZE_sp_ia_css_rawcopy_sp_tagger 24
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x5880
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x5828
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_exp_ids 70
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x5880
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x5828
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_exp_ids 70
 
-/* function ia_css_queue_item_load: 4E97 */
+/* function ia_css_queue_item_load: 4D5C */
 
-/* function ia_css_spctrl_sp_get_state: 5C92 */
+/* function ia_css_spctrl_sp_get_state: 5B57 */
 
-/* function ia_css_isys_sp_token_map_uninit: 63BF */
+/* function ia_css_isys_sp_token_map_uninit: 6284 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_callout_sp_thread
 #define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_callout_sp_thread 0x4984
+#define HIVE_ADDR_callout_sp_thread 0x4884
 #define HIVE_SIZE_callout_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_callout_sp_thread 0x4984
+#define HIVE_ADDR_sp_callout_sp_thread 0x4884
 #define HIVE_SIZE_sp_callout_sp_thread 4
 
-/* function thread_fiber_sp_init: E86 */
+/* function thread_fiber_sp_init: EF0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_SP_PMEM_BASE
@@ -1555,65 +1459,53 @@
 #define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
 #define HIVE_SIZE_sp_SP_PMEM_BASE 4
 
-/* function ia_css_isys_sp_token_map_snd_acquire_req: 631E */
+/* function ia_css_isys_sp_token_map_snd_acquire_req: 61E3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_input_stream_format
 #define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_input_stream_format 0x40DC
+#define HIVE_ADDR_sp_isp_input_stream_format 0x3FDC
 #define HIVE_SIZE_sp_isp_input_stream_format 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x40DC
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3FDC
 #define HIVE_SIZE_sp_sp_isp_input_stream_format 20
 
-/* function __mod: 6BDE */
+/* function __mod: 6AC6 */
 
-/* function ia_css_dmaproxy_sp_init_dmem_channel: 31EF */
+/* function ia_css_dmaproxy_sp_init_dmem_channel: 30EE */
 
-/* function ia_css_thread_sp_join: D56 */
+/* function ia_css_thread_sp_join: DC0 */
 
-/* function ia_css_dmaproxy_sp_add_command: 72DF */
+/* function ia_css_dmaproxy_sp_add_command: 7122 */
 
-/* function ia_css_sp_metadata_thread_func: 5B3E */
+/* function ia_css_sp_metadata_thread_func: 5A03 */
 
-/* function __sp_event_proxy_func_critical: 6C71 */
-
-#ifndef HIVE_MULTIPLE_PROGRAMS
-#ifndef HIVE_MEM_dmaproxy_sp_proxy_status
-#define HIVE_MEM_dmaproxy_sp_proxy_status scalar_processor_2400_dmem
-#define HIVE_ADDR_dmaproxy_sp_proxy_status 0x208
-#define HIVE_SIZE_dmaproxy_sp_proxy_status 4
-#else
-#endif
-#endif
-#define HIVE_MEM_sp_dmaproxy_sp_proxy_status scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_dmaproxy_sp_proxy_status 0x208
-#define HIVE_SIZE_sp_dmaproxy_sp_proxy_status 4
+/* function __sp_event_proxy_func_critical: 6B59 */
 
-/* function ia_css_sp_metadata_wait: 5C59 */
+/* function ia_css_sp_metadata_wait: 5B1E */
 
-/* function ia_css_circbuf_peek_from_start: F63 */
+/* function ia_css_circbuf_peek_from_start: FCD */
 
-/* function ia_css_event_sp_encode: 352E */
+/* function ia_css_event_sp_encode: 33F3 */
 
-/* function ia_css_thread_sp_run: DC9 */
+/* function ia_css_thread_sp_run: E33 */
 
-/* function sp_isys_copy_func: 77D */
+/* function sp_isys_copy_func: 799 */
 
-/* function ia_css_isys_sp_backend_flush: 5DE8 */
+/* function ia_css_isys_sp_backend_flush: 5CAD */
 
-/* function ia_css_isys_sp_backend_frame_exists: 5CFD */
+/* function ia_css_isys_sp_backend_frame_exists: 5BC2 */
 
-/* function ia_css_sp_isp_param_init_isp_memories: 48D1 */
+/* function ia_css_sp_isp_param_init_isp_memories: 4796 */
 
-/* function register_isr: 901 */
+/* function register_isr: 91D */
 
 /* function irq_raise: D3 */
 
-/* function ia_css_dmaproxy_sp_mmu_invalidate: 2FE7 */
+/* function ia_css_dmaproxy_sp_mmu_invalidate: 2FC1 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SRST_ADDRESS
@@ -1627,41 +1519,41 @@
 #define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x1BC
 #define HIVE_SIZE_sp_HIVE_IF_SRST_ADDRESS 16
 
-/* function pipeline_sp_initialize_stage: 18D7 */
+/* function pipeline_sp_initialize_stage: 194D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_frontend_states
 #define HIVE_MEM_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x61B8
+#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x6160
 #define HIVE_SIZE_ia_css_isys_sp_frontend_states 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x61B8
+#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x6160
 #define HIVE_SIZE_sp_ia_css_isys_sp_frontend_states 12
 
-/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 71D9 */
+/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 7011 */
 
-/* function ia_css_ispctrl_sp_done_ds: 37C9 */
+/* function ia_css_ispctrl_sp_done_ds: 368E */
 
-/* function ia_css_sp_isp_param_get_mem_inits: 48AC */
+/* function ia_css_sp_isp_param_get_mem_inits: 4771 */
 
-/* function ia_css_parambuf_sp_init_buffer_queues: 1452 */
+/* function ia_css_parambuf_sp_init_buffer_queues: 14BC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_pfp_spref
 #define HIVE_MEM_vbuf_pfp_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_pfp_spref 0x2DC
+#define HIVE_ADDR_vbuf_pfp_spref 0x2F0
 #define HIVE_SIZE_vbuf_pfp_spref 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_pfp_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_pfp_spref 0x2DC
+#define HIVE_ADDR_sp_vbuf_pfp_spref 0x2F0
 #define HIVE_SIZE_sp_vbuf_pfp_spref 4
 
-/* function input_system_cfg: AEB */
+/* function input_system_cfg: B55 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_HMEM_BASE
@@ -1678,256 +1570,268 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_frames
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x58C8
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x5870
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_frames 280
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x58C8
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x5870
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_frames 280
 
-/* function ia_css_isys_sp_backend_release: 5E5D */
+/* function ia_css_isys_sp_backend_release: 5D22 */
 
-/* function ia_css_isys_sp_backend_destroy: 5E87 */
+/* function ia_css_isys_sp_backend_destroy: 5D4C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_buffer_queue_handle
 #define HIVE_MEM_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_buffer_queue_handle 0x59E0
+#define HIVE_ADDR_sp2host_buffer_queue_handle 0x5988
 #define HIVE_SIZE_sp2host_buffer_queue_handle 96
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x59E0
+#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x5988
 #define HIVE_SIZE_sp_sp2host_buffer_queue_handle 96
 
-/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 62E2 */
+/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 61A7 */
 
-/* function ia_css_ispctrl_sp_init_isp_vars: 45B2 */
+/* function ia_css_ispctrl_sp_init_isp_vars: 4477 */
 
-/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 5EDA */
+/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 5D9F */
 
-/* function sp_warning: 941 */
+/* function sp_warning: 95C */
 
-/* function ia_css_rmgr_sp_vbuf_enqueue: 66B7 */
+/* function ia_css_rmgr_sp_vbuf_enqueue: 6584 */
 
-/* function ia_css_tagger_sp_tag_exp_id: 20D4 */
+/* function ia_css_tagger_sp_tag_exp_id: 2135 */
 
-/* function ia_css_dmaproxy_sp_write: 319A */
+/* function ia_css_dmaproxy_sp_write: 30A1 */
 
-/* function ia_css_parambuf_sp_release_in_param: 12D2 */
+/* function ia_css_parambuf_sp_release_in_param: 133C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_irq_sw_interrupt_token
 #define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_irq_sw_interrupt_token 0x40D8
+#define HIVE_ADDR_irq_sw_interrupt_token 0x3FD8
 #define HIVE_SIZE_irq_sw_interrupt_token 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x40D8
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3FD8
 #define HIVE_SIZE_sp_irq_sw_interrupt_token 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_addresses
 #define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_addresses 0x5E34
+#define HIVE_ADDR_sp_isp_addresses 0x5DDC
 #define HIVE_SIZE_sp_isp_addresses 172
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_addresses 0x5E34
+#define HIVE_ADDR_sp_sp_isp_addresses 0x5DDC
 #define HIVE_SIZE_sp_sp_isp_addresses 172
 
-/* function ia_css_rmgr_sp_acq_gen: 65DC */
+/* function ia_css_rmgr_sp_acq_gen: 64A9 */
 
-/* function receiver_reg_load: B00 */
+/* function receiver_reg_load: B6A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isps
 #define HIVE_MEM_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_isps 0x61F0
+#define HIVE_ADDR_isps 0x6198
 #define HIVE_SIZE_isps 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isps 0x61F0
+#define HIVE_ADDR_sp_isps 0x6198
 #define HIVE_SIZE_sp_isps 28
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_queues_initialized
 #define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_queues_initialized 0x40F0
+#define HIVE_ADDR_host_sp_queues_initialized 0x3FF0
 #define HIVE_SIZE_host_sp_queues_initialized 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_queues_initialized 0x40F0
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3FF0
 #define HIVE_SIZE_sp_host_sp_queues_initialized 4
 
-/* function ia_css_queue_uninit: 4D40 */
+/* function ia_css_queue_uninit: 4C05 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_ispctrl_sp_isp_started
 #define HIVE_MEM_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5AE8
+#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5A90
 #define HIVE_SIZE_ia_css_ispctrl_sp_isp_started 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5AE8
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5A90
 #define HIVE_SIZE_sp_ia_css_ispctrl_sp_isp_started 4
 
-/* function ia_css_bufq_sp_release_dynamic_buf: 2C66 */
+/* function ia_css_bufq_sp_release_dynamic_buf: 2C40 */
 
-/* function ia_css_dmaproxy_sp_set_height_exception: 32A2 */
+/* function ia_css_dmaproxy_sp_set_height_exception: 319C */
 
-/* function ia_css_dmaproxy_sp_init_vmem_channel: 3225 */
+/* function ia_css_dmaproxy_sp_init_vmem_channel: 3121 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_num_ready_threads
 #define HIVE_MEM_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_num_ready_threads 0x498C
+#define HIVE_ADDR_num_ready_threads 0x488C
 #define HIVE_SIZE_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_num_ready_threads 0x498C
+#define HIVE_ADDR_sp_num_ready_threads 0x488C
 #define HIVE_SIZE_sp_num_ready_threads 4
 
-/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 316C */
+/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 3073 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_spref
 #define HIVE_MEM_vbuf_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_spref 0x2D8
+#define HIVE_ADDR_vbuf_spref 0x2EC
 #define HIVE_SIZE_vbuf_spref 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_spref 0x2D8
+#define HIVE_ADDR_sp_vbuf_spref 0x2EC
 #define HIVE_SIZE_sp_vbuf_spref 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_metadata_thread
 #define HIVE_MEM_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_metadata_thread 0x4940
+#define HIVE_ADDR_sp_metadata_thread 0x4840
 #define HIVE_SIZE_sp_metadata_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_metadata_thread 0x4940
+#define HIVE_ADDR_sp_sp_metadata_thread 0x4840
 #define HIVE_SIZE_sp_sp_metadata_thread 68
 
-/* function ia_css_queue_enqueue: 4C80 */
+/* function ia_css_queue_enqueue: 4B45 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_request
 #define HIVE_MEM_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_request 0x4998
+#define HIVE_ADDR_ia_css_flash_sp_request 0x4940
 #define HIVE_SIZE_ia_css_flash_sp_request 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x4998
+#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x4940
 #define HIVE_SIZE_sp_ia_css_flash_sp_request 4
 
-/* function ia_css_dmaproxy_sp_vmem_write: 3126 */
+/* function ia_css_dmaproxy_sp_vmem_write: 3044 */
 
-/* function ia_css_isys_sp_token_map_snd_capture_req: 6344 */
+#ifndef HIVE_MULTIPLE_PROGRAMS
+#ifndef HIVE_MEM_tagger_frames
+#define HIVE_MEM_tagger_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_tagger_frames 0x4894
+#define HIVE_SIZE_tagger_frames 168
+#else
+#endif
+#endif
+#define HIVE_MEM_sp_tagger_frames scalar_processor_2400_dmem
+#define HIVE_ADDR_sp_tagger_frames 0x4894
+#define HIVE_SIZE_sp_tagger_frames 168
+
+/* function ia_css_isys_sp_token_map_snd_capture_req: 6209 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_if
 #define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_if 0x4770
+#define HIVE_ADDR_sem_for_reading_if 0x4670
 #define HIVE_SIZE_sem_for_reading_if 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_if 0x4770
+#define HIVE_ADDR_sp_sem_for_reading_if 0x4670
 #define HIVE_SIZE_sp_sem_for_reading_if 20
 
-/* function sp_generate_interrupts: 9C0 */
+/* function sp_generate_interrupts: 9DB */
 
-/* function ia_css_pipeline_sp_start: 17EA */
+/* function ia_css_pipeline_sp_start: 1860 */
 
-/* function ia_css_sp_rawcopy_init: 531B */
+/* function ia_css_sp_rawcopy_init: 51E0 */
 
-/* function tmr_clock_read: AD2 */
+/* function tmr_clock_read: B3C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_BAMEM_BASE
 #define HIVE_MEM_ISP_BAMEM_BASE scalar_processor_2400_dmem
-#define HIVE_ADDR_ISP_BAMEM_BASE 0x2E8
+#define HIVE_ADDR_ISP_BAMEM_BASE 0x2F8
 #define HIVE_SIZE_ISP_BAMEM_BASE 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ISP_BAMEM_BASE scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x2E8
+#define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x2F8
 #define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
 
-/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5F92 */
+/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5E57 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A40
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x59E8
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5A40
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x59E8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 
-/* function css_get_frame_processing_time_start: 1F94 */
+/* function css_get_frame_processing_time_start: 200A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame
 #define HIVE_MEM_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame 0x4784
+#define HIVE_ADDR_sp_all_cbs_frame 0x4684
 #define HIVE_SIZE_sp_all_cbs_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame 0x4784
+#define HIVE_ADDR_sp_sp_all_cbs_frame 0x4684
 #define HIVE_SIZE_sp_sp_all_cbs_frame 16
 
-/* function thread_sp_queue_print: DE6 */
+/* function thread_sp_queue_print: E50 */
 
-/* function sp_notify_eof: 96C */
+/* function sp_notify_eof: 987 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_str2mem
 #define HIVE_MEM_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_str2mem 0x4794
+#define HIVE_ADDR_sem_for_str2mem 0x4694
 #define HIVE_SIZE_sem_for_str2mem 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_str2mem 0x4794
+#define HIVE_ADDR_sp_sem_for_str2mem 0x4694
 #define HIVE_SIZE_sp_sem_for_str2mem 20
 
-/* function ia_css_tagger_buf_sp_is_marked_from_start: 2A60 */
+/* function ia_css_tagger_buf_sp_is_marked_from_start: 2A3A */
 
-/* function ia_css_bufq_sp_acquire_dynamic_buf: 2E40 */
+/* function ia_css_bufq_sp_acquire_dynamic_buf: 2E1A */
 
-/* function ia_css_circbuf_destroy: 1085 */
+/* function ia_css_circbuf_destroy: 10EF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_PMEM_BASE
@@ -1941,68 +1845,68 @@
 #define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
 #define HIVE_SIZE_sp_ISP_PMEM_BASE 4
 
-/* function ia_css_sp_isp_param_mem_load: 4834 */
+/* function ia_css_sp_isp_param_mem_load: 46F9 */
 
-/* function __div: 6B96 */
+/* function __div: 6A7E */
 
-/* function ia_css_isys_sp_frontend_create: 6174 */
+/* function ia_css_isys_sp_frontend_create: 6039 */
 
-/* function ia_css_rmgr_sp_refcount_release_vbuf: 66D6 */
+/* function ia_css_rmgr_sp_refcount_release_vbuf: 65A3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_in_use
 #define HIVE_MEM_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_in_use 0x499C
+#define HIVE_ADDR_ia_css_flash_sp_in_use 0x4944
 #define HIVE_SIZE_ia_css_flash_sp_in_use 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x499C
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x4944
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_use 4
 
-/* function ia_css_thread_sem_sp_wait: 6E4F */
+/* function ia_css_thread_sem_sp_wait: 6D37 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sleep_mode
 #define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sleep_mode 0x40F4
+#define HIVE_ADDR_sp_sleep_mode 0x3FF4
 #define HIVE_SIZE_sp_sleep_mode 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sleep_mode 0x40F4
+#define HIVE_ADDR_sp_sp_sleep_mode 0x3FF4
 #define HIVE_SIZE_sp_sp_sleep_mode 4
 
+/* function ia_css_tagger_buf_sp_push: 294F */
+
 /* function mmu_invalidate_cache: EA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_max_cb_elems
 #define HIVE_MEM_sp_max_cb_elems scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_max_cb_elems 0x148
+#define HIVE_ADDR_sp_max_cb_elems 0x14C
 #define HIVE_SIZE_sp_max_cb_elems 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_max_cb_elems scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_max_cb_elems 0x148
+#define HIVE_ADDR_sp_sp_max_cb_elems 0x14C
 #define HIVE_SIZE_sp_sp_max_cb_elems 8
 
-/* function ia_css_dmaproxy_sp_register_channel_to_port: 30E4 */
-
-/* function ia_css_queue_remote_init: 4D62 */
+/* function ia_css_queue_remote_init: 4C27 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stop_req
 #define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stop_req 0x4628
+#define HIVE_ADDR_isp_stop_req 0x4528
 #define HIVE_SIZE_isp_stop_req 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stop_req 0x4628
+#define HIVE_ADDR_sp_isp_stop_req 0x4528
 #define HIVE_SIZE_sp_isp_stop_req 4
 
 #define HIVE_ICACHE_sp_critical_SEGMENT_START 0
-- 
1.9.1

