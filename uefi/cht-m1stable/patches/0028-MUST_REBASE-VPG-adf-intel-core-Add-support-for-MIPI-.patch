From a2ba8bd0cce4338dee2f303ac321036daa687ed9 Mon Sep 17 00:00:00 2001
Message-Id: <a2ba8bd0cce4338dee2f303ac321036daa687ed9.1421709247.git.chang-joon.lee@intel.com>
In-Reply-To: <3650eb44734ad4fbe098313349da8185595a20d8.1421709247.git.chang-joon.lee@intel.com>
References: <3650eb44734ad4fbe098313349da8185595a20d8.1421709247.git.chang-joon.lee@intel.com>
From: Shobhit Kumar <shobhit.kumar@intel.com>
Date: Thu, 4 Sep 2014 17:58:54 +0530
Subject: [PATCH 28/75] MUST_REBASE [VPG]: adf:/intel/core: Add support for
 MIPI DSI Encoder for GEN platforms

- Add DSI pipe ops
- Define the vlv_dc_config to have dsi_pipe as a union
- Check while initializing the disply the pipe type and init matching
  pipe. Today only dsi_pipe_init is supported
- Enable PIPE event handling fro DSI pipe. Later when similar handling is
  needed for HDMI as well then move them to event callback between
  differnet encoder types
- Add DSI encoder enable/disable sequence
- Add generic mipi panel driver. Today supports only Single linke Video
  mode. Burst mode is supported.

MUST_REBASE: Since Google ADF framework is not in upstream and also
we cannot have two display drivers, other one being i915, we need to
work on i915 and ADF convergence path before it can be upstreamed

For: GMINL-3547
Change-Id: I98bf1b37284eb1c101e2a6d8d6278adde7b4a139
Signed-off-by: Shashank Sharma <shashank.sharma@intel.com>
Signed-off-by: Shobhit Kumar <shobhit.kumar@intel.com>
---
 drivers/video/adf/intel/core/common/dsi/Makefile   |   24 +
 .../video/adf/intel/core/common/dsi/dsi_config.c   |   23 +-
 .../video/adf/intel/core/common/dsi/dsi_panel.c    |   19 +-
 drivers/video/adf/intel/core/common/dsi/dsi_pipe.c |    3 +-
 .../video/adf/intel/core/common/dsi/dsi_pipe_ops.c |  564 +++++++++++++++
 drivers/video/adf/intel/core/common/dsi/dsi_vbt.h  |  232 +++++++
 .../video/adf/intel/core/common/dsi/gen_dsi_pipe.c |  404 +++++++++++
 .../video/adf/intel/core/common/dsi/intel_dsi.h    |   47 ++
 .../adf/intel/core/common/dsi/intel_dsi_cmd.c      |  412 +++++++++++
 .../adf/intel/core/common/dsi/intel_dsi_cmd.h      |  113 +++
 .../adf/intel/core/common/dsi/intel_dsi_pll.c      |  217 ++++++
 .../adf/intel/core/common/dsi/panels/Makefile      |   16 +
 .../core/common/dsi/panels/intel_dsi_panel_vbt.c   |  732 ++++++++++++++++++++
 drivers/video/adf/intel/core/intel_adf_drv.c       |    3 +
 drivers/video/adf/intel/core/intel_dc_config.c     |    2 +-
 drivers/video/adf/intel/core/intel_pipe.c          |    2 +
 drivers/video/adf/intel/core/vlv/vlv_dc_config.c   |   32 +-
 .../adf/intel/include/core/common/dsi/dsi_config.h |   85 ++-
 .../adf/intel/include/core/common/dsi/dsi_panel.h  |   21 +-
 .../adf/intel/include/core/common/dsi/dsi_pipe.h   |    5 +
 .../video/adf/intel/include/core/vlv/vlv_dc_hw.h   |   54 ++
 21 files changed, 2976 insertions(+), 34 deletions(-)
 create mode 100644 drivers/video/adf/intel/core/common/dsi/Makefile
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/dsi_vbt.h
 create mode 100644 drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/intel_dsi.h
 create mode 100644 drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
 create mode 100644 drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/Makefile
 create mode 100644 drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c

diff --git a/drivers/video/adf/intel/core/common/dsi/Makefile b/drivers/video/adf/intel/core/common/dsi/Makefile
new file mode 100644
index 0000000..282e3fa
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/Makefile
@@ -0,0 +1,24 @@
+# Makefile for Intel display driver based on ADF framework
+
+ccflags-y := -Idrivers/staging/ -Iinclude/adf -Iinclude/uapi/adf -Idrivers/video/adf/intel/include -Werror
+
+CFLAGS_adf.o := -I$(src)
+
+ifdef CONFIG_ADF_INTEL_VLV
+	obj-y := gen_dsi_pipe.o
+	obj-y += dsi_pipe_ops.o
+	obj-y += intel_dsi_cmd.o
+	obj-y += intel_dsi_pll.o
+else
+	obj-y := dsi_pipe.o
+	obj-y += dsi_dbi.o
+	obj-y += dsi_dbi_dsr.o
+	obj-y += dsi_dpi_sdo.o
+	obj-y += dsi_pkg_sender.o
+endif
+
+obj-y += dsi_config.o
+obj-y += dsi_panel.o
+
+obj-y += panels/
+
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_config.c b/drivers/video/adf/intel/core/common/dsi/dsi_config.c
index 152d030..c82d567 100644
--- a/drivers/video/adf/intel/core/common/dsi/dsi_config.c
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_config.c
@@ -18,6 +18,7 @@
 #include "core/common/dsi/dsi_config.h"
 #include "core/common/dsi/dsi_panel.h"
 
+#ifndef CONFIG_ADF_INTEL_VLV
 static void dsi_regs_init(struct dsi_config *config, int idx)
 {
 	struct dsi_registers *regs;
@@ -174,6 +175,8 @@ static void dsi_regs_init(struct dsi_config *config, int idx)
 	}
 }
 
+#endif
+
 int dsi_config_init(struct dsi_config *config,
 			struct dsi_panel *panel, u8 idx)
 {
@@ -181,6 +184,8 @@ int dsi_config_init(struct dsi_config *config,
 	struct panel_info pi;
 	struct drm_mode_modeinfo mode;
 
+	pr_err("ADF: %s\n", __func__);
+
 	if (!config || !panel) {
 		pr_err("%s: invalid parameter\n", __func__);
 		err = -EINVAL;
@@ -205,29 +210,31 @@ int dsi_config_init(struct dsi_config *config,
 		goto out_err0;
 	}
 
-	err = panel->ops->get_config_mode(&mode);
+	err = panel->ops->get_config_mode(config, &mode);
 	if (err) {
 		pr_err("%s: failed to get configured mode\n", __func__);
 		goto out_err0;
 	}
 
-	panel->ops->get_panel_info(&pi);
+	panel->ops->get_panel_info(config, &pi);
+
+	memcpy(&config->perferred_mode, &mode, sizeof(mode));
 
 	config->changed = 0;
-	config->channel_num = 0;
 	config->drv_ic_inited = 0;
+	config->bpp = pi.bpp;
+	config->dual_link = pi.dual_link;
+
+#ifdef CONFIG_INTEL_ADF_VLV
+	config->channel_num = 0;
 	config->enable_gamma_csc = 0;
 	config->video_mode = DSI_VIDEO_BURST_MODE;
-	config->bpp = pi.bpp;
 	config->lane_count = pi.lane_num;
 	config->type = pi.dsi_type;
-	config->dual_link = pi.dual_link;
-
-	memcpy(&config->perferred_mode, &mode, sizeof(mode));
 
 	/*init regs*/
 	dsi_regs_init(config, idx);
-
+#endif
 	/*init context lock*/
 	mutex_init(&config->ctx_lock);
 
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_panel.c b/drivers/video/adf/intel/core/common/dsi/dsi_panel.c
index 68d817f..5948e16 100644
--- a/drivers/video/adf/intel/core/common/dsi/dsi_panel.c
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_panel.c
@@ -16,8 +16,11 @@
  **************************************************************************/
 
 #include "core/common/dsi/dsi_panel.h"
+#include "dsi_vbt.h"
 
+#ifndef CONFIG_ADF_INTEL_VLV
 extern int PanelID;
+
 /*declare get panel callbacks*/
 extern const struct dsi_panel *cmi_get_panel(void);
 extern struct dsi_panel *jdi_cmd_get_panel(void);
@@ -26,6 +29,7 @@ extern struct dsi_panel *sharp_10x19_cmd_get_panel(void);
 extern struct dsi_panel *sharp_10x19_dual_cmd_get_panel(void);
 extern struct dsi_panel *sharp_25x16_vid_get_panel(void);
 extern struct dsi_panel *sharp_25x16_cmd_get_panel(void);
+#endif
 
 struct supported_panel_item {
 	u8 id;
@@ -33,6 +37,8 @@ struct supported_panel_item {
 };
 
 static const struct supported_panel_item supported_panels[] = {
+	{MIPI_DSI_GENERIC_PANEL_ID, get_generic_panel},
+#ifdef SUPPORT_ALL_PANELS
 	{CMI_7x12_CMD, cmi_get_panel},
 	{JDI_7x12_CMD, jdi_cmd_get_panel},
 	{JDI_7x12_VID, jdi_vid_get_panel},
@@ -40,27 +46,32 @@ static const struct supported_panel_item supported_panels[] = {
 	{SHARP_10x19_DUAL_CMD, sharp_10x19_dual_cmd_get_panel},
 	{SHARP_25x16_VID, sharp_25x16_vid_get_panel},
 	{SHARP_25x16_CMD, sharp_25x16_cmd_get_panel},
+#endif
 };
 
-const struct dsi_panel *get_dsi_panel_by_id(u8 id)
+struct dsi_panel *get_dsi_panel_by_id(u8 id)
 {
 	int i;
 
+	pr_debug("ADF: %s\n", __func__);
+#ifndef CONFIG_ADF_INTEL_VLV
 	if (id == GCT_DETECT) {
 		pr_err("%s: invalid panel id\n", __func__);
 		return NULL;
 	}
-
+#endif
 	for (i = 0; i < ARRAY_SIZE(supported_panels); i++) {
 		if (id == supported_panels[i].id)
-			return supported_panels[i].get_panel();
+			return (struct dsi_panel *)
+					supported_panels[i].get_panel();
 	}
 
 	return NULL;
 }
 
+#ifndef CONFIG_ADF_INTEL_VLV
 const struct dsi_panel *get_dsi_panel(void)
 {
-
 	return get_dsi_panel_by_id((u8)PanelID);
 }
+#endif
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_pipe.c b/drivers/video/adf/intel/core/common/dsi/dsi_pipe.c
index b6478ef..381e473 100644
--- a/drivers/video/adf/intel/core/common/dsi/dsi_pipe.c
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_pipe.c
@@ -10,6 +10,7 @@
 #include "core/common/dsi/dsi_pipe.h"
 #include "core/common/dsi/dsi_dbi.h"
 #include "core/common/dsi/dsi_dpi.h"
+#include "core/common/intel_dc_regs.h"
 
 #define KSEL_CRYSTAL_19 1
 #define KSEL_BYPASS_19 5
@@ -738,7 +739,7 @@ int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 	memset(pipe, 0, sizeof(struct dsi_pipe));
 
 	/*get panel*/
-	panel = get_dsi_panel();
+	panel = get_dsi_panel_by_id(INTEL_GENERIC);
 	if (!panel)
 		return -ENODEV;
 
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c b/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
new file mode 100644
index 0000000..56c4438
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_pipe_ops.c
@@ -0,0 +1,564 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#include <drm/i915_drm.h>
+#include <drm/i915_adf_wrapper.h>
+#include <intel_adf_device.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/common/dsi/dsi_config.h>
+#include <core/vlv/vlv_dc_regs.h>
+#include <core/vlv/vlv_dc_config.h>
+#include "intel_dsi.h"
+#include "intel_dsi_cmd.h"
+
+static void vlv_flisdsi_write(u32 reg, u32 val)
+{
+	intel_dpio_sideband_rw(INTEL_SIDEBAND_REG_WRITE, IOSF_PORT_FLISDSI,
+			      reg, &val);
+}
+
+static void band_gap_reset(void)
+{
+	pr_err("ADF: %s\n", __func__);
+
+	vlv_flisdsi_write(0x0F, 0x0001);
+	vlv_flisdsi_write(0x0F, 0x0005);
+	vlv_flisdsi_write(0x0F, 0x0025);
+	udelay(150);
+	vlv_flisdsi_write(0x0F, 0x0000);
+	vlv_flisdsi_write(0x08, 0x0000);
+}
+
+static inline bool is_vid_mode(struct dsi_config *config)
+{
+	return config->ctx.operation_mode == DSI_DPI;
+}
+
+static inline bool is_cmd_mode(struct dsi_config *config)
+{
+	return config->ctx.operation_mode == DSI_DBI;
+}
+
+static void intel_dsi_device_ready(struct dsi_pipe *dsi_pipe)
+{
+	int pipe = dsi_pipe->config.pipe;
+	u32 val;
+
+	pr_err("ADF: %s\n", __func__);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_ENTER);
+	usleep_range(2500, 3000);
+
+	val = REG_READ(MIPI_PORT_CTRL(pipe));
+	REG_WRITE(MIPI_PORT_CTRL(pipe), val | LP_OUTPUT_HOLD);
+	usleep_range(1000, 1500);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), ULPS_STATE_EXIT);
+	usleep_range(2500, 3000);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY);
+	usleep_range(2500, 3000);
+}
+
+static void intel_dsi_enable(struct dsi_pipe *dsi_pipe)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	u32 temp;
+
+	pr_debug("ADF: %s\n", __func__);
+	if (is_cmd_mode(config))
+		REG_WRITE(MIPI_MAX_RETURN_PKT_SIZE(pipe), 8 * 4);
+	else {
+		msleep(20); /* XXX */
+		dpi_send_cmd(dsi_pipe, TURN_ON, DPI_LP_MODE_EN);
+		msleep(100);
+
+		if (panel->ops->power_on)
+			panel->ops->power_on(dsi_pipe);
+
+		wait_for_dsi_fifo_empty(dsi_pipe);
+
+		/* assert ip_tg_enable signal */
+		temp = REG_READ(MIPI_PORT_CTRL(pipe)) &
+				~LANE_CONFIGURATION_MASK;
+		temp = temp | intel_dsi->port_bits;
+		REG_WRITE(MIPI_PORT_CTRL(pipe), temp | DPI_ENABLE);
+		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
+	}
+}
+
+/* return txclkesc cycles in terms of divider and duration in us */
+static u16 txclkesc(u32 divider, unsigned int us)
+{
+	switch (divider) {
+	case ESCAPE_CLOCK_DIVIDER_1:
+	default:
+		return 20 * us;
+	case ESCAPE_CLOCK_DIVIDER_2:
+		return 10 * us;
+	case ESCAPE_CLOCK_DIVIDER_4:
+		return 5 * us;
+	}
+}
+
+/* return pixels in terms of txbyteclkhs */
+static u16 txbyteclkhs(u16 pixels, int bpp, int lane_count,
+		       u16 burst_mode_ratio)
+{
+	return DIV_ROUND_UP(DIV_ROUND_UP(pixels * bpp * burst_mode_ratio,
+					 8 * 100), lane_count);
+}
+
+static void set_dsi_timings(struct dsi_pipe *dsi_pipe,
+			    const struct drm_mode_modeinfo *mode)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	unsigned int bpp = config->bpp;
+	unsigned int lane_count = intel_dsi->lane_count;
+	u32 val;
+
+	u16 hactive, hfp, hsync, hbp, vfp, vsync, vbp;
+
+	pr_err("ADF: %s\n", __func__);
+
+	/* DEVICE_READY[0] = 0 */
+	val = REG_READ(MIPI_DEVICE_READY(pipe));
+	val &= ~0x1;
+	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
+
+	hactive = mode->hdisplay;
+	hfp = mode->hsync_start - mode->hdisplay;
+	hsync = mode->hsync_end - mode->hsync_start;
+	hbp = mode->htotal - mode->hsync_end;
+
+	vfp = mode->vsync_start - mode->vdisplay;
+	vsync = mode->vsync_end - mode->vsync_start;
+	vbp = mode->vtotal - mode->vsync_end;
+
+	/* horizontal values are in terms of high speed byte clock */
+	hactive = txbyteclkhs(hactive, bpp, lane_count,
+			      intel_dsi->burst_mode_ratio);
+	hfp = txbyteclkhs(hfp, bpp, lane_count, intel_dsi->burst_mode_ratio);
+	hsync = txbyteclkhs(hsync, bpp, lane_count,
+			    intel_dsi->burst_mode_ratio);
+	hbp = txbyteclkhs(hbp, bpp, lane_count, intel_dsi->burst_mode_ratio);
+
+	REG_WRITE(MIPI_HACTIVE_AREA_COUNT(pipe), hactive);
+	REG_WRITE(MIPI_HFP_COUNT(pipe), hfp);
+
+	/* meaningful for video mode non-burst sync pulse mode only, can be zero
+	 * for non-burst sync events and burst modes */
+	REG_WRITE(MIPI_HSYNC_PADDING_COUNT(pipe), hsync);
+	REG_WRITE(MIPI_HBP_COUNT(pipe), hbp);
+
+	/* vertical values are in terms of lines */
+	REG_WRITE(MIPI_VFP_COUNT(pipe), vfp);
+	REG_WRITE(MIPI_VSYNC_PADDING_COUNT(pipe), vsync);
+	REG_WRITE(MIPI_VBP_COUNT(pipe), vbp);
+
+	val = intel_dsi->lane_count << DATA_LANES_PRG_REG_SHIFT;
+	if (is_cmd_mode(config)) {
+		val |= intel_dsi->channel << CMD_MODE_CHANNEL_NUMBER_SHIFT;
+		val |= CMD_MODE_DATA_WIDTH_8_BIT; /* XXX */
+	} else {
+		val |= intel_dsi->channel << VID_MODE_CHANNEL_NUMBER_SHIFT;
+
+		/* XXX: cross-check bpp vs. pixel format? */
+		val |= intel_dsi->pixel_format;
+	}
+	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), val);
+
+	val = 0;
+	if (intel_dsi->eotp_pkt == 0)
+		val |= EOT_DISABLE;
+
+	if (intel_dsi->clock_stop)
+		val |= CLOCKSTOP;
+
+	/* recovery disables */
+	REG_WRITE(MIPI_EOT_DISABLE(pipe), val);
+
+	/* DEVICE_READY[0] = 1 */
+	val = REG_READ(MIPI_DEVICE_READY(pipe));
+	val |= 0x1;
+	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
+
+	/* XXX: why here, why like this? handling in irq handler?! */
+	REG_WRITE(MIPI_INTR_STAT(pipe), 0xffffffff);
+	REG_WRITE(MIPI_INTR_EN(pipe), 0xffffffff);
+}
+
+int intel_dsi_modeset(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
+{
+	pr_err("ADF: %s\n", __func__);
+
+	vlv_display_off(&dsi_pipe->base);
+
+	return 0;
+}
+
+int intel_dsi_prepare(struct dsi_pipe *dsi_pipe, struct drm_mode_modeinfo *mode)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	unsigned int bpp = config->bpp;
+	u32 val, tmp;
+
+	pr_err("ADF: %s\n", __func__);
+
+	val = REG_READ(MIPI_DEVICE_READY(pipe));
+	val &= ~0x1;
+	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
+
+	/* escape clock divider, 20MHz, shared for A and C. device ready must be
+	 * off when doing this! txclkesc? */
+	tmp = REG_READ(MIPI_CTRL(0));
+	tmp &= ~ESCAPE_CLOCK_DIVIDER_MASK;
+	REG_WRITE(MIPI_CTRL(0), tmp | ESCAPE_CLOCK_DIVIDER_1);
+
+	/* read request priority is per pipe */
+	tmp = REG_READ(MIPI_CTRL(pipe));
+	tmp &= ~READ_REQUEST_PRIORITY_MASK;
+	REG_WRITE(MIPI_CTRL(pipe), tmp | READ_REQUEST_PRIORITY_HIGH);
+
+	REG_WRITE(MIPI_DPHY_PARAM(pipe), intel_dsi->dphy_reg);
+
+	REG_WRITE(MIPI_DPI_RESOLUTION(pipe),
+		   mode->vdisplay << VERTICAL_ADDRESS_SHIFT |
+		   mode->hdisplay << HORIZONTAL_ADDRESS_SHIFT);
+
+	/* timeouts for recovery. one frame IIUC. if counter expires, EOT and
+	 * stop state. */
+
+	/*
+	 * In burst mode, value greater than one DPI line Time in byte clock
+	 * (txbyteclkhs) To timeout this timer 1+ of the above said value is
+	 * recommended.
+	 *
+	 * In non-burst mode, Value greater than one DPI frame time in byte
+	 * clock(txbyteclkhs) To timeout this timer 1+ of the above said value
+	 * is recommended.
+	 *
+	 * In DBI only mode, value greater than one DBI frame time in byte
+	 * clock(txbyteclkhs) To timeout this timer 1+ of the above said value
+	 * is recommended.
+	 */
+
+	if (is_vid_mode(config) &&
+	    intel_dsi->video_mode_format == VIDEO_MODE_BURST) {
+		REG_WRITE(MIPI_HS_TX_TIMEOUT(pipe),
+			   txbyteclkhs(mode->htotal, bpp,
+				       intel_dsi->lane_count,
+				       intel_dsi->burst_mode_ratio) + 1);
+	} else {
+		REG_WRITE(MIPI_HS_TX_TIMEOUT(pipe),
+			   txbyteclkhs(mode->vtotal *
+				       mode->htotal,
+				       bpp, intel_dsi->lane_count,
+				       intel_dsi->burst_mode_ratio) + 1);
+	}
+
+	REG_WRITE(MIPI_HS_TX_TIMEOUT(pipe), 0x3FFFFF);
+	REG_WRITE(MIPI_LP_RX_TIMEOUT(pipe), intel_dsi->lp_rx_timeout);
+	REG_WRITE(MIPI_TURN_AROUND_TIMEOUT(pipe), intel_dsi->turn_arnd_val);
+	REG_WRITE(MIPI_DEVICE_RESET_TIMER(pipe), intel_dsi->rst_timer_val);
+
+	/* dphy stuff */
+
+	/* in terms of low power clock */
+	REG_WRITE(MIPI_INIT_COUNT(pipe),
+				 txclkesc(intel_dsi->escape_clk_div, 100));
+
+	/* in terms of low power clock */
+	REG_WRITE(MIPI_INIT_COUNT(pipe), intel_dsi->init_count);
+
+	/* in terms of txbyteclkhs. actual high to low switch +
+	 * MIPI_STOP_STATE_STALL * MIPI_LP_BYTECLK.
+	 *
+	 * XXX: write MIPI_STOP_STATE_STALL?
+	 */
+	REG_WRITE(MIPI_HIGH_LOW_SWITCH_COUNT(pipe),
+		   intel_dsi->hs_to_lp_count);
+
+	/* XXX: low power clock equivalence in terms of byte clock. the number
+	 * of byte clocks occupied in one low power clock. based on txbyteclkhs
+	 * and txclkesc. txclkesc time / txbyteclk time * (105 +
+	 * MIPI_STOP_STATE_STALL) / 105.???
+	 */
+	REG_WRITE(MIPI_LP_BYTECLK(pipe), intel_dsi->lp_byte_clk);
+
+	/* the bw essential for transmitting 16 long packets containing 252
+	 * bytes meant for dcs write memory command is programmed in this
+	 * register in terms of byte clocks. based on dsi transfer rate and the
+	 * number of lanes configured the time taken to transmit 16 long packets
+	 * in a dsi stream varies. */
+	REG_WRITE(MIPI_DBI_BW_CTRL(pipe), intel_dsi->bw_timer);
+
+	REG_WRITE(MIPI_CLK_LANE_SWITCH_TIME_CNT(pipe),
+		   intel_dsi->clk_lp_to_hs_count << LP_HS_SSW_CNT_SHIFT |
+		   intel_dsi->clk_hs_to_lp_count << HS_LP_PWR_SW_CNT_SHIFT);
+
+	if (is_vid_mode(config))
+		/* Some panels might have resolution which is not a multiple of
+		 * 64 like 1366 x 768. Enable RANDOM resolution support for such
+		 * panels by default */
+		REG_WRITE(MIPI_VIDEO_MODE_FORMAT(pipe),
+			   intel_dsi->video_frmt_cfg_bits |
+			   intel_dsi->video_mode_format |
+			   IP_TG_CONFIG |
+			   RANDOM_DPI_DISPLAY_RESOLUTION);
+
+	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), 0);
+	REG_WRITE(MIPI_EOT_DISABLE(pipe), CLOCKSTOP);
+
+	val = REG_READ(MIPI_DEVICE_READY(pipe));
+	val |= 0x1;
+	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
+
+	return 0;
+}
+
+static void intel_dsi_pre_pll_enable(struct dsi_pipe *dsi_pipe)
+{
+	pr_debug("ADF: %s\n", __func__);
+	vlv_enable_dsi_pll(&dsi_pipe->config);
+}
+
+int intel_dsi_pre_enable(struct dsi_pipe *dsi_pipe)
+{
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	int pipe = dsi_pipe->config.pipe;
+	u32 tmp;
+	struct drm_mode_modeinfo mode;
+
+	pr_err("ADF: %s\n", __func__);
+
+	/* program rcomp for compliance, reduce from 50 ohms to 45 ohms
+	 * needed everytime after power gate */
+	vlv_flisdsi_write(0x04, 0x0004);
+
+	/* bandgap reset is needed after everytime we do power gate */
+	band_gap_reset();
+
+	/*
+	 * FIXME:
+	 * Add panel power on using PMIC/I2C
+	 */
+	msleep(intel_dsi->panel_on_delay);
+
+	if (panel->ops->reset)
+		panel->ops->reset(dsi_pipe);
+
+	/* Disable DPOunit clock gating, can stall pipe
+	 * and we need DPLL REFA always enabled */
+	tmp = REG_READ(DPLL(pipe));
+	tmp |= DPLL_REFA_CLK_ENABLE_VLV;
+	REG_WRITE(DPLL(pipe), tmp);
+
+	tmp = REG_READ(DSPCLK_GATE_D);
+	tmp |= DPOUNIT_CLOCK_GATE_DISABLE;
+	REG_WRITE(DSPCLK_GATE_D, tmp);
+
+	intel_dsi_pre_pll_enable(dsi_pipe);
+
+	/* put device in ready state */
+	intel_dsi_device_ready(dsi_pipe);
+
+	/*
+	 * FIXME:
+	 * get the mode; works for DSI as only one mode
+	 */
+	panel->ops->get_config_mode(&dsi_pipe->config, &mode);
+
+	intel_dsi_prepare(dsi_pipe, &mode);
+
+	if (panel->ops->drv_ic_init)
+		panel->ops->drv_ic_init(dsi_pipe);
+
+	wait_for_dsi_fifo_empty(dsi_pipe);
+
+	set_dsi_timings(dsi_pipe, &mode);
+
+	/* Enable port in pre-enable phase itself because as per hw team
+	 * recommendation, port should be enabled befor plane & pipe */
+	intel_dsi_enable(dsi_pipe);
+
+	/* enable pipe */
+	pipe_mode_set(&dsi_pipe->base, &mode);
+
+	return 0;
+}
+
+void intel_dsi_pre_disable(struct dsi_pipe *dsi_pipe)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+
+	pr_debug("ADF: %s\n", __func__);
+
+	if (is_vid_mode(config)) {
+		/* Send Shutdown command to the panel in LP mode */
+		dpi_send_cmd(dsi_pipe, SHUTDOWN, DPI_LP_MODE_EN);
+		usleep_range(10000, 10500);
+		pr_err("ADF: %s: Sent DPI_SHUTDOWN\n", __func__);
+	}
+}
+
+int intel_dsi_disable(struct dsi_pipe *dsi_pipe)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	int pipe = dsi_pipe->config.pipe;
+	u32 temp;
+
+	pr_err("ADF: %s\n", __func__);
+
+	if (is_vid_mode(config)) {
+		wait_for_dsi_fifo_empty(dsi_pipe);
+
+		/* de-assert ip_tg_enable signal */
+		temp = REG_READ(MIPI_PORT_CTRL(pipe));
+		REG_WRITE(MIPI_PORT_CTRL(pipe), temp & ~DPI_ENABLE);
+		REG_POSTING_READ(MIPI_PORT_CTRL(pipe));
+
+		usleep_range(2000, 2500);
+	}
+
+	/* Panel commands can be sent when clock is in LP11 */
+	temp = REG_READ(MIPI_DEVICE_READY(pipe));
+	temp &= ~0x1;
+	REG_WRITE(MIPI_DEVICE_READY(pipe), temp);
+
+	temp = REG_READ(MIPI_CTRL(pipe));
+	temp &= ~ESCAPE_CLOCK_DIVIDER_MASK;
+	REG_WRITE(MIPI_CTRL(pipe), temp |
+		   intel_dsi->escape_clk_div <<
+		   ESCAPE_CLOCK_DIVIDER_SHIFT);
+
+	/*
+	 * FIXME:
+	 * Writing 0 here works but we get LP not going low error
+	temp = REG_READ(MIPI_DSI_FUNC_PRG(pipe));
+	temp &= ~VID_MODE_FORMAT_MASK;
+	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), temp);
+	*/
+	REG_WRITE(MIPI_DSI_FUNC_PRG(pipe), 0);
+
+	REG_WRITE(MIPI_EOT_DISABLE(pipe), CLOCKSTOP);
+
+	temp = REG_READ(MIPI_DEVICE_READY(pipe));
+	temp |= 0x1;
+	REG_WRITE(MIPI_DEVICE_READY(pipe), temp);
+
+	/* if disable packets are sent before sending shutdown packet then in
+	 * some next enable sequence send turn on packet error is observed */
+	if (panel->ops->power_off)
+		panel->ops->power_off(dsi_pipe);
+
+	wait_for_dsi_fifo_empty(dsi_pipe);
+
+	return 0;
+}
+
+static void intel_dsi_clear_device_ready(struct dsi_pipe *dsi_pipe)
+{
+	int pipe = dsi_pipe->config.pipe;
+	u32 val;
+	pr_debug("ADF: %s\n", __func__);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_ENTER);
+	usleep_range(2000, 2500);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_EXIT);
+	usleep_range(2000, 2500);
+
+	REG_WRITE(MIPI_DEVICE_READY(pipe), DEVICE_READY | ULPS_STATE_ENTER);
+	usleep_range(2000, 2500);
+
+	if (wait_for(((REG_READ(MIPI_PORT_CTRL(pipe)) & AFE_LATCHOUT)
+		      == 0x00000), 30))
+		DRM_ERROR("DSI LP not going Low\n");
+
+	val = REG_READ(MIPI_PORT_CTRL(pipe));
+	REG_WRITE(MIPI_PORT_CTRL(pipe), val & ~LP_OUTPUT_HOLD);
+	usleep_range(1000, 1500);
+
+	val = REG_READ(MIPI_DEVICE_READY(pipe));
+	val &= ~0x1;
+	REG_WRITE(MIPI_DEVICE_READY(pipe), val);
+	usleep_range(2000, 2500);
+
+	vlv_disable_dsi_pll(&dsi_pipe->config);
+}
+
+int intel_dsi_post_disable(struct dsi_pipe *dsi_pipe)
+{
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	struct dsi_panel *panel = dsi_pipe->panel;
+	u32 val;
+
+	pr_debug("ADF: %s\n", __func__);
+	intel_dsi_disable(dsi_pipe);
+
+	intel_dsi_clear_device_ready(dsi_pipe);
+
+	val = REG_READ(DSPCLK_GATE_D);
+	val &= ~DPOUNIT_CLOCK_GATE_DISABLE;
+	REG_WRITE(DSPCLK_GATE_D, val);
+
+	if (panel->ops->disable_panel_power)
+		panel->ops->disable_panel_power(dsi_pipe);
+
+	msleep(intel_dsi->panel_off_delay);
+	msleep(intel_dsi->panel_pwr_cycle_delay);
+
+	return 0;
+}
+
+int intel_dsi_set_events(struct dsi_pipe *dsi_pipe, u8 event, bool enabled)
+{
+	return 0;
+}
+
+void intel_dsi_get_events(struct dsi_pipe *dsi_pipe, u32 *events)
+{
+	return;
+}
+
+void intel_dsi_handle_events(struct dsi_pipe *dsi_pipe, u32 events)
+{
+	return;
+}
+
+void intel_dsi_pre_post(struct dsi_pipe *dsi_pipe)
+{
+	return;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/dsi_vbt.h b/drivers/video/adf/intel/core/common/dsi/dsi_vbt.h
new file mode 100644
index 0000000..6253609
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/dsi_vbt.h
@@ -0,0 +1,232 @@
+/*
+ * Copyright © 2006 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *    Shobhit Kumar <shobhit.kumar@intel.com>
+ *
+ */
+
+#ifndef _DSI_VBT_H_
+#define _DSI_VBT_H_
+
+/* Block 52 contains MIPI Panel info
+ * 6 such enteries will there. Index into correct
+ * entery is based on the panel_index in #40 LFP
+ */
+#define MAX_MIPI_CONFIGURATIONS	6
+
+#define MIPI_DSI_UNDEFINED_PANEL_ID	0
+#define MIPI_DSI_GENERIC_PANEL_ID	1
+#define INTEL_DSI_COMMAND_MODE	0
+#define INTEL_DSI_VIDEO_MODE	1
+
+struct mipi_config {
+	u16 panel_id;
+
+	/* General Params */
+	u32 enable_dithering:1;
+	u32 rsvd1:1;
+	u32 is_bridge:1;
+
+	u32 panel_arch_type:2;
+	u32 is_cmd_mode:1;
+
+#define NON_BURST_SYNC_PULSE	0x1
+#define NON_BURST_SYNC_EVENTS	0x2
+#define BURST_MODE		0x3
+	u32 video_transfer_mode:2;
+
+	u32 cabc_supported:1;
+	u32 pwm_blc:1;
+
+	/* Bit 13:10 */
+#define PIXEL_FORMAT_RGB565			0x1
+#define PIXEL_FORMAT_RGB666			0x2
+#define PIXEL_FORMAT_RGB666_LOOSELY_PACKED	0x3
+#define PIXEL_FORMAT_RGB888			0x4
+	u32 videomode_color_format:4;
+
+	/* Bit 15:14 */
+#define ENABLE_ROTATION_0	0x0
+#define ENABLE_ROTATION_90	0x1
+#define ENABLE_ROTATION_180	0x2
+#define ENABLE_ROTATION_270	0x3
+	u32 rotation:2;
+	u32 bta_enabled:1;
+	u32 rsvd2:15;
+
+	/* 2 byte Port Description */
+#define DUAL_LINK_NOT_SUPPORTED	0
+#define DUAL_LINK_FRONT_BACK	1
+#define DUAL_LINK_PIXEL_ALT	2
+	u16 dual_link:2;
+	u16 lane_cnt:2;
+	u16 rsvd3:12;
+
+	u16 rsvd4;
+
+	u8 rsvd5;
+	u32 target_burst_mode_freq;
+	u32 dsi_ddr_clk;
+	u32 bridge_ref_clk;
+
+#define  BYTE_CLK_SEL_20MHZ		0
+#define  BYTE_CLK_SEL_10MHZ		1
+#define  BYTE_CLK_SEL_5MHZ		2
+	u8 byte_clk_sel:2;
+
+	u8 rsvd6:6;
+
+	/* DPHY Flags */
+	u16 dphy_param_valid:1;
+	u16 eot_pkt_disabled:1;
+	u16 enable_clk_stop:1;
+	u16 rsvd7:13;
+
+	u32 hs_tx_timeout;
+	u32 lp_rx_timeout;
+	u32 turn_around_timeout;
+	u32 device_reset_timer;
+	u32 master_init_timer;
+	u32 dbi_bw_timer;
+	u32 lp_byte_clk_val;
+
+	/*  4 byte Dphy Params */
+	u32 prepare_cnt:6;
+	u32 rsvd8:2;
+	u32 clk_zero_cnt:8;
+	u32 trail_cnt:5;
+	u32 rsvd9:3;
+	u32 exit_zero_cnt:6;
+	u32 rsvd10:2;
+
+	u32 clk_lane_switch_cnt;
+	u32 hl_switch_cnt;
+
+	u32 rsvd11[6];
+
+	/* timings based on dphy spec */
+	u8 tclk_miss;
+	u8 tclk_post;
+	u8 rsvd12;
+	u8 tclk_pre;
+	u8 tclk_prepare;
+	u8 tclk_settle;
+	u8 tclk_term_enable;
+	u8 tclk_trail;
+	u16 tclk_prepare_clkzero;
+	u8 rsvd13;
+	u8 td_term_enable;
+	u8 teot;
+	u8 ths_exit;
+	u8 ths_prepare;
+	u16 ths_prepare_hszero;
+	u8 rsvd14;
+	u8 ths_settle;
+	u8 ths_skip;
+	u8 ths_trail;
+	u8 tinit;
+	u8 tlpx;
+	u8 rsvd15[3];
+
+	/* GPIOs */
+	u8 panel_enable;
+	u8 bl_enable;
+	u8 pwm_enable;
+	u8 reset_r_n;
+	u8 pwr_down_r;
+	u8 stdby_r_n;
+
+} __packed;
+
+/* Block 52 contains MIPI configuration block
+ * 6 * bdb_mipi_config, followed by 6 pps data
+ * block below
+ *
+ * all delays has a unit of 100us
+ */
+struct mipi_pps_data {
+	u16 panel_on_delay;
+	u16 bl_enable_delay;
+	u16 bl_disable_delay;
+	u16 panel_off_delay;
+	u16 panel_power_cycle_delay;
+};
+
+struct bdb_mipi_config {
+	struct mipi_config config[MAX_MIPI_CONFIGURATIONS];
+	struct mipi_pps_data pps[MAX_MIPI_CONFIGURATIONS];
+};
+
+/* Block 53 contains MIPI sequences as needed by the panel
+ * for enabling it. This block can be variable in size and
+ * can be maximum of 6 blocks
+ */
+struct bdb_mipi_sequence {
+	u8 version;
+	u8 data[0];
+};
+
+/* MIPI Sequnece Block definitions */
+enum mipi_seq {
+	MIPI_SEQ_UNDEFINED = 0,
+	MIPI_SEQ_ASSERT_RESET,
+	MIPI_SEQ_INIT_OTP,
+	MIPI_SEQ_DISPLAY_ON,
+	MIPI_SEQ_DISPLAY_OFF,
+	MIPI_SEQ_DEASSERT_RESET,
+	MIPI_SEQ_MAX
+};
+
+enum mipi_seq_element {
+	MIPI_SEQ_ELEM_UNDEFINED = 0,
+	MIPI_SEQ_ELEM_SEND_PKT,
+	MIPI_SEQ_ELEM_DELAY,
+	MIPI_SEQ_ELEM_GPIO,
+	MIPI_SEQ_ELEM_STATUS,
+	MIPI_SEQ_ELEM_MAX
+};
+
+enum mipi_gpio_pin_index {
+	MIPI_GPIO_UNDEFINED = 0,
+	MIPI_GPIO_PANEL_ENABLE,
+	MIPI_GPIO_BL_ENABLE,
+	MIPI_GPIO_PWM_ENABLE,
+	MIPI_GPIO_RESET_N,
+	MIPI_GPIO_PWR_DOWN_R,
+	MIPI_GPIO_STDBY_RST_N,
+	MIPI_GPIO_MAX
+};
+
+/* MIPI DSI */
+struct dsi_vbt {
+	u16 port;
+	u16 panel_id;
+	struct mipi_config *config;
+	struct mipi_pps_data *pps;
+	u8 seq_version;
+	u32 size;
+	u8 *data;
+	u8 *sequence[MIPI_SEQ_MAX];
+};
+
+#endif /* _DSI_VBT_H_ */
diff --git a/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c b/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
new file mode 100644
index 0000000..c60518e
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/gen_dsi_pipe.c
@@ -0,0 +1,404 @@
+/*
+ * ann_dsi_pipe.c
+ *
+ *  Created on: May 23, 2014
+ *      Author: root
+ */
+
+#include <drm/drm_mode.h>
+#include <drm/i915_drm.h>
+
+#include <core/intel_dc_config.h>
+#include <core/vlv/vlv_dc_regs.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/common/dsi/dsi_config.h>
+#include <intel_adf_device.h>
+#include "dsi_vbt.h"
+#include "intel_dsi.h"
+
+static void dsi_pipe_suspend(struct intel_dc_component *component)
+{
+	struct intel_pipe *pipe = to_intel_pipe(component);
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	/*power gate the power rail directly*/
+	dsi_pipe->ops.power_off(dsi_pipe);
+}
+
+static void dsi_pipe_resume(struct intel_dc_component *component)
+{
+	struct intel_pipe *pipe = to_intel_pipe(component);
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	dsi_pipe->ops.power_on(dsi_pipe);
+}
+
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+static int dsi_set_brightness(struct intel_pipe *pipe, int level)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_panel *panel = NULL;
+	struct dsi_config *config = NULL;
+	struct dsi_context *ctx = NULL;
+	int err = 0;
+
+	if (!dsi_pipe) {
+		pr_err("%s: invalid DSI interface", __func__);
+		return -EINVAL;
+	}
+
+	panel = dsi_pipe->panel;
+	if (!panel || !panel->ops || !panel->ops->set_brightness) {
+		pr_err("%s: invalid panel\n", __func__);
+		return -EINVAL;
+	}
+
+	config = &dsi_pipe->config;
+	ctx = &config->ctx;
+
+	mutex_lock(&config->ctx_lock);
+
+	ctx->backlight_level = level;
+	err = panel->ops->set_brightness(dsi_pipe, level);
+
+	mutex_unlock(&config->ctx_lock);
+
+	return err;
+}
+#endif
+
+static int dsi_pipe_hw_init(struct intel_pipe *pipe)
+{
+	return 0;
+}
+
+static void dsi_pipe_hw_deinit(struct intel_pipe *pipe)
+{
+
+}
+
+static void dsi_get_modelist(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **modelist, size_t *n_modes)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+
+	mutex_lock(&config->ctx_lock);
+	*modelist = &config->perferred_mode;
+	*n_modes = 1;
+	mutex_unlock(&config->ctx_lock);
+}
+
+static void dsi_get_preferred_mode(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo **mode)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+
+	mutex_lock(&config->ctx_lock);
+	*mode = &config->perferred_mode;
+	mutex_unlock(&config->ctx_lock);
+
+	pr_err("ADF: %s: Preferred Mode = %dx%d @%d\n", __func__,
+	       (*mode)->hdisplay, (*mode)->vdisplay, (*mode)->vrefresh);
+}
+
+static bool dsi_is_screen_connected(struct intel_pipe *pipe)
+{
+	return true;
+}
+
+static int dsi_dpms(struct intel_pipe *pipe, u8 state)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+	int err = 0;
+
+	if (!config)
+		return -EINVAL;
+
+	mutex_lock(&config->ctx_lock);
+
+	switch (state) {
+	case DRM_MODE_DPMS_ON:
+		err = dsi_pipe->ops.power_on(dsi_pipe);
+		break;
+	case DRM_MODE_DPMS_OFF:
+		err = dsi_pipe->ops.power_off(dsi_pipe);
+		break;
+	case DRM_MODE_DPMS_STANDBY:
+	case DRM_MODE_DPMS_SUSPEND:
+	default:
+		mutex_unlock(&config->ctx_lock);
+		pr_err("%s: unsupported dpms mode\n", __func__);
+		return -EOPNOTSUPP;
+	}
+
+	mutex_unlock(&config->ctx_lock);
+	return err;
+}
+
+static int dsi_modeset(struct intel_pipe *pipe,
+		struct drm_mode_modeinfo *mode)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_config *config = &dsi_pipe->config;
+	int err = 0;
+
+	if (!mode) {
+		pr_err("%s: invalid mode\n", __func__);
+		err = -EINVAL;
+		return err;
+	}
+
+	if (!config) {
+		pr_err("%s: invalid DSI config\n", __func__);
+		err = -EINVAL;
+		return err;
+	}
+
+	mutex_lock(&config->ctx_lock);
+
+	err = dsi_pipe->ops.mode_set(dsi_pipe, mode);
+	if (err) {
+		pr_err("%s: failed to set mode\n", __func__);
+		goto out_err;
+	}
+
+out_err:
+	mutex_unlock(&config->ctx_lock);
+	return err;
+}
+
+static int dsi_get_screen_size(struct intel_pipe *pipe,
+		u16 *width_mm, u16 *height_mm)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	struct dsi_panel *panel = dsi_pipe->panel;
+	struct panel_info pi;
+	int err;
+
+	if (!panel || !panel->ops || !panel->ops->get_panel_info) {
+		pr_err("%s: failed to get panel info\n", __func__);
+		err = -ENODEV;
+		goto out_err;
+	}
+
+	panel->ops->get_panel_info(&dsi_pipe->config, &pi);
+
+	*width_mm = pi.width_mm;
+	*height_mm = pi.height_mm;
+
+	return 0;
+out_err:
+	return err;
+}
+
+static void dsi_on_post(struct intel_pipe *pipe)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.on_post)
+		dsi_pipe->ops.on_post(dsi_pipe);
+}
+
+static void dsi_pre_post(struct intel_pipe *pipe)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.pre_post)
+		dsi_pipe->ops.pre_post(dsi_pipe);
+}
+
+static u32 dsi_get_supported_events(struct intel_pipe *pipe)
+{
+	return INTEL_PIPE_EVENT_VSYNC;
+}
+
+static int dsi_set_event(struct intel_pipe *pipe, u8 event, bool enabled)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.set_event)
+		return dsi_pipe->ops.set_event(dsi_pipe, event, enabled);
+	else
+		return -EOPNOTSUPP;
+}
+
+/**
+ * FIXME: hardware vsync counter failed to work on ANN. use static SW
+ * counter for now.
+ */
+static u32 vsync_counter;
+
+#define VSYNC_COUNT_MAX_MASK 0xffffff
+
+static void dsi_get_events(struct intel_pipe *pipe, u32 *events)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+	u8 idx = pipe->base.idx;
+	u32 dc_events = REG_READ(VLV_IIR);
+	u32 event_bit;
+
+	*events = 0;
+
+	pr_debug("%s: IIR = %#x\n", __func__, dc_events);
+
+	switch (idx) {
+	case 0:
+		event_bit = I915_DISPLAY_PIPE_A_VBLANK_INTERRUPT;
+		break;
+	case 2:
+		event_bit = I915_DISPLAY_PIPE_B_VBLANK_INTERRUPT;
+		break;
+	default:
+		pr_err("%s: invalid pipe index %d\n", __func__, idx);
+		return;
+	}
+
+	if (!(dc_events & event_bit))
+		return;
+
+	/* Clear the 1st level interrupt. */
+	REG_WRITE(VLV_IIR, dc_events);
+
+	if (dsi_pipe->ops.get_events)
+		dsi_pipe->ops.get_events(dsi_pipe, events);
+
+	/**
+	 * FIXME: should use hardware vsync counter.
+	 */
+	if (*events & INTEL_PIPE_EVENT_VSYNC) {
+		if (++vsync_counter > VSYNC_COUNT_MAX_MASK)
+			vsync_counter = 0;
+	}
+}
+
+u32 dsi_get_vsync_counter(struct intel_pipe *pipe, u32 interval)
+{
+	u32 count;
+	u32 max_count_mask = VSYNC_COUNT_MAX_MASK;
+
+	count = vsync_counter;
+	count |= (~max_count_mask);
+	count += interval;
+	count &= max_count_mask;
+
+	pr_debug("%s: count = %#x\n", __func__, count);
+
+	return count;
+}
+
+/* Handle more device custom events. */
+static void dsi_handle_events(struct intel_pipe *pipe, u32 events)
+{
+	struct dsi_pipe *dsi_pipe = to_dsi_pipe(pipe);
+
+	if (dsi_pipe->ops.handle_events)
+		dsi_pipe->ops.handle_events(dsi_pipe, events);
+}
+
+static struct intel_pipe_ops dsi_base_ops = {
+	.base = {
+		.suspend = dsi_pipe_suspend,
+		.resume = dsi_pipe_resume,
+	},
+	.hw_init = dsi_pipe_hw_init,
+	.hw_deinit = dsi_pipe_hw_deinit,
+	.get_preferred_mode = dsi_get_preferred_mode,
+	.is_screen_connected = dsi_is_screen_connected,
+	.get_modelist = dsi_get_modelist,
+	.dpms = dsi_dpms,
+	.modeset = dsi_modeset,
+	.get_screen_size = dsi_get_screen_size,
+	.pre_post = dsi_pre_post,
+	.on_post = dsi_on_post,
+	.get_supported_events = dsi_get_supported_events,
+	.set_event = dsi_set_event,
+	.get_events = dsi_get_events,
+	.get_vsync_counter = dsi_get_vsync_counter,
+	.handle_events = dsi_handle_events,
+#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE
+	.set_brightness = dsi_set_brightness,
+#endif
+};
+
+void dsi_pipe_destroy(struct dsi_pipe *pipe)
+{
+	if (pipe)
+		dsi_config_destroy(&pipe->config);
+}
+
+int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
+	struct intel_plane *primary_plane, u8 idx)
+{
+	struct dsi_panel *panel;
+	int err, i;
+
+	pr_debug("ADF:%s:\n", __func__);
+
+	if (!pipe || !primary_plane)
+		return -EINVAL;
+
+	memset(pipe, 0, sizeof(struct dsi_pipe));
+
+	/*get panel*/
+	panel = get_dsi_panel_by_id(MIPI_DSI_GENERIC_PANEL_ID);
+	if (!panel)
+		return -ENODEV;
+
+	/*
+	 * For GEN DSI implementation of generic driver, we need this call
+	 * before any other panel ops
+	 */
+	if (!panel->ops || !panel->ops->dsi_controller_init) {
+		pr_err("%s: panel doesn't have initialization params\n",
+		       __func__);
+		err = -ENODEV;
+		goto err;
+	}
+
+	err = panel->ops->dsi_controller_init(pipe);
+	if (err) {
+		pr_err("%s: panel doesn't have initialization params\n",
+		       __func__);
+		err = -ENODEV;
+		goto err;
+	}
+
+	/*init config*/
+	err = dsi_config_init(&pipe->config, panel, idx);
+	if (err)
+		goto err;
+
+	/*init dsi interface ops*/
+	pipe->ops.power_on = intel_dsi_pre_enable;
+	pipe->ops.pre_power_off = intel_dsi_pre_disable;
+	pipe->ops.power_off = intel_dsi_post_disable;
+	pipe->ops.mode_set = intel_dsi_modeset;
+	pipe->ops.pre_post = intel_dsi_pre_post;
+	pipe->ops.set_event = intel_dsi_set_events;
+	pipe->ops.get_events = intel_dsi_get_events;
+	pipe->ops.handle_events = intel_dsi_handle_events;
+
+	pipe->panel = panel;
+
+	err = intel_pipe_init(&pipe->base, dev, idx, true, INTEL_PIPE_DSI,
+		primary_plane, &dsi_base_ops, "dsi_pipe");
+	if (err)
+		goto err;
+
+	/* initialize the LUT */
+	for (i = 0; i < 256; i++) {
+		pipe->config.lut_r[i] = i;
+		pipe->config.lut_g[i] = i;
+		pipe->config.lut_b[i] = i;
+	}
+
+	pipe->config.pixel_multiplier = 1;
+
+	return 0;
+err:
+	dsi_pipe_destroy(pipe);
+	return err;
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi.h b/drivers/video/adf/intel/core/common/dsi/intel_dsi.h
new file mode 100644
index 0000000..f21613d
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _INTEL_DSI_H
+#define _INTEL_DSI_H
+
+#define INTEL_SIDEBAND_REG_READ		0
+#define INTEL_SIDEBAND_REG_WRITE	1
+
+extern void vlv_enable_dsi_pll(struct dsi_config *);
+extern void vlv_disable_dsi_pll(struct dsi_config *);
+extern u32 vlv_get_dsi_pclk(struct dsi_config *, int pipe_bpp);
+
+extern int intel_dsi_pre_enable(struct dsi_pipe *dsi_pipe);
+extern void intel_dsi_pre_post(struct dsi_pipe *dsi_pipe);
+extern int intel_dsi_post_disable(struct dsi_pipe *dsi_pipe);
+extern int intel_dsi_prepare(struct dsi_pipe *dsi_pipe,
+						struct drm_mode_modeinfo *mode);
+extern int intel_dsi_set_events(struct dsi_pipe *dsi_pipe, u8 event,
+						bool enabled);
+extern void intel_dsi_get_events(struct dsi_pipe *dsi_pipe, u32 *events);
+extern void intel_dsi_handle_events(struct dsi_pipe *dsi_pipe, u32 events);
+extern void intel_dsi_pre_disable(struct dsi_pipe *dsi_pipe);
+extern int intel_dsi_modeset(struct dsi_pipe *dsi_pipe,
+						struct drm_mode_modeinfo *mode);
+
+#endif /* _INTEL_DSI_H */
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c
new file mode 100644
index 0000000..0d13958
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.c
@@ -0,0 +1,412 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Jani Nikula <jani.nikula@intel.com>
+ */
+
+#include <linux/export.h>
+#include <video/mipi_display.h>
+#include <core/common/dsi/dsi_config.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/vlv/vlv_dc_regs.h>
+#include "intel_dsi.h"
+#include "intel_dsi_cmd.h"
+
+/*
+ * XXX: MIPI_DATA_ADDRESS, MIPI_DATA_LENGTH, MIPI_COMMAND_LENGTH, and
+ * MIPI_COMMAND_ADDRESS registers.
+ *
+ * Apparently these registers provide a MIPI adapter level way to send (lots of)
+ * commands and data to the receiver, without having to write the commands and
+ * data to MIPI_{HS,LP}_GEN_{CTRL,DATA} registers word by word.
+ *
+ * Presumably for anything other than MIPI_DCS_WRITE_MEMORY_START and
+ * MIPI_DCS_WRITE_MEMORY_CONTINUE (which are used to update the external
+ * framebuffer in command mode displays) these are just an optimization that can
+ * come later.
+ *
+ * For memory writes, these should probably be used for performance.
+ */
+
+static void print_stat(struct dsi_pipe *dsi_pipe)
+{
+	int pipe = dsi_pipe->config.pipe;
+	u32 val;
+
+	val = REG_READ(MIPI_INTR_STAT(pipe));
+
+#define STAT_BIT(val, bit) (val) & (bit) ? " " #bit : ""
+	pr_info("MIPI_INTR_STAT(%d) = %08x"
+	      "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"
+		      "\n", pipe, val,
+		      STAT_BIT(val, TEARING_EFFECT),
+		      STAT_BIT(val, SPL_PKT_SENT_INTERRUPT),
+		      STAT_BIT(val, GEN_READ_DATA_AVAIL),
+		      STAT_BIT(val, LP_GENERIC_WR_FIFO_FULL),
+		      STAT_BIT(val, HS_GENERIC_WR_FIFO_FULL),
+		      STAT_BIT(val, RX_PROT_VIOLATION),
+		      STAT_BIT(val, RX_INVALID_TX_LENGTH),
+		      STAT_BIT(val, ACK_WITH_NO_ERROR),
+		      STAT_BIT(val, TURN_AROUND_ACK_TIMEOUT),
+		      STAT_BIT(val, LP_RX_TIMEOUT),
+		      STAT_BIT(val, HS_TX_TIMEOUT),
+		      STAT_BIT(val, DPI_FIFO_UNDERRUN),
+		      STAT_BIT(val, LOW_CONTENTION),
+		      STAT_BIT(val, HIGH_CONTENTION),
+		      STAT_BIT(val, TXDSI_VC_ID_INVALID),
+		      STAT_BIT(val, TXDSI_DATA_TYPE_NOT_RECOGNISED),
+		      STAT_BIT(val, TXCHECKSUM_ERROR),
+		      STAT_BIT(val, TXECC_MULTIBIT_ERROR),
+		      STAT_BIT(val, TXECC_SINGLE_BIT_ERROR),
+		      STAT_BIT(val, TXFALSE_CONTROL_ERROR),
+		      STAT_BIT(val, RXDSI_VC_ID_INVALID),
+		      STAT_BIT(val, RXDSI_DATA_TYPE_NOT_REGOGNISED),
+		      STAT_BIT(val, RXCHECKSUM_ERROR),
+		      STAT_BIT(val, RXECC_MULTIBIT_ERROR),
+		      STAT_BIT(val, RXECC_SINGLE_BIT_ERROR),
+		      STAT_BIT(val, RXFALSE_CONTROL_ERROR),
+		      STAT_BIT(val, RXHS_RECEIVE_TIMEOUT_ERROR),
+		      STAT_BIT(val, RX_LP_TX_SYNC_ERROR),
+		      STAT_BIT(val, RXEXCAPE_MODE_ENTRY_ERROR),
+		      STAT_BIT(val, RXEOT_SYNC_ERROR),
+		      STAT_BIT(val, RXSOT_SYNC_ERROR),
+		      STAT_BIT(val, RXSOT_ERROR));
+#undef STAT_BIT
+}
+
+enum dsi_type {
+	DSI_DCS,
+	DSI_GENERIC,
+};
+
+/* enable or disable command mode hs transmissions */
+void dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	u32 temp;
+	u32 mask = DBI_FIFO_EMPTY;
+
+	if (wait_for((REG_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == mask, 50))
+		pr_err("Timeout waiting for DBI FIFO empty\n");
+
+	temp = REG_READ(MIPI_HS_LP_DBI_ENABLE(pipe));
+	temp &= DBI_HS_LP_MODE_MASK;
+	REG_WRITE(MIPI_HS_LP_DBI_ENABLE(pipe),
+		 enable ? DBI_HS_MODE : DBI_LP_MODE);
+
+	intel_dsi->hs = enable;
+}
+
+static int dsi_vc_send_short(struct dsi_pipe *dsi_pipe, int channel,
+			     u8 data_type, u16 data)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	u32 ctrl_reg;
+	u32 ctrl;
+	u32 mask;
+
+	pr_info("channel %d, data_type %d, data %04x\n",
+		      channel, data_type, data);
+
+	if (intel_dsi->hs) {
+		ctrl_reg = MIPI_HS_GEN_CTRL(pipe);
+		mask = HS_CTRL_FIFO_FULL;
+	} else {
+		ctrl_reg = MIPI_LP_GEN_CTRL(pipe);
+		mask = LP_CTRL_FIFO_FULL;
+	}
+
+	if (wait_for((REG_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == 0, 50)) {
+		pr_err("Timeout waiting for HS/LP CTRL FIFO !full\n");
+		print_stat(dsi_pipe);
+	}
+
+	/*
+	 * Note: This function is also used for long packets, with length passed
+	 * as data, since SHORT_PACKET_PARAM_SHIFT ==
+	 * LONG_PACKET_WORD_COUNT_SHIFT.
+	 */
+	ctrl = data << SHORT_PACKET_PARAM_SHIFT |
+		channel << VIRTUAL_CHANNEL_SHIFT |
+		data_type << DATA_TYPE_SHIFT;
+
+	REG_WRITE(ctrl_reg, ctrl);
+
+	return 0;
+}
+
+static int dsi_vc_send_long(struct dsi_pipe *dsi_pipe, int channel,
+			    u8 data_type, const u8 *data, int len)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	u32 data_reg;
+	int i, j, n;
+	u32 mask;
+
+	pr_info("channel %d, data_type %d, len %04x\n",
+		      channel, data_type, len);
+
+	if (intel_dsi->hs) {
+		data_reg = MIPI_HS_GEN_DATA(pipe);
+		mask = HS_DATA_FIFO_FULL;
+	} else {
+		data_reg = MIPI_LP_GEN_DATA(pipe);
+		mask = LP_DATA_FIFO_FULL;
+	}
+
+	if (wait_for((REG_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == 0, 50))
+		pr_err("Timeout waiting for HS/LP DATA FIFO !full\n");
+
+	for (i = 0; i < len; i += n) {
+		u32 val = 0;
+		n = min_t(int, len - i, 4);
+
+		for (j = 0; j < n; j++)
+			val |= *data++ << 8 * j;
+
+		REG_WRITE(data_reg, val);
+		/* XXX: check for data fifo full, once that is set, write 4
+		 * dwords, then wait for not set, then continue. */
+	}
+
+	return dsi_vc_send_short(dsi_pipe, channel, data_type, len);
+}
+
+static int dsi_vc_write_common(struct dsi_pipe *dsi_pipe,
+			       int channel, const u8 *data, int len,
+			       enum dsi_type type)
+{
+	int ret;
+
+	if (len == 0) {
+		BUG_ON(type == DSI_GENERIC);
+		ret = dsi_vc_send_short(dsi_pipe, channel,
+					MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM,
+					0);
+	} else if (len == 1) {
+		ret = dsi_vc_send_short(dsi_pipe, channel,
+					type == DSI_GENERIC ?
+					MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM :
+					MIPI_DSI_DCS_SHORT_WRITE, data[0]);
+	} else if (len == 2) {
+		ret = dsi_vc_send_short(dsi_pipe, channel,
+					type == DSI_GENERIC ?
+					MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM :
+					MIPI_DSI_DCS_SHORT_WRITE_PARAM,
+					(data[1] << 8) | data[0]);
+	} else {
+		ret = dsi_vc_send_long(dsi_pipe, channel,
+				       type == DSI_GENERIC ?
+				       MIPI_DSI_GENERIC_LONG_WRITE :
+				       MIPI_DSI_DCS_LONG_WRITE, data, len);
+	}
+
+	return ret;
+}
+
+int dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
+		     const u8 *data, int len)
+{
+	return dsi_vc_write_common(dsi_pipe, channel, data, len, DSI_DCS);
+}
+
+int dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
+			 const u8 *data, int len)
+{
+	return dsi_vc_write_common(dsi_pipe, channel, data, len, DSI_GENERIC);
+}
+
+static int dsi_vc_dcs_send_read_request(struct dsi_pipe *dsi_pipe,
+					int channel, u8 dcs_cmd)
+{
+	return dsi_vc_send_short(dsi_pipe, channel, MIPI_DSI_DCS_READ,
+				 dcs_cmd);
+}
+
+static int dsi_vc_generic_send_read_request(struct dsi_pipe *dsi_pipe,
+					    int channel, u8 *reqdata,
+					    int reqlen)
+{
+	u16 data;
+	u8 data_type;
+
+	switch (reqlen) {
+	case 0:
+		data_type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;
+		data = 0;
+		break;
+	case 1:
+		data_type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;
+		data = reqdata[0];
+		break;
+	case 2:
+		data_type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;
+		data = (reqdata[1] << 8) | reqdata[0];
+		break;
+	default:
+		BUG();
+	}
+
+	return dsi_vc_send_short(dsi_pipe, channel, data_type, data);
+}
+
+static int dsi_read_data_return(struct dsi_pipe *dsi_pipe,
+				u8 *buf, int buflen)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	int pipe = config->pipe;
+	int i, len = 0;
+	u32 data_reg, val;
+
+	if (intel_dsi->hs)
+		data_reg = MIPI_HS_GEN_DATA(pipe);
+	else
+		data_reg = MIPI_LP_GEN_DATA(pipe);
+
+	while (len < buflen) {
+		val = REG_READ(data_reg);
+		for (i = 0; i < 4 && len < buflen; i++, len++)
+			buf[len] = val >> 8 * i;
+	}
+
+	return len;
+}
+
+int dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
+		    u8 *buf, int buflen)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	int pipe = config->pipe;
+	u32 mask;
+	int ret;
+
+	/*
+	 * XXX: should issue multiple read requests and reads if request is
+	 * longer than MIPI_MAX_RETURN_PKT_SIZE
+	 */
+
+	REG_WRITE(MIPI_INTR_STAT(pipe), GEN_READ_DATA_AVAIL);
+
+	ret = dsi_vc_dcs_send_read_request(dsi_pipe, channel, dcs_cmd);
+	if (ret)
+		return ret;
+
+	mask = GEN_READ_DATA_AVAIL;
+	if (wait_for((REG_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 50))
+		DRM_ERROR("Timeout waiting for read data.\n");
+
+	ret = dsi_read_data_return(dsi_pipe, buf, buflen);
+	if (ret < 0)
+		return ret;
+
+	if (ret != buflen)
+		return -EIO;
+
+	return 0;
+}
+
+int dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
+			u8 *reqdata, int reqlen, u8 *buf, int buflen)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	int pipe = config->pipe;
+	u32 mask;
+	int ret;
+
+	/*
+	 * XXX: should issue multiple read requests and reads if request is
+	 * longer than MIPI_MAX_RETURN_PKT_SIZE
+	 */
+
+	REG_WRITE(MIPI_INTR_STAT(pipe), GEN_READ_DATA_AVAIL);
+
+	ret = dsi_vc_generic_send_read_request(dsi_pipe, channel, reqdata,
+					       reqlen);
+	if (ret)
+		return ret;
+
+	mask = GEN_READ_DATA_AVAIL;
+	if (wait_for((REG_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 50))
+		pr_err("Timeout waiting for read data.\n");
+
+	ret = dsi_read_data_return(dsi_pipe, buf, buflen);
+	if (ret < 0)
+		return ret;
+
+	if (ret != buflen)
+		return -EIO;
+
+	return 0;
+}
+
+/*
+ * send a video mode command
+ *
+ * XXX: commands with data in MIPI_DPI_DATA?
+ */
+int dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	int pipe = config->pipe;
+	u32 mask;
+
+	/* XXX: pipe, hs */
+	if (hs)
+		cmd &= ~DPI_LP_MODE;
+	else
+		cmd |= DPI_LP_MODE;
+
+	/* clear bit */
+	REG_WRITE(MIPI_INTR_STAT(pipe), SPL_PKT_SENT_INTERRUPT);
+
+	/* XXX: old code skips write if control unchanged */
+	if (cmd == REG_READ(MIPI_DPI_CONTROL(pipe)))
+		pr_err("Same special packet %02x twice in a row.\n", cmd);
+
+	REG_WRITE(MIPI_DPI_CONTROL(pipe), cmd);
+
+	mask = SPL_PKT_SENT_INTERRUPT;
+	if (wait_for((REG_READ(MIPI_INTR_STAT(pipe)) & mask) == mask, 100))
+		pr_err("Video mode command 0x%08x send failed.\n", cmd);
+
+	return 0;
+}
+
+void wait_for_dsi_fifo_empty(struct dsi_pipe *dsi_pipe)
+{
+	struct dsi_config *config = &dsi_pipe->config;
+	int pipe = config->pipe;
+	u32 mask;
+
+	mask = LP_CTRL_FIFO_EMPTY | HS_CTRL_FIFO_EMPTY |
+		LP_DATA_FIFO_EMPTY | HS_DATA_FIFO_EMPTY;
+
+	if (wait_for((REG_READ(MIPI_GEN_FIFO_STAT(pipe)) & mask) == mask, 100))
+		pr_err("DPI FIFOs are not empty\n");
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
new file mode 100644
index 0000000..d00b41f
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi_cmd.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Jani Nikula <jani.nikula@intel.com>
+ */
+
+#ifndef _INTEL_DSI_DSI_H
+#define _INTEL_DSI_DSI_H
+
+#include <drm/drmP.h>
+#include <drm/i915_drm.h>
+#include <video/mipi_display.h>
+#include "core/common/dsi/dsi_pipe.h"
+#include "core/common/dsi/dsi_config.h"
+#include "intel_adf_device.h"
+
+#define DPI_LP_MODE_EN	false
+#define DPI_HS_MODE_EN	true
+
+void dsi_hs_mode_enable(struct dsi_pipe *dsi_pipe, bool enable);
+
+int dsi_vc_dcs_write(struct dsi_pipe *dsi_pipe, int channel,
+		     const u8 *data, int len);
+
+int dsi_vc_generic_write(struct dsi_pipe *dsi_pipe, int channel,
+			 const u8 *data, int len);
+
+int dsi_vc_dcs_read(struct dsi_pipe *dsi_pipe, int channel, u8 dcs_cmd,
+		    u8 *buf, int buflen);
+
+int dsi_vc_generic_read(struct dsi_pipe *dsi_pipe, int channel,
+			u8 *reqdata, int reqlen, u8 *buf, int buflen);
+
+int dpi_send_cmd(struct dsi_pipe *dsi_pipe, u32 cmd, bool hs);
+void wait_for_dsi_fifo_empty(struct dsi_pipe *dsi_pipe);
+
+/* XXX: questionable write helpers */
+static inline int dsi_vc_dcs_write_0(struct dsi_pipe *dsi_pipe,
+				     int channel, u8 dcs_cmd)
+{
+	return dsi_vc_dcs_write(dsi_pipe, channel, &dcs_cmd, 1);
+}
+
+static inline int dsi_vc_dcs_write_1(struct dsi_pipe *dsi_pipe,
+				     int channel, u8 dcs_cmd, u8 param)
+{
+	u8 buf[2] = { dcs_cmd, param };
+	return dsi_vc_dcs_write(dsi_pipe, channel, buf, 2);
+}
+
+static inline int dsi_vc_generic_write_0(struct dsi_pipe *dsi_pipe,
+					 int channel)
+{
+	return dsi_vc_generic_write(dsi_pipe, channel, NULL, 0);
+}
+
+static inline int dsi_vc_generic_write_1(struct dsi_pipe *dsi_pipe,
+					 int channel, u8 param)
+{
+	return dsi_vc_generic_write(dsi_pipe, channel, &param, 1);
+}
+
+static inline int dsi_vc_generic_write_2(struct dsi_pipe *dsi_pipe,
+					 int channel, u8 param1, u8 param2)
+{
+	u8 buf[2] = { param1, param2 };
+	return dsi_vc_generic_write(dsi_pipe, channel, buf, 2);
+}
+
+/* XXX: questionable read helpers */
+static inline int dsi_vc_generic_read_0(struct dsi_pipe *dsi_pipe,
+					int channel, u8 *buf, int buflen)
+{
+	return dsi_vc_generic_read(dsi_pipe, channel, NULL, 0, buf, buflen);
+}
+
+static inline int dsi_vc_generic_read_1(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param, u8 *buf,
+					int buflen)
+{
+	return dsi_vc_generic_read(dsi_pipe, channel, &param, 1, buf, buflen);
+}
+
+static inline int dsi_vc_generic_read_2(struct dsi_pipe *dsi_pipe,
+					int channel, u8 param1, u8 param2,
+					u8 *buf, int buflen)
+{
+	u8 req[2] = { param1, param2 };
+
+	return dsi_vc_generic_read(dsi_pipe, channel, req, 2, buf, buflen);
+}
+
+
+#endif /* _INTEL_DSI_DSI_H */
diff --git a/drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c b/drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c
new file mode 100644
index 0000000..d8ac897
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/intel_dsi_pll.c
@@ -0,0 +1,217 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *	Shobhit Kumar <shobhit.kumar@intel.com>
+ *	Yogesh Mohan Marimuthu <yogesh.mohan.marimuthu@intel.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <drm/drmP.h>
+#include <drm/i915_drm.h>
+#include <drm/i915_adf_wrapper.h>
+#include <intel_adf_device.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/common/dsi/dsi_config.h>
+#include <core/vlv/vlv_dc_regs.h>
+#include "intel_dsi.h"
+
+#define DSI_HSS_PACKET_SIZE		4
+#define DSI_HSE_PACKET_SIZE		4
+#define DSI_HSA_PACKET_EXTRA_SIZE	6
+#define DSI_HBP_PACKET_EXTRA_SIZE	6
+#define DSI_HACTIVE_PACKET_EXTRA_SIZE	6
+#define DSI_HFP_PACKET_EXTRA_SIZE	6
+#define DSI_EOTP_PACKET_SIZE		4
+
+struct dsi_mnp {
+	u32 dsi_pll_ctrl;
+	u32 dsi_pll_div;
+};
+
+static const u32 lfsr_converts[] = {
+	426, 469, 234, 373, 442, 221, 110, 311, 411,		/* 62 - 70 */
+	461, 486, 243, 377, 188, 350, 175, 343, 427, 213,	/* 71 - 80 */
+	106, 53, 282, 397, 354, 227, 113, 56, 284, 142,		/* 81 - 90 */
+	71, 35							/* 91 - 92 */
+};
+
+static u32 vlv_cck_read(u32 reg)
+{
+	u32 val;
+	intel_dpio_sideband_rw(INTEL_SIDEBAND_REG_READ, IOSF_PORT_CCK,
+			       reg, &val);
+	return val;
+}
+
+static void vlv_cck_write(u32 reg, u32 val)
+{
+	intel_dpio_sideband_rw(INTEL_SIDEBAND_REG_WRITE, IOSF_PORT_CCK,
+			       reg, &val);
+}
+
+/* Get DSI clock from pixel clock */
+static u32 dsi_clk_from_pclk(u32 pclk, int pixel_format, int lane_count)
+{
+	u32 dsi_clk_khz;
+	u32 bpp;
+
+	switch (pixel_format) {
+	default:
+	case VID_MODE_FORMAT_RGB888:
+	case VID_MODE_FORMAT_RGB666_LOOSE:
+		bpp = 24;
+		break;
+	case VID_MODE_FORMAT_RGB666:
+		bpp = 18;
+		break;
+	case VID_MODE_FORMAT_RGB565:
+		bpp = 16;
+		break;
+	}
+
+	/* DSI data rate = pixel clock * bits per pixel / lane count
+	   pixel clock is converted from KHz to Hz */
+	dsi_clk_khz = DIV_ROUND_CLOSEST(pclk * bpp, lane_count);
+
+	return dsi_clk_khz;
+}
+
+static int dsi_calc_mnp(u32 dsi_clk, struct dsi_mnp *dsi_mnp)
+{
+	u32 m, n, p;
+	u32 ref_clk;
+	u32 error;
+	u32 tmp_error;
+	int target_dsi_clk;
+	int calc_dsi_clk;
+	u32 calc_m;
+	u32 calc_p;
+	u32 m_seed;
+
+	/* dsi_clk is expected in KHZ */
+	if (dsi_clk < 300000 || dsi_clk > 1150000) {
+		pr_err("DSI CLK Out of Range\n");
+		return -ECHRNG;
+	}
+
+	ref_clk = 25000;
+	target_dsi_clk = dsi_clk;
+	error = 0xFFFFFFFF;
+	tmp_error = 0xFFFFFFFF;
+	calc_m = 0;
+	calc_p = 0;
+
+	for (m = 62; m <= 92; m++) {
+		for (p = 2; p <= 6; p++) {
+			/* Find the optimal m and p divisors
+			   with minimal error +/- the required clock */
+			calc_dsi_clk = (m * ref_clk) / p;
+			if (calc_dsi_clk == target_dsi_clk) {
+				calc_m = m;
+				calc_p = p;
+				error = 0;
+				break;
+			} else
+				tmp_error = abs(target_dsi_clk - calc_dsi_clk);
+
+			if (tmp_error < error) {
+				error = tmp_error;
+				calc_m = m;
+				calc_p = p;
+			}
+		}
+
+		if (error == 0)
+			break;
+	}
+
+	m_seed = lfsr_converts[calc_m - 62];
+	n = 1;
+	dsi_mnp->dsi_pll_ctrl = 1 << (DSI_PLL_P1_POST_DIV_SHIFT + calc_p - 2);
+	dsi_mnp->dsi_pll_div = (n - 1) << DSI_PLL_N1_DIV_SHIFT |
+		m_seed << DSI_PLL_M1_DIV_SHIFT;
+
+	return 0;
+}
+
+/*
+ * XXX: The muxing and gating is hard coded for now. Need to add support for
+ * sharing PLLs with two DSI outputs.
+ */
+static void vlv_configure_dsi_pll(struct dsi_config *config)
+{
+	struct dsi_context *intel_dsi = &config->ctx;
+	int ret;
+	struct dsi_mnp dsi_mnp;
+	u32 dsi_clk;
+
+	dsi_clk = dsi_clk_from_pclk(intel_dsi->pclk, intel_dsi->pixel_format,
+				    intel_dsi->lane_count);
+
+	ret = dsi_calc_mnp(dsi_clk, &dsi_mnp);
+	if (ret) {
+		pr_info("dsi_calc_mnp failed\n");
+		return;
+	}
+
+	dsi_mnp.dsi_pll_ctrl |= DSI_PLL_CLK_GATE_DSI0_DSIPLL;
+
+	pr_info("dsi pll div %08x, ctrl %08x\n",
+		      dsi_mnp.dsi_pll_div, dsi_mnp.dsi_pll_ctrl);
+
+	vlv_cck_write(CCK_REG_DSI_PLL_CONTROL, 0);
+	vlv_cck_write(CCK_REG_DSI_PLL_DIVIDER, dsi_mnp.dsi_pll_div);
+	vlv_cck_write(CCK_REG_DSI_PLL_CONTROL, dsi_mnp.dsi_pll_ctrl);
+}
+
+void vlv_enable_dsi_pll(struct dsi_config *config)
+{
+	u32 tmp;
+	int pipe = config->pipe;
+
+	vlv_configure_dsi_pll(config);
+
+	/* wait at least 0.5 us after ungating before enabling VCO */
+	usleep_range(1, 10);
+
+	tmp = vlv_cck_read(CCK_REG_DSI_PLL_CONTROL);
+	tmp |= DSI_PLL_VCO_EN;
+	vlv_cck_write(CCK_REG_DSI_PLL_CONTROL, tmp);
+
+	if (wait_for(REG_READ(PIPECONF(pipe)) & PIPECONF_DSI_PLL_LOCKED, 20)) {
+		pr_err("DSI PLL lock failed\n");
+		return;
+	}
+
+	pr_info("DSI PLL locked\n");
+}
+
+void vlv_disable_dsi_pll(struct dsi_config *config)
+{
+	u32 tmp;
+	tmp = vlv_cck_read(CCK_REG_DSI_PLL_CONTROL);
+	tmp &= ~DSI_PLL_VCO_EN;
+	tmp |= DSI_PLL_LDO_GATE;
+	vlv_cck_write(CCK_REG_DSI_PLL_CONTROL, tmp);
+}
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/Makefile b/drivers/video/adf/intel/core/common/dsi/panels/Makefile
new file mode 100644
index 0000000..bc499da
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/Makefile
@@ -0,0 +1,16 @@
+# Makefile for Intel display driver based on ADF framework
+
+ccflags-y := -Idrivers/staging/android -Iinclude/adf -Iinclude/uapi/adf -Idrivers/video/adf/intel/include -Idrivers/video/adf/intel/core/common/dsi -Werror
+
+CFLAGS_adf.o := -I$(src)
+
+ifdef CONFIG_ADF_INTEL_VLV
+	obj-y := intel_dsi_panel_vbt.o
+else
+	obj-y := cmi_7x12_cmd.o
+	obj-y += jdi_7x12_cmd.o
+      	obj-y += jdi_7x12_vid.o
+	obj-y += sharp_10x19_cmd.o
+	obj-y += sharp_25x16_cmd.o
+	obj-y += sharp_25x16_vid.o
+endif
diff --git a/drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c b/drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c
new file mode 100644
index 0000000..c4a1749
--- /dev/null
+++ b/drivers/video/adf/intel/core/common/dsi/panels/intel_dsi_panel_vbt.c
@@ -0,0 +1,732 @@
+/*
+ * Copyright © 2014 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Shobhit Kumar <shobhit.kumar@intel.com>
+ *
+ */
+
+#include <linux/slab.h>
+#include <video/mipi_display.h>
+#include <asm/intel-mid.h>
+#include <drm/i915_drm.h>
+#include <drm/i915_adf_wrapper.h>
+#include <core/common/dsi/dsi_config.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/common/dsi/dsi_panel.h>
+#include <core/vlv/vlv_dc_regs.h>
+#include "intel_dsi.h"
+#include "intel_dsi_cmd.h"
+#include "dsi_vbt.h"
+
+#define MIPI_TRANSFER_MODE_SHIFT	0
+#define MIPI_VIRTUAL_CHANNEL_SHIFT	1
+#define MIPI_PORT_SHIFT			3
+
+#define PREPARE_CNT_MAX		0x3F
+#define EXIT_ZERO_CNT_MAX	0x3F
+#define CLK_ZERO_CNT_MAX	0xFF
+#define TRAIL_CNT_MAX		0x1F
+
+#define NS_KHZ_RATIO 1000000
+
+#define GPI0_NC_0_HV_DDI0_HPD           0x4130
+#define GPIO_NC_0_HV_DDI0_PAD           0x4138
+#define GPIO_NC_1_HV_DDI0_DDC_SDA       0x4120
+#define GPIO_NC_1_HV_DDI0_DDC_SDA_PAD   0x4128
+#define GPIO_NC_2_HV_DDI0_DDC_SCL       0x4110
+#define GPIO_NC_2_HV_DDI0_DDC_SCL_PAD   0x4118
+#define GPIO_NC_3_PANEL0_VDDEN          0x4140
+#define GPIO_NC_3_PANEL0_VDDEN_PAD      0x4148
+#define GPIO_NC_4_PANEL0_BLKEN          0x4150
+#define GPIO_NC_4_PANEL0_BLKEN_PAD      0x4158
+#define GPIO_NC_5_PANEL0_BLKCTL         0x4160
+#define GPIO_NC_5_PANEL0_BLKCTL_PAD     0x4168
+#define GPIO_NC_6_PCONF0                0x4180
+#define GPIO_NC_6_PAD                   0x4188
+#define GPIO_NC_7_PCONF0                0x4190
+#define GPIO_NC_7_PAD                   0x4198
+#define GPIO_NC_8_PCONF0                0x4170
+#define GPIO_NC_8_PAD                   0x4178
+#define GPIO_NC_9_PCONF0                0x4100
+#define GPIO_NC_9_PAD                   0x4108
+#define GPIO_NC_10_PCONF0               0x40E0
+#define GPIO_NC_10_PAD                  0x40E8
+#define GPIO_NC_11_PCONF0               0x40F0
+#define GPIO_NC_11_PAD                  0x40F8
+
+static void vlv_gpio_nc_write(u32 reg, u32 val)
+{
+	intel_dpio_sideband_rw(INTEL_SIDEBAND_REG_WRITE, IOSF_PORT_GPIO_NC,
+			       reg, &val);
+}
+
+struct gpio_table {
+	u16 function_reg;
+	u16 pad_reg;
+	u8 init;
+};
+
+static struct gpio_table gtable[] = {
+	{ GPI0_NC_0_HV_DDI0_HPD, GPIO_NC_0_HV_DDI0_PAD, 0 },
+	{ GPIO_NC_1_HV_DDI0_DDC_SDA, GPIO_NC_1_HV_DDI0_DDC_SDA_PAD, 0 },
+	{ GPIO_NC_2_HV_DDI0_DDC_SCL, GPIO_NC_2_HV_DDI0_DDC_SCL_PAD, 0 },
+	{ GPIO_NC_3_PANEL0_VDDEN, GPIO_NC_3_PANEL0_VDDEN_PAD, 0 },
+	{ GPIO_NC_4_PANEL0_BLKEN, GPIO_NC_4_PANEL0_BLKEN_PAD, 0 },
+	{ GPIO_NC_5_PANEL0_BLKCTL, GPIO_NC_5_PANEL0_BLKCTL_PAD, 0 },
+	{ GPIO_NC_6_PCONF0, GPIO_NC_6_PAD, 0 },
+	{ GPIO_NC_7_PCONF0, GPIO_NC_7_PAD, 0 },
+	{ GPIO_NC_8_PCONF0, GPIO_NC_8_PAD, 0 },
+	{ GPIO_NC_9_PCONF0, GPIO_NC_9_PAD, 0 },
+	{ GPIO_NC_10_PCONF0, GPIO_NC_10_PAD, 0},
+	{ GPIO_NC_11_PCONF0, GPIO_NC_11_PAD, 0}
+};
+
+static u8 *mipi_exec_send_packet(struct dsi_pipe *dsi_pipe, u8 *data)
+{
+	struct dsi_context *intel_dsi = &dsi_pipe->config.ctx;
+	u8 type, byte, mode, vc, port;
+	u16 len;
+
+	byte = *data++;
+	mode = (byte >> MIPI_TRANSFER_MODE_SHIFT) & 0x1;
+	vc = (byte >> MIPI_VIRTUAL_CHANNEL_SHIFT) & 0x3;
+	port = (byte >> MIPI_PORT_SHIFT) & 0x3;
+
+	/* LP or HS mode */
+	intel_dsi->hs = mode;
+
+	/* get packet type and increment the pointer */
+	type = *data++;
+
+	len = *((u16 *) data);
+	data += 2;
+
+	switch (type) {
+	case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+		dsi_vc_generic_write_0(dsi_pipe, vc);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+		dsi_vc_generic_write_1(dsi_pipe, vc, *data);
+		break;
+	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+		dsi_vc_generic_write_2(dsi_pipe, vc, *data, *(data + 1));
+		break;
+	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
+	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
+	case MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:
+		pr_debug("Generic Read not yet implemented or used\n");
+		break;
+	case MIPI_DSI_GENERIC_LONG_WRITE:
+		dsi_vc_generic_write(dsi_pipe, vc, data, len);
+		break;
+	case MIPI_DSI_DCS_SHORT_WRITE:
+		dsi_vc_dcs_write_0(dsi_pipe, vc, *data);
+		break;
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+		dsi_vc_dcs_write_1(dsi_pipe, vc, *data, *(data + 1));
+		break;
+	case MIPI_DSI_DCS_READ:
+		pr_debug("DCS Read not yet implemented or used\n");
+		break;
+	case MIPI_DSI_DCS_LONG_WRITE:
+		dsi_vc_dcs_write(dsi_pipe, vc, data, len);
+		break;
+	}
+
+	data += len;
+
+	return data;
+}
+
+static u8 *mipi_exec_delay(struct dsi_pipe *dsi_pipe, u8 *data)
+{
+	u32 delay = *((u32 *) data);
+
+	usleep_range(delay, delay + 10);
+	data += 4;
+
+	return data;
+}
+
+static u8 *mipi_exec_gpio(struct dsi_pipe *dsi_pipe, u8 *data)
+{
+	u8 gpio, action;
+	u16 function, pad;
+	u32 val;
+
+	gpio = *data++;
+
+	/* pull up/down */
+	action = *data++;
+
+	function = gtable[gpio].function_reg;
+	pad = gtable[gpio].pad_reg;
+
+	if (!gtable[gpio].init) {
+		/* program the function */
+		/* FIXME: remove constant below */
+		vlv_gpio_nc_write(function, 0x2000CC00);
+		gtable[gpio].init = 1;
+	}
+
+	val = 0x4 | action;
+
+	/* pull up/down */
+	vlv_gpio_nc_write(pad, val);
+
+	return data;
+}
+
+typedef u8 * (*fn_mipi_elem_exec)(struct dsi_pipe *dsi_pipe, u8 *data);
+static const fn_mipi_elem_exec exec_elem[] = {
+	NULL, /* reserved */
+	mipi_exec_send_packet,
+	mipi_exec_delay,
+	mipi_exec_gpio,
+	NULL, /* status read; later */
+};
+
+/*
+ * MIPI Sequence from VBT #53 parsing logic
+ * We have already separated each seqence during bios parsing
+ * Following is generic execution function for any sequence
+ */
+
+static const char * const seq_name[] = {
+	"UNDEFINED",
+	"MIPI_SEQ_ASSERT_RESET",
+	"MIPI_SEQ_INIT_OTP",
+	"MIPI_SEQ_DISPLAY_ON",
+	"MIPI_SEQ_DISPLAY_OFF",
+	"MIPI_SEQ_DEASSERT_RESET"
+};
+
+static void generic_exec_sequence(struct dsi_pipe *dsi_pipe, char *sequence)
+{
+	u8 *data = sequence;
+	fn_mipi_elem_exec mipi_elem_exec;
+	int index;
+
+	if (!sequence)
+		return;
+
+	pr_debug("Starting MIPI sequence - %s\n", seq_name[*data]);
+
+	/* go to the first element of the sequence */
+	data++;
+
+	/* parse each byte till we reach end of sequence byte - 0x00 */
+	while (1) {
+		index = *data;
+		mipi_elem_exec = exec_elem[index];
+		if (!mipi_elem_exec) {
+			pr_err("Unsupported MIPI element, skipping sequence execution\n");
+			return;
+		}
+
+		/* goto element payload */
+		data++;
+
+		/* execute the element specific rotines */
+		data = mipi_elem_exec(dsi_pipe, data);
+
+		/*
+		 * After processing the element, data should point to
+		 * next element or end of sequence
+		 * check if have we reached end of sequence
+		 */
+		if (*data == 0x00)
+			break;
+	}
+}
+
+static int generic_init(struct dsi_pipe *pipe)
+{
+	struct dsi_config *dsi_config = &pipe->config;
+	struct dsi_context *intel_dsi = &dsi_config->ctx;
+	struct dsi_vbt *dsi_vbt = NULL;
+	struct mipi_config *mipi_config;
+	struct drm_display_mode *mode = NULL;
+	struct mipi_pps_data *pps;
+
+	u32 bits_per_pixel = 24;
+	u32 tlpx_ns, extra_byte_count, bitrate, tlpx_ui;
+	u32 ui_num, ui_den;
+	u32 prepare_cnt, exit_zero_cnt, clk_zero_cnt, trail_cnt;
+	u32 ths_prepare_ns, tclk_trail_ns;
+	u32 tclk_prepare_clkzero, ths_prepare_hszero;
+	u32 lp_to_hs_switch, hs_to_lp_switch;
+	u32 pclk, computed_ddr;
+	u16 burst_mode_ratio;
+
+	pr_debug("ADF: %s\n", __func__);
+
+	/* get the VBT parsed MIPI data and support mode from i915 wrapper */
+	intel_get_dsi_vbt_data((void **)&dsi_vbt, &mode);
+	if (!dsi_vbt || !mode) {
+		pr_err("ADF: %s: No VBT data from i915\n", __func__);
+		return -1;
+	}
+
+	dsi_config->dsi = dsi_vbt;
+	memcpy(&dsi_config->vbt_mode, mode, sizeof(struct drm_display_mode));
+	mipi_config = dsi_config->dsi->config;
+	pps = dsi_config->dsi->pps;
+
+	intel_dsi->eotp_pkt = mipi_config->eot_pkt_disabled ? 0 : 1;
+	intel_dsi->clock_stop = mipi_config->enable_clk_stop ? 1 : 0;
+	intel_dsi->lane_count = mipi_config->lane_cnt + 1;
+	intel_dsi->pixel_format = mipi_config->videomode_color_format << 7;
+
+	if (intel_dsi->pixel_format == VID_MODE_FORMAT_RGB666)
+		bits_per_pixel = 18;
+	else if (intel_dsi->pixel_format == VID_MODE_FORMAT_RGB565)
+		bits_per_pixel = 16;
+
+	intel_dsi->operation_mode = mipi_config->is_cmd_mode;
+	intel_dsi->video_mode_format = mipi_config->video_transfer_mode;
+	intel_dsi->escape_clk_div = mipi_config->byte_clk_sel;
+	intel_dsi->lp_rx_timeout = mipi_config->lp_rx_timeout;
+	intel_dsi->turn_arnd_val = mipi_config->turn_around_timeout;
+	intel_dsi->rst_timer_val = mipi_config->device_reset_timer;
+	intel_dsi->init_count = mipi_config->master_init_timer;
+	intel_dsi->bw_timer = mipi_config->dbi_bw_timer;
+	intel_dsi->video_frmt_cfg_bits =
+		mipi_config->bta_enabled ? DISABLE_VIDEO_BTA : 0;
+	intel_dsi->dual_link = mipi_config->dual_link;
+
+	pclk = mode->clock;
+
+	/* Burst Mode Ratio
+	 * Target ddr frequency from VBT / non burst ddr freq
+	 * multiply by 100 to preserve remainder
+	 */
+	if (intel_dsi->video_mode_format == VIDEO_MODE_BURST) {
+		if (mipi_config->target_burst_mode_freq) {
+			computed_ddr =
+				(pclk * bits_per_pixel) / intel_dsi->lane_count;
+
+			if (mipi_config->target_burst_mode_freq <
+								computed_ddr) {
+				pr_err("Burst mode freq is less than computed\n");
+				return -1;
+			}
+
+			burst_mode_ratio = DIV_ROUND_UP(
+				mipi_config->target_burst_mode_freq * 100,
+				computed_ddr);
+
+			pclk = DIV_ROUND_UP(pclk * burst_mode_ratio, 100);
+		} else {
+			pr_err("Burst mode target is not set\n");
+			return -1;
+		}
+	} else
+		burst_mode_ratio = 100;
+
+	intel_dsi->burst_mode_ratio = burst_mode_ratio;
+	intel_dsi->pclk = pclk;
+
+	bitrate = (pclk * bits_per_pixel) / intel_dsi->lane_count;
+
+	switch (intel_dsi->escape_clk_div) {
+	case 0:
+		tlpx_ns = 50;
+		break;
+	case 1:
+		tlpx_ns = 100;
+		break;
+
+	case 2:
+		tlpx_ns = 200;
+		break;
+	default:
+		tlpx_ns = 50;
+		break;
+	}
+
+	switch (intel_dsi->lane_count) {
+	case 1:
+	case 2:
+		extra_byte_count = 2;
+		break;
+	case 3:
+		extra_byte_count = 4;
+		break;
+	case 4:
+	default:
+		extra_byte_count = 3;
+		break;
+	}
+
+	/*
+	 * ui(s) = 1/f [f in hz]
+	 * ui(ns) = 10^9 / (f*10^6) [f in Mhz] -> 10^3/f(Mhz)
+	 */
+
+	/* in Kbps */
+	ui_num = NS_KHZ_RATIO;
+	ui_den = bitrate;
+
+	tclk_prepare_clkzero = mipi_config->tclk_prepare_clkzero;
+	ths_prepare_hszero = mipi_config->ths_prepare_hszero;
+
+	/*
+	 * B060
+	 * LP byte clock = TLPX/ (8UI)
+	 */
+	intel_dsi->lp_byte_clk = DIV_ROUND_UP(tlpx_ns * ui_den, 8 * ui_num);
+
+	/* count values in UI = (ns value) * (bitrate / (2 * 10^6))
+	 *
+	 * Since txddrclkhs_i is 2xUI, all the count values programmed in
+	 * DPHY param register are divided by 2
+	 *
+	 * prepare count
+	 */
+	ths_prepare_ns = max(mipi_config->ths_prepare,
+			     mipi_config->tclk_prepare);
+	prepare_cnt = DIV_ROUND_UP(ths_prepare_ns * ui_den, ui_num * 2);
+
+	/* exit zero count */
+	exit_zero_cnt = DIV_ROUND_UP(
+				(ths_prepare_hszero - ths_prepare_ns) * ui_den,
+				ui_num * 2
+				);
+
+	/*
+	 * Exit zero  is unified val ths_zero and ths_exit
+	 * minimum value for ths_exit = 110ns
+	 * min (exit_zero_cnt * 2) = 110/UI
+	 * exit_zero_cnt = 55/UI
+	 */
+	 if (exit_zero_cnt < (55 * ui_den / ui_num))
+		if ((55 * ui_den) % ui_num)
+			exit_zero_cnt += 1;
+
+	/* clk zero count */
+	clk_zero_cnt = DIV_ROUND_UP(
+			(tclk_prepare_clkzero -	ths_prepare_ns)
+			* ui_den, 2 * ui_num);
+
+	/* trail count */
+	tclk_trail_ns = max(mipi_config->tclk_trail, mipi_config->ths_trail);
+	trail_cnt = DIV_ROUND_UP(tclk_trail_ns * ui_den, 2 * ui_num);
+
+	if (prepare_cnt > PREPARE_CNT_MAX ||
+		exit_zero_cnt > EXIT_ZERO_CNT_MAX ||
+		clk_zero_cnt > CLK_ZERO_CNT_MAX ||
+		trail_cnt > TRAIL_CNT_MAX)
+		pr_debug("Values crossing maximum limits, restricting to max values\n");
+
+	if (prepare_cnt > PREPARE_CNT_MAX)
+		prepare_cnt = PREPARE_CNT_MAX;
+
+	if (exit_zero_cnt > EXIT_ZERO_CNT_MAX)
+		exit_zero_cnt = EXIT_ZERO_CNT_MAX;
+
+	if (clk_zero_cnt > CLK_ZERO_CNT_MAX)
+		clk_zero_cnt = CLK_ZERO_CNT_MAX;
+
+	if (trail_cnt > TRAIL_CNT_MAX)
+		trail_cnt = TRAIL_CNT_MAX;
+
+	/* B080 */
+	intel_dsi->dphy_reg = exit_zero_cnt << 24 | trail_cnt << 16 |
+						clk_zero_cnt << 8 | prepare_cnt;
+
+	/*
+	 * LP to HS switch count = 4TLPX + PREP_COUNT * 2 + EXIT_ZERO_COUNT * 2
+	 *					+ 10UI + Extra Byte Count
+	 *
+	 * HS to LP switch count = THS-TRAIL + 2TLPX + Extra Byte Count
+	 * Extra Byte Count is calculated according to number of lanes.
+	 * High Low Switch Count is the Max of LP to HS and
+	 * HS to LP switch count
+	 *
+	 */
+	tlpx_ui = DIV_ROUND_UP(tlpx_ns * ui_den, ui_num);
+
+	/* B044 */
+	/* FIXME:
+	 * The comment above does not match with the code */
+	lp_to_hs_switch = DIV_ROUND_UP(4 * tlpx_ui + prepare_cnt * 2 +
+						exit_zero_cnt * 2 + 10, 8);
+
+	hs_to_lp_switch = DIV_ROUND_UP(mipi_config->ths_trail + 2 * tlpx_ui, 8);
+
+	intel_dsi->hs_to_lp_count = max(lp_to_hs_switch, hs_to_lp_switch);
+	intel_dsi->hs_to_lp_count += extra_byte_count;
+
+	/* B088 */
+	/* LP -> HS for clock lanes
+	 * LP clk sync + LP11 + LP01 + tclk_prepare + tclk_zero +
+	 *						extra byte count
+	 * 2TPLX + 1TLPX + 1 TPLX(in ns) + prepare_cnt * 2 + clk_zero_cnt *
+	 *					2(in UI) + extra byte count
+	 * In byteclks = (4TLPX + prepare_cnt * 2 + clk_zero_cnt *2 (in UI)) /
+	 *					8 + extra byte count
+	 */
+	intel_dsi->clk_lp_to_hs_count =
+		DIV_ROUND_UP(
+			4 * tlpx_ui + prepare_cnt * 2 +
+			clk_zero_cnt * 2,
+			8);
+
+	intel_dsi->clk_lp_to_hs_count += extra_byte_count;
+
+	/* HS->LP for Clock Lanes
+	 * Low Power clock synchronisations + 1Tx byteclk + tclk_trail +
+	 *						Extra byte count
+	 * 2TLPX + 8UI + (trail_count*2)(in UI) + Extra byte count
+	 * In byteclks = (2*TLpx(in UI) + trail_count*2 +8)(in UI)/8 +
+	 *						Extra byte count
+	 */
+	intel_dsi->clk_hs_to_lp_count =
+		DIV_ROUND_UP(2 * tlpx_ui + trail_cnt * 2 + 8,
+			8);
+	intel_dsi->clk_hs_to_lp_count += extra_byte_count;
+
+	pr_info("ADF: %s: Eot %s\n", __func__,
+		intel_dsi->eotp_pkt ? "enabled" : "disabled");
+	pr_info("ADF: %s: Clockstop %s\n", __func__, intel_dsi->clock_stop ?
+						"disabled" : "enabled");
+	pr_info("ADF: %s: Mode %s\n", __func__,
+		intel_dsi->operation_mode ? "command" : "video");
+	pr_info("ADF: %s: Pixel Format %d\n", __func__,
+		intel_dsi->pixel_format);
+	pr_info("ADF: %s: TLPX %d\n", __func__, intel_dsi->escape_clk_div);
+	pr_info("ADF: %s: LP RX Timeout 0x%x\n",
+		__func__, intel_dsi->lp_rx_timeout);
+	pr_info("ADF: %s: Turnaround Timeout 0x%x\n",
+		__func__, intel_dsi->turn_arnd_val);
+	pr_info("ADF: %s: Init Count 0x%x\n", __func__, intel_dsi->init_count);
+	pr_info("ADF: %s: HS to LP Count 0x%x\n",
+		__func__, intel_dsi->hs_to_lp_count);
+	pr_info("ADF: %s: LP Byte Clock %d\n",
+		__func__, intel_dsi->lp_byte_clk);
+	pr_info("ADF: %s: DBI BW Timer 0x%x\n", __func__, intel_dsi->bw_timer);
+	pr_info("ADF: %s: LP to HS Clock Count 0x%x\n",
+		__func__, intel_dsi->clk_lp_to_hs_count);
+	pr_info("ADF: %s: HS to LP Clock Count 0x%x\n",
+		__func__, intel_dsi->clk_hs_to_lp_count);
+	pr_info("ADF: %s: BTA %s\n", __func__,
+			intel_dsi->video_frmt_cfg_bits & DISABLE_VIDEO_BTA ?
+			"disabled" : "enabled");
+
+	/* delays in VBT are in unit of 100us, so need to convert
+	 * here in ms
+	 * Delay (100us) * 100 /1000 = Delay / 10 (ms) */
+	intel_dsi->backlight_off_delay = pps->bl_disable_delay / 10;
+	intel_dsi->backlight_on_delay = pps->bl_enable_delay / 10;
+	intel_dsi->panel_on_delay = pps->panel_on_delay / 10;
+	intel_dsi->panel_off_delay = pps->panel_off_delay / 10;
+	intel_dsi->panel_pwr_cycle_delay = pps->panel_power_cycle_delay / 10;
+
+	return 0;
+}
+
+#if 0
+static int generic_mode_valid(struct intel_dsi_device *dsi,
+		   struct drm_display_mode *mode)
+{
+	return MODE_OK;
+}
+
+static bool generic_mode_fixup(struct intel_dsi_device *dsi,
+		    const struct drm_display_mode *mode,
+		    struct drm_display_mode *adjusted_mode) {
+	return true;
+}
+#endif
+
+static int generic_panel_reset(struct dsi_pipe *interface)
+{
+	struct dsi_vbt *dsi = interface->config.dsi;
+	char *sequence = dsi->sequence[MIPI_SEQ_ASSERT_RESET];
+	pr_debug("ADF: %s\n", __func__);
+
+	generic_exec_sequence(interface, sequence);
+
+	return 0;
+}
+
+static int generic_disable_panel_power(struct dsi_pipe *interface)
+{
+	struct dsi_vbt *dsi = interface->config.dsi;
+	char *sequence = dsi->sequence[MIPI_SEQ_DEASSERT_RESET];
+	pr_debug("ADF: %s\n", __func__);
+
+	generic_exec_sequence(interface, sequence);
+	return 0;
+}
+
+static int generic_send_otp_cmds(struct dsi_pipe *interface)
+{
+	struct dsi_vbt *dsi = interface->config.dsi;
+	char *sequence = dsi->sequence[MIPI_SEQ_INIT_OTP];
+	pr_debug("ADF: %s\n", __func__);
+
+	generic_exec_sequence(interface, sequence);
+
+	return 0;
+}
+
+static int generic_enable(struct dsi_pipe *interface)
+{
+	struct dsi_vbt *dsi = interface->config.dsi;
+	char *sequence = dsi->sequence[MIPI_SEQ_DISPLAY_ON];
+	pr_debug("ADF: %s\n", __func__);
+
+	generic_exec_sequence(interface, sequence);
+
+	return 0;
+}
+
+static int generic_disable(struct dsi_pipe *interface)
+{
+	struct dsi_vbt *dsi = interface->config.dsi;
+	char *sequence = dsi->sequence[MIPI_SEQ_DISPLAY_OFF];
+	pr_debug("ADF: %s\n", __func__);
+
+	generic_exec_sequence(interface, sequence);
+
+	return 0;
+}
+
+static int generic_detect(struct dsi_pipe *interface)
+{
+	pr_debug("ADF: %s\n", __func__);
+	return 1;
+}
+
+#if 0
+static bool generic_get_hw_state(struct intel_dsi_device *dev)
+{
+	return true;
+}
+#endif
+
+static int generic_get_modes(struct dsi_config *config,
+			     struct drm_mode_modeinfo *modeinfo)
+{
+	struct drm_display_mode *mode = &config->vbt_mode;
+
+	pr_err("ADF: %s\n", __func__);
+
+	modeinfo->clock = mode->clock;
+	modeinfo->hdisplay = (u16) mode->hdisplay;
+	modeinfo->hsync_start = (u16) mode->hsync_start;
+	modeinfo->hsync_end = (u16) mode->hsync_end;
+	modeinfo->htotal = (u16) mode->htotal;
+	modeinfo->vdisplay = (u16) mode->vdisplay;
+	modeinfo->vsync_start = (u16) mode->vsync_start;
+	modeinfo->vsync_end = (u16) mode->vsync_end;
+	modeinfo->vtotal = (u16) mode->vtotal;
+	modeinfo->hskew = (u16) mode->hskew;
+	modeinfo->vscan = (u16) mode->vscan;
+	modeinfo->vrefresh = (u32) mode->vrefresh;
+	modeinfo->flags = mode->flags;
+	modeinfo->type |= mode->type | DRM_MODE_TYPE_PREFERRED;
+	strncpy(modeinfo->name, mode->name, DRM_DISPLAY_MODE_LEN);
+
+	return 0;
+}
+
+#if 0
+static void generic_destroy(struct intel_dsi_device *dsi) { }
+#endif
+
+int generic_get_panel_info(struct dsi_config *config, struct panel_info *info)
+{
+	struct drm_display_mode *mode = &config->vbt_mode;
+	struct dsi_context *ctx = &config->ctx;
+	int bpp = 24;
+
+	pr_err("ADF: %s\n", __func__);
+
+	info->width_mm = mode->width_mm;
+	info->height_mm = mode->height_mm;
+	info->dsi_type = ctx->operation_mode;
+	info->lane_num = ctx->lane_count;
+	info->dual_link = ctx->dual_link;
+
+	if (ctx->pixel_format == VID_MODE_FORMAT_RGB666)
+		bpp = 18;
+	else if (ctx->pixel_format == VID_MODE_FORMAT_RGB565)
+		bpp = 16;
+
+	info->bpp = bpp;
+
+	return 0;
+}
+
+static int generic_exit_standby(struct dsi_pipe *interface)
+{
+	pr_debug("ADF: %s\n", __func__);
+	return 0;
+}
+
+static int generic_set_brightness(struct dsi_pipe *interface, int level)
+{
+	pr_debug("ADF: %s\n", __func__);
+	return 0;
+}
+
+static int generic_set_mode(struct dsi_pipe *interface)
+{
+	pr_debug("ADF: %s\n", __func__);
+	return 0;
+}
+
+struct panel_ops generic_ops = {
+		.get_config_mode = generic_get_modes,
+		.dsi_controller_init = generic_init,
+		.get_panel_info = generic_get_panel_info,
+		.reset = generic_panel_reset,
+		.exit_deep_standby = generic_exit_standby,
+		.detect = generic_detect,
+		.power_on = generic_enable,
+		.power_off = generic_disable,
+		.set_brightness = generic_set_brightness,
+		.drv_ic_init = generic_send_otp_cmds,
+		.drv_set_panel_mode = generic_set_mode,
+		.disable_panel_power = generic_disable_panel_power,
+/*
+ * Might need to add these hooks in panel_ops
+		.mode_valid = generic_mode_valid,
+		.mode_fixup = generic_mode_fixup,
+		.get_hw_state = generic_get_hw_state,
+		.destroy = generic_destroy,
+*/
+};
+
+struct dsi_panel generic_panel = {
+	.panel_id = MIPI_DSI_GENERIC_PANEL_ID,
+	.ops = &generic_ops,
+};
+
+const struct dsi_panel *get_generic_panel(void)
+{
+	pr_debug("ADF: %s\n", __func__);
+	return &generic_panel;
+}
diff --git a/drivers/video/adf/intel/core/intel_adf_drv.c b/drivers/video/adf/intel/core/intel_adf_drv.c
index 44ee4fe..e839845 100644
--- a/drivers/video/adf/intel/core/intel_adf_drv.c
+++ b/drivers/video/adf/intel/core/intel_adf_drv.c
@@ -30,6 +30,7 @@ struct intel_adf_context *adf_ctx;
 static int intel_adf_init(void)
 {
 	struct pci_dev *i915_pci_dev;
+	pr_err("ADF: %s\n", __func__);
 
 	i915_pci_dev = i915_adf_get_pci_dev();
 	adf_ctx = intel_adf_context_create(i915_pci_dev);
@@ -37,6 +38,8 @@ static int intel_adf_init(void)
 		pr_err("%s:failed to create ADF context\n", __func__);
 		return -EINVAL;
 	}
+
+	pr_err("ADF: %s\n", __func__);
 	return 0;
 }
 
diff --git a/drivers/video/adf/intel/core/intel_dc_config.c b/drivers/video/adf/intel/core/intel_dc_config.c
index e8ffd5f..e7d7ba8 100644
--- a/drivers/video/adf/intel/core/intel_dc_config.c
+++ b/drivers/video/adf/intel/core/intel_dc_config.c
@@ -262,7 +262,7 @@ struct intel_dc_config *intel_adf_get_dc_config(struct pci_dev *pdev, u32 id)
 		}
 	}
 
-	if (!config) {
+	if (IS_ERR(config)) {
 		dev_err(&pdev->dev, "%s: failed to get dc config\n", __func__);
 		return ERR_PTR(-EINVAL);
 	}
diff --git a/drivers/video/adf/intel/core/intel_pipe.c b/drivers/video/adf/intel/core/intel_pipe.c
index ffb3057..9ac3800 100644
--- a/drivers/video/adf/intel/core/intel_pipe.c
+++ b/drivers/video/adf/intel/core/intel_pipe.c
@@ -19,6 +19,8 @@ int intel_pipe_init(struct intel_pipe *pipe, struct device *dev,
 	const struct intel_plane *primary_plane,
 	const struct intel_pipe_ops *ops, const char *name)
 {
+	pr_debug("ADF: %s\n", __func__);
+
 	if (!pipe || !primary_plane || !ops)
 		return -EINVAL;
 
diff --git a/drivers/video/adf/intel/core/vlv/vlv_dc_config.c b/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
index 29a7af0..6a69b0a 100644
--- a/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
+++ b/drivers/video/adf/intel/core/vlv/vlv_dc_config.c
@@ -13,10 +13,11 @@
  */
 
 #include <linux/pci.h>
-#include "core/intel_dc_config.h"
-#include "core/vlv/vlv_dc_config.h"
-#include "core/vlv/vlv_pri_plane.h"
-#include "core/vlv/vlv_sp_plane.h"
+#include <core/intel_dc_config.h>
+#include <core/common/dsi/dsi_pipe.h>
+#include <core/vlv/vlv_dc_config.h>
+#include <core/vlv/vlv_pri_plane.h>
+#include <core/vlv/vlv_sp_plane.h>
 
 #define VLV_ID(pipe, plane) ((pipe * VLV_MAX_PLANES) + plane)
 
@@ -25,11 +26,12 @@ struct vlv_dc_config {
 	struct vlv_disp {
 		struct vlv_pri_plane pplane;
 		struct vlv_sp_plane splane[2];
+		enum intel_pipe_type type;
+		union {
+			struct dsi_pipe dsi;
 
-		/*
-		 * TBD:
-		 * Add pipe datastructure
-		 */
+			/* later we will have hdmi pipe */
+		} pipe;
 	} vdisp[2];
 };
 
@@ -65,8 +67,7 @@ void vlv_dc_config_destroy(struct intel_dc_config *config)
 		return;
 
 	for (pipe = 0; pipe < MAX_PIPES; pipe++) {
-		/* Do pipe deinit here one pipe init code is there from DSI */
-
+		/* Do pipe deinit here one pipe init code is ready for DSI */
 		pplane = &vlv_config->vdisp[pipe].pplane;
 		vlv_pri_plane_destroy(pplane);
 		splane = &vlv_config->vdisp[pipe].splane[0];
@@ -102,10 +103,11 @@ static int vlv_initialize_disp(struct vlv_dc_config *vlv_config, int pipe,
 	}
 	intel_dc_config_add_plane(&vlv_config->base, &pplane->base,
 				  VLV_ID(pipe, VLV_PLANE));
+
 	/* Initialize first sprite */
 	splane = &vlv_config->vdisp[pipe].splane[0];
-	err = vlv_sp_plane_init(splane, vlv_config->base.dev, pipe ?
-				SPRITE_C : SPRITE_A);
+	err = vlv_sp_plane_init(splane, vlv_config->base.dev,
+				pipe ? SPRITE_C : SPRITE_A);
 	if (err) {
 		dev_err(vlv_config->base.dev,
 			"%s: failed to init sprite plane, %d\n", __func__, err);
@@ -113,10 +115,11 @@ static int vlv_initialize_disp(struct vlv_dc_config *vlv_config, int pipe,
 	}
 	intel_dc_config_add_plane(&vlv_config->base, &splane->base,
 				  VLV_ID(pipe, VLV_SPRITE1));
+
 	/* Initialize second sprite */
 	splane = &vlv_config->vdisp[pipe].splane[1];
-	err = vlv_sp_plane_init(splane, vlv_config->base.dev, pipe ?
-				SPRITE_D : SPRITE_B);
+	err = vlv_sp_plane_init(splane, vlv_config->base.dev,
+				pipe ? SPRITE_D : SPRITE_B);
 	if (err) {
 		dev_err(vlv_config->base.dev,
 				"%s: failed to init sprite plane, %d\n",
@@ -127,6 +130,7 @@ static int vlv_initialize_disp(struct vlv_dc_config *vlv_config, int pipe,
 				  VLV_ID(pipe, VLV_SPRITE2));
 
 	/* TBD: Initialize interface PIPE */
+
 	return err;
 }
 
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_config.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_config.h
index 05289c4..efab956 100644
--- a/drivers/video/adf/intel/include/core/common/dsi/dsi_config.h
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_config.h
@@ -22,6 +22,7 @@
 #include <linux/mutex.h>
 
 #include <video/adf.h>
+#include <drm/drm_crtc.h>
 #include "core/common/intel_dc_regs.h"
 
 /*DSI data lane configuration*/
@@ -43,8 +44,8 @@ enum {
 };
 
 typedef enum {
-	DSI_DBI = 0,
-	DSI_DPI,
+	DSI_DPI = 0,
+	DSI_DBI,
 } dsi_type_t;
 
 
@@ -154,7 +155,86 @@ struct dsi_registers {
 	u32 lvds_port_ctrl_reg;
 };
 
+#ifdef CONFIG_ADF_INTEL_VLV
+struct dsi_context {
+	/* if true, use HS mode, otherwise LP */
+	bool hs;
+
+	/* virtual channel */
+	int channel;
+
+	/* Video mode or command mode */
+	u16 operation_mode;
+
+	/* dual link support */
+	u8 dual_link;
+
+	/* number of DSI lanes */
+	unsigned int lane_count;
+
+	/* video mode pixel format for MIPI_DSI_FUNC_PRG register */
+	u32 pixel_format;
+
+	/* video mode format for MIPI_VIDEO_MODE_FORMAT register */
+	u32 video_mode_format;
 
+	/* eot for MIPI_EOT_DISABLE register */
+	u8 eotp_pkt;
+	u8 clock_stop;
+
+	u8 escape_clk_div;
+	u32 port_bits;
+	u32 bw_timer;
+	u32 dphy_reg;
+	u32 video_frmt_cfg_bits;
+	u16 lp_byte_clk;
+
+	/* timeouts in byte clocks */
+	u16 lp_rx_timeout;
+	u16 turn_arnd_val;
+	u16 rst_timer_val;
+	u16 hs_to_lp_count;
+	u16 clk_lp_to_hs_count;
+	u16 clk_hs_to_lp_count;
+
+	u16 init_count;
+	u32 pclk;
+	u16 burst_mode_ratio;
+
+	int backlight_level;
+
+	/* all delays in ms */
+	u16 backlight_off_delay;
+	u16 backlight_on_delay;
+	u16 panel_on_delay;
+	u16 panel_off_delay;
+	u16 panel_pwr_cycle_delay;
+};
+
+struct dsi_config {
+	struct dsi_context ctx;
+	struct mutex ctx_lock;
+	struct drm_mode_modeinfo perferred_mode;
+	struct drm_display_mode vbt_mode;
+
+	int pipe;
+	int changed;
+
+	int drv_ic_inited;
+
+	int bpp;
+
+	u8 dual_link;
+
+	/*mipi data lane config*/
+	int lane_config;
+
+	struct dsi_vbt *dsi;
+
+	u32 pixel_multiplier;
+	u8 lut_r[256], lut_g[256], lut_b[256];
+};
+#else
 struct dsi_context {
 	u32 vgacntr;
 
@@ -299,6 +379,7 @@ struct dsi_config {
 	/* SDO */
 	void *sdo;
 };
+#endif
 
 static inline int is_dual_link(struct dsi_config *config)
 {
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h
index b3cb53a..99134bc 100644
--- a/drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_panel.h
@@ -24,6 +24,8 @@
 #include <linux/panel_psb_drv.h>
 #endif
 
+#include "core/common/dsi/dsi_config.h"
+
 struct dsi_pipe;
 
 /*DSI panel connection status*/
@@ -64,9 +66,9 @@ struct panel_info {
  *call these callbacks to take the specific actions for the new panel.
  */
 struct panel_ops {
-	int (*get_config_mode)(struct drm_mode_modeinfo *);
-	void (*dsi_controller_init)(struct dsi_pipe *intf);
-	void (*get_panel_info)(struct panel_info *);
+	int (*get_config_mode)(struct dsi_config *, struct drm_mode_modeinfo *);
+	int (*dsi_controller_init)(struct dsi_pipe *intf);
+	int (*get_panel_info)(struct dsi_config *, struct panel_info *);
 	int (*reset)(struct dsi_pipe *intf);
 	int (*exit_deep_standby)(struct dsi_pipe *intf);
 	int (*detect)(struct dsi_pipe *intf);
@@ -75,6 +77,7 @@ struct panel_ops {
 	int (*set_brightness)(struct dsi_pipe *intf, int level);
 	int (*drv_ic_init)(struct dsi_pipe *intf);
 	int (*drv_set_panel_mode)(struct dsi_pipe *intf);
+	int (*disable_panel_power)(struct dsi_pipe *intf);
 };
 
 struct dsi_panel {
@@ -83,7 +86,17 @@ struct dsi_panel {
 	struct panel_ops *ops;
 };
 
-extern const struct dsi_panel *get_dsi_panel_by_id(u8 id);
+extern struct dsi_panel *get_dsi_panel_by_id(u8 id);
 extern const struct dsi_panel *get_dsi_panel(void);
 
+/* declare get panel callbacks */
+extern const struct dsi_panel *get_generic_panel(void);
+extern const struct dsi_panel *cmi_get_panel(void);
+extern struct dsi_panel *jdi_cmd_get_panel(void);
+extern struct dsi_panel *jdi_vid_get_panel(void);
+extern struct dsi_panel *sharp_10x19_cmd_get_panel(void);
+extern struct dsi_panel *sharp_10x19_dual_cmd_get_panel(void);
+extern struct dsi_panel *sharp_25x16_vid_get_panel(void);
+extern struct dsi_panel *sharp_25x16_cmd_get_panel(void);
+
 #endif /* DSI_PANEL_H_ */
diff --git a/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h b/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
index d39a901..6e94747 100644
--- a/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
+++ b/drivers/video/adf/intel/include/core/common/dsi/dsi_pipe.h
@@ -72,8 +72,13 @@ static inline struct dsi_pipe *to_dsi_pipe(struct intel_pipe *pipe)
 	return container_of(pipe, struct dsi_pipe, base);
 }
 
+#ifdef CONFIG_ADF_INTEL_VLV
+extern int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
+	struct intel_plane *primary_plane, u8 idx);
+#else
 extern int dsi_pipe_init(struct dsi_pipe *pipe, struct device *dev,
 	struct intel_plane *primary_plane, u8 idx, u32 gtt_phy_addr);
+#endif
 extern void dsi_pipe_destroy(struct dsi_pipe *pipe);
 
 extern bool dsi_pipe_enable_clocking(struct dsi_pipe *pipe);
diff --git a/drivers/video/adf/intel/include/core/vlv/vlv_dc_hw.h b/drivers/video/adf/intel/include/core/vlv/vlv_dc_hw.h
index 58c3543..f177d4e 100644
--- a/drivers/video/adf/intel/include/core/vlv/vlv_dc_hw.h
+++ b/drivers/video/adf/intel/include/core/vlv/vlv_dc_hw.h
@@ -26,4 +26,58 @@ enum {
 	N_PRI_PLANE,
 };
 
+#define BIT31   0x80000000
+#define BIT30   0x40000000
+#define BIT29   0x20000000
+#define BIT28   0x10000000
+#define BIT27   0x08000000
+#define BIT26   0x04000000
+#define BIT25   0x02000000
+#define BIT24   0x01000000
+#define BIT23   0x00800000
+#define BIT22   0x00400000
+#define BIT21   0x00200000
+#define BIT20   0x00100000
+#define BIT19   0x00080000
+#define BIT18   0x00040000
+#define BIT17   0x00020000
+#define BIT16   0x00010000
+#define BIT15   0x00008000
+#define BIT14   0x00004000
+#define BIT13   0x00002000
+#define BIT12   0x00001000
+#define BIT11   0x00000800
+#define BIT10   0x00000400
+#define BIT9    0x00000200
+#define BIT8    0x00000100
+#define BIT7    0x00000080
+#define BIT6    0x00000040
+#define BIT5    0x00000020
+#define BIT4    0x00000010
+#define BIT3    0x00000008
+#define BIT2    0x00000004
+#define BIT1    0x00000002
+#define BIT0    0x00000001
+
+enum pipestat_reg {
+	PIPE_HBLANK_STAT = BIT0,
+	FRAMESTART_STAT = BIT1,
+	START_OF_VBLANK_STAT = BIT2,
+	PIPE_PSR_STAT = BIT6,
+	DPST_EVENT_STAT = BIT7,
+	VSYNC_STAT = BIT9,
+	PLANE_FLIP_DONE_STAT = BIT10,
+	SPRITE1_FLIP_DONE_STAT = BIT14,
+	SPRITE2_FLIP_DONE_STAT = BIT15,
+	PIPE_HBLANK_EN = BIT16,
+	FRAMESTART_EN = BIT17,
+	START_OF_VBLANK_EN = BIT18,
+	SPRITE1_FLIP_DONE_EN = BIT22,
+	DPST_EVENT_EN = BIT23,
+	VSYNC_EN = BIT25,
+	PLANE_FLIP_DONE_EN = BIT26,
+	SPRITE2_FLIP_DONE_EN = BIT30,
+	FIFO_UNDERRUN_STAT = BIT31,
+};
+
 #endif
-- 
1.7.9.5

