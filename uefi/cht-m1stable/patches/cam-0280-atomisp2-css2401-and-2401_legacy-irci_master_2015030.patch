From 0de686789a79a1f91dc9b102ba00a6bdbb51c2bb Mon Sep 17 00:00:00 2001
From: Pengpeng Cui <pengpengx.cui@intel.com>
Date: Wed, 4 Mar 2015 18:13:08 +0800
Subject: [PATCH 280/284] atomisp2: css2401 and
 2401_legacy-irci_master_20150303_1500

Merge CSS2.1 for css2401 and 2401_legacy
for irci_master_20150303_1500 firmware tag

Change-Id: I9e10e5d7d0070b701a9fd7419c0b046118c93555
Tracked-On: https://jira01.devtools.intel.com/browse/IMINAN-24134
Signed-off-by: Pengpeng Cui <pengpengx.cui@intel.com>
Reviewed-on: https://icggerrit.ir.intel.com/44561
Build: viefandr
Integrator: Wei Tao <wei.tao@intel.com>
Approver: Wei Tao <wei.tao@intel.com>
Build: Wei Tao <wei.tao@intel.com>
Reviewed-by: Wei Tao <wei.tao@intel.com>
Maintainer: Wei Tao <wei.tao@intel.com>
---
 .../base/circbuf/interface/ia_css_circbuf.h        |   4 +-
 .../base/circbuf/src/circbuf.c                     |   5 +
 .../camera/pipe/interface/ia_css_pipe_binarydesc.h |  18 +-
 .../camera/pipe/src/pipe_binarydesc.c              |  46 +-
 .../css2401a0_legacy_v21/css_api_version.h         |  91 ++-
 .../hive_isp_css_2400_system/host/gdc.c            |  33 +
 .../hive_isp_css_2400_system/host/system_local.h   |   8 +
 .../ia_css_isp_states.h                            |   3 +
 .../hive_isp_css_include/host/gdc_public.h         |  10 +
 .../hive_isp_css_include/host/isys_irq_public.h    |  28 +-
 .../host/isys_stream2mmio_public.h                 |  14 +-
 .../hive_isp_css_include/host/ref_vector_func.h    | 220 ++++--
 .../host/ref_vector_func_types.h                   | 118 ++-
 .../hive_isp_css_include/isys_irq.h                |  28 +-
 .../hive_isp_css_include/math_support.h            |  10 +
 .../hive_isp_css_include/type_support.h            |   5 +
 .../hive_isp_css_include/vector_ops.h              |   2 +-
 .../pci/atomisp2/css2401a0_legacy_v21/ia_css.h     |   4 +-
 .../css2401a0_legacy_v21/ia_css_acc_types.h        |  14 +
 .../pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h |  17 -
 .../css2401a0_legacy_v21/ia_css_event_public.h     |  10 +-
 .../css2401a0_legacy_v21/ia_css_host_data.h        |   4 +-
 .../atomisp2/css2401a0_legacy_v21/ia_css_pipe.h    |   8 +
 .../css2401a0_legacy_v21/ia_css_pipe_public.h      |  63 +-
 .../css2401a0_legacy_v21/ia_css_stream_public.h    |  10 +-
 .../atomisp2/css2401a0_legacy_v21/ia_css_types.h   |  14 +-
 .../css2401a0_legacy_v21/ia_css_version_data.h     |   2 +-
 .../isp/kernels/bnlm/ia_css_bnlm.host.c            |  44 +-
 .../isp/kernels/bnlm/ia_css_bnlm_param.h           |   9 +-
 .../isp/kernels/bnlm/ia_css_bnlm_state.h           |  31 +
 .../isp/kernels/bnlm/ia_css_bnlm_types.h           |  76 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c    |   2 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h    |   2 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h   |  47 +-
 .../isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h      |  12 +-
 .../copy_output_1.0/ia_css_copy_output.host.c      |  10 +-
 .../isp/kernels/crop/crop_1.0/ia_css_crop.host.c   |  10 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.c        |  28 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.h        |  28 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_param.h       |  28 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_types.h       |  28 +-
 .../isp/kernels/dp/dp_1.0/ia_css_dp_state.h        |   4 +
 .../isp/kernels/dpc2/ia_css_dpc2.host.c            |  21 +
 .../isp/kernels/dpc2/ia_css_dpc2.host.h            |  12 +
 .../isp/kernels/dpc2/ia_css_dpc2_default.host.c    |  12 +
 .../isp/kernels/dpc2/ia_css_dpc2_default.host.h    |   9 +
 .../isp/kernels/dpc2/ia_css_dpc2_types.h           |  25 +-
 .../isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c      |  54 +-
 .../isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h      |   8 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.c        |  56 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.h        |   7 +-
 .../kernels/eed1_8/ia_css_eed1_8_default.host.c    |  20 +
 .../isp/kernels/eed1_8/ia_css_eed1_8_param.h       |  26 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8_types.h       |  87 ++-
 .../isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c      |  27 +-
 .../isp/kernels/hdr/ia_css_hdr.host.c              |  32 +-
 .../isp/kernels/hdr/ia_css_hdr.host.h              |   4 +-
 .../isp/kernels/hdr/ia_css_hdr_param.h             |   4 +-
 .../isp/kernels/hdr/ia_css_hdr_types.h             |   4 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.c      |  31 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.h      |   7 +
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_param.h     |   7 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_state.h     |  28 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_types.h     |   2 +-
 .../kernels/io_ls/common/ia_css_common_io_param.h  |  28 +-
 .../kernels/io_ls/common/ia_css_common_io_types.h  |  28 +-
 .../io_ls/plane_io_ls/ia_css_plane_io_param.h      |  28 +-
 .../io_ls/plane_io_ls/ia_css_plane_io_types.h      |  28 +-
 .../iterator/iterator_1.0/ia_css_iterator.host.c   |  52 +-
 .../iterator/iterator_1.0/ia_css_iterator.host.h   |  28 +-
 .../iterator/iterator_1.0/ia_css_iterator_param.h  |  28 +-
 .../kernels/macc/macc1_5/ia_css_macc1_5_types.h    |  10 +
 .../isp/kernels/ob/ob2/ia_css_ob2_types.h          |   9 +
 .../isp/kernels/ob/ob_1.0/ia_css_ob.host.c         |   2 +-
 .../kernels/output/output_1.0/ia_css_output.host.c |  43 +-
 .../kernels/qplane/qplane_2/ia_css_qplane.host.c   |  13 +-
 .../isp/kernels/raw/raw_1.0/ia_css_raw.host.c      |  37 +-
 .../isp/kernels/raw/raw_1.0/ia_css_raw_param.h     |   4 +-
 .../isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h     |  17 +
 .../kernels/sdis/common/ia_css_sdis_common.host.h  |  28 +-
 .../kernels/sdis/common/ia_css_sdis_common_types.h | 115 ++-
 .../isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c   |  22 +-
 .../isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c    |  32 +-
 .../isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c      |  30 +-
 .../kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c  |  32 +-
 .../isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h     |  44 +-
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c  | 155 ++++
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h  |  58 ++
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h |  50 ++
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h |  33 +
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c    | 154 ++++
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h    |  59 ++
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h   |  50 ++
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h   |  33 +
 .../isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c      |   4 +-
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c     |   4 +-
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h    |  25 +-
 .../isp/modes/interface/isp_const.h                |  67 +-
 .../isp/modes/interface/isp_exprs.h                |  28 +-
 .../isp/modes/interface/isp_types.h                |  28 +-
 .../runtime/binary/interface/ia_css_binary.h       |   7 +
 .../runtime/binary/src/binary.c                    |  57 +-
 .../runtime/debug/interface/ia_css_debug.h         |   8 +-
 .../runtime/debug/src/ia_css_debug.c               |   4 +-
 .../runtime/isys/src/csi_rx_rmgr.c                 |   4 +-
 .../runtime/queue/src/queue_access.h               |  14 +-
 .../runtime/spctrl/src/spctrl.c                    |   8 +-
 .../pci/atomisp2/css2401a0_legacy_v21/sh_css.c     | 296 ++++---
 .../css2401a0_legacy_v21/sh_css_firmware.c         |   4 +-
 .../pci/atomisp2/css2401a0_legacy_v21/sh_css_hrt.c |   8 -
 .../css2401a0_legacy_v21/sh_css_internal.h         |   9 +-
 .../css2401a0_legacy_v21/sh_css_param_shading.c    |  51 +-
 .../css2401a0_legacy_v21/sh_css_param_shading.h    |   3 +-
 .../atomisp2/css2401a0_legacy_v21/sh_css_params.c  | 310 +++++---
 .../atomisp2/css2401a0_legacy_v21/sh_css_params.h  |  18 +-
 .../pci/atomisp2/css2401a0_legacy_v21/sh_css_sp.c  |  10 +-
 .../pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c | 836 ++++++++++----------
 .../base/circbuf/interface/ia_css_circbuf.h        |   4 +-
 .../css2401a0_v21/base/circbuf/src/circbuf.c       |   5 +
 .../camera/pipe/interface/ia_css_pipe_binarydesc.h |  18 +-
 .../camera/pipe/src/pipe_binarydesc.c              |  46 +-
 .../css2401a0_v21/css_2401_system/host/isys_irq.c  |  28 +-
 .../css_2401_system/host/isys_irq_local.h          |  28 +-
 .../css_2401_system/host/isys_irq_private.h        |  28 +-
 .../host/isys_stream2mmio_private.h                |  45 +-
 .../css_2401_system/isys_irq_global.h              |  28 +-
 .../pci/atomisp2/css2401a0_v21/css_api_version.h   |  91 ++-
 .../hive_isp_css_2400_system/host/gdc.c            |  33 +
 .../hive_isp_css_2400_system/host/system_local.h   |   8 +
 .../ia_css_isp_states.h                            |   3 +
 .../hive_isp_css_include/host/gdc_public.h         |  10 +
 .../hive_isp_css_include/host/isys_irq_public.h    |  28 +-
 .../host/isys_stream2mmio_public.h                 |  14 +-
 .../hive_isp_css_include/host/ref_vector_func.h    | 220 ++++--
 .../host/ref_vector_func_types.h                   | 118 ++-
 .../css2401a0_v21/hive_isp_css_include/isys_irq.h  |  28 +-
 .../hive_isp_css_include/math_support.h            |  10 +
 .../hive_isp_css_include/type_support.h            |   5 +
 .../hive_isp_css_include/vector_ops.h              |   2 +-
 .../media/pci/atomisp2/css2401a0_v21/ia_css.h      |   4 +-
 .../pci/atomisp2/css2401a0_v21/ia_css_acc_types.h  |  14 +
 .../media/pci/atomisp2/css2401a0_v21/ia_css_err.h  |  17 -
 .../atomisp2/css2401a0_v21/ia_css_event_public.h   |  10 +-
 .../pci/atomisp2/css2401a0_v21/ia_css_host_data.h  |   4 +-
 .../media/pci/atomisp2/css2401a0_v21/ia_css_pipe.h |   8 +
 .../atomisp2/css2401a0_v21/ia_css_pipe_public.h    |  63 +-
 .../atomisp2/css2401a0_v21/ia_css_stream_public.h  |  10 +-
 .../pci/atomisp2/css2401a0_v21/ia_css_types.h      |  14 +-
 .../atomisp2/css2401a0_v21/ia_css_version_data.h   |   2 +-
 .../isp/kernels/bnlm/ia_css_bnlm.host.c            |  44 +-
 .../isp/kernels/bnlm/ia_css_bnlm_param.h           |   9 +-
 .../isp/kernels/bnlm/ia_css_bnlm_state.h           |  31 +
 .../isp/kernels/bnlm/ia_css_bnlm_types.h           |  76 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c    |   2 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h    |   2 +-
 .../isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h   |  47 +-
 .../isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h      |  12 +-
 .../copy_output_1.0/ia_css_copy_output.host.c      |  10 +-
 .../isp/kernels/crop/crop_1.0/ia_css_crop.host.c   |  10 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.c        |  28 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2.host.h        |  28 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_param.h       |  28 +-
 .../isp/kernels/ctc/ctc2/ia_css_ctc2_types.h       |  28 +-
 .../isp/kernels/dp/dp_1.0/ia_css_dp_state.h        |   4 +
 .../isp/kernels/dpc2/ia_css_dpc2.host.c            |  21 +
 .../isp/kernels/dpc2/ia_css_dpc2.host.h            |  12 +
 .../isp/kernels/dpc2/ia_css_dpc2_default.host.c    |  12 +
 .../isp/kernels/dpc2/ia_css_dpc2_default.host.h    |   9 +
 .../isp/kernels/dpc2/ia_css_dpc2_types.h           |  25 +-
 .../isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c      |  54 +-
 .../isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h      |   8 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.c        |  56 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8.host.h        |   7 +-
 .../kernels/eed1_8/ia_css_eed1_8_default.host.c    |  20 +
 .../isp/kernels/eed1_8/ia_css_eed1_8_param.h       |  26 +-
 .../isp/kernels/eed1_8/ia_css_eed1_8_types.h       |  87 ++-
 .../isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c      |  27 +-
 .../isp/kernels/hdr/ia_css_hdr.host.c              |  32 +-
 .../isp/kernels/hdr/ia_css_hdr.host.h              |   4 +-
 .../isp/kernels/hdr/ia_css_hdr_param.h             |   4 +-
 .../isp/kernels/hdr/ia_css_hdr_types.h             |   4 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.c      |  31 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6.host.h      |   7 +
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_param.h     |   7 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_state.h     |  28 +-
 .../isp/kernels/iefd2_6/ia_css_iefd2_6_types.h     |   2 +-
 .../kernels/io_ls/common/ia_css_common_io_param.h  |  28 +-
 .../kernels/io_ls/common/ia_css_common_io_types.h  |  28 +-
 .../io_ls/plane_io_ls/ia_css_plane_io_param.h      |  28 +-
 .../io_ls/plane_io_ls/ia_css_plane_io_types.h      |  28 +-
 .../iterator/iterator_1.0/ia_css_iterator.host.c   |  52 +-
 .../iterator/iterator_1.0/ia_css_iterator.host.h   |  28 +-
 .../iterator/iterator_1.0/ia_css_iterator_param.h  |  28 +-
 .../kernels/macc/macc1_5/ia_css_macc1_5_types.h    |  10 +
 .../isp/kernels/ob/ob2/ia_css_ob2_types.h          |   9 +
 .../isp/kernels/ob/ob_1.0/ia_css_ob.host.c         |   2 +-
 .../kernels/output/output_1.0/ia_css_output.host.c |  43 +-
 .../kernels/qplane/qplane_2/ia_css_qplane.host.c   |  13 +-
 .../isp/kernels/raw/raw_1.0/ia_css_raw.host.c      |  37 +-
 .../isp/kernels/raw/raw_1.0/ia_css_raw_param.h     |   4 +-
 .../isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h     |  17 +
 .../kernels/sdis/common/ia_css_sdis_common.host.h  |  28 +-
 .../kernels/sdis/common/ia_css_sdis_common_types.h | 115 ++-
 .../isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c   |  22 +-
 .../isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c    |  32 +-
 .../isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c      |  30 +-
 .../kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c  |  32 +-
 .../isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h     |  44 +-
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c  | 155 ++++
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h  |  58 ++
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h |  50 ++
 .../kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h |  33 +
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c    | 154 ++++
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h    |  59 ++
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h   |  50 ++
 .../kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h   |  33 +
 .../isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c      |   4 +-
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c     |   4 +-
 .../isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h    |  25 +-
 .../css2401a0_v21/isp/modes/interface/isp_const.h  |  67 +-
 .../css2401a0_v21/isp/modes/interface/isp_exprs.h  |  28 +-
 .../css2401a0_v21/isp/modes/interface/isp_types.h  |  28 +-
 .../runtime/binary/interface/ia_css_binary.h       |   7 +
 .../css2401a0_v21/runtime/binary/src/binary.c      |  57 +-
 .../runtime/debug/interface/ia_css_debug.h         |   8 +-
 .../css2401a0_v21/runtime/debug/src/ia_css_debug.c |   4 +-
 .../css2401a0_v21/runtime/isys/src/csi_rx_rmgr.c   |   4 +-
 .../css2401a0_v21/runtime/queue/src/queue_access.h |  14 +-
 .../css2401a0_v21/runtime/spctrl/src/spctrl.c      |   8 +-
 .../media/pci/atomisp2/css2401a0_v21/sh_css.c      | 296 ++++---
 .../pci/atomisp2/css2401a0_v21/sh_css_firmware.c   |   4 +-
 .../media/pci/atomisp2/css2401a0_v21/sh_css_hrt.c  |   8 -
 .../pci/atomisp2/css2401a0_v21/sh_css_internal.h   |   9 +-
 .../atomisp2/css2401a0_v21/sh_css_param_shading.c  |  51 +-
 .../atomisp2/css2401a0_v21/sh_css_param_shading.h  |   3 +-
 .../pci/atomisp2/css2401a0_v21/sh_css_params.c     | 310 +++++---
 .../pci/atomisp2/css2401a0_v21/sh_css_params.h     |  18 +-
 .../media/pci/atomisp2/css2401a0_v21/sh_css_sp.c   |  10 +-
 .../media/pci/atomisp2/css2401a0_v21/spmem_dump.c  | 866 +++++++++++----------
 239 files changed, 6346 insertions(+), 3209 deletions(-)
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_state.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_state.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h
 create mode 100644 drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h

diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/interface/ia_css_circbuf.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/interface/ia_css_circbuf.h
index 32afa10..2a38e2b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/interface/ia_css_circbuf.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/interface/ia_css_circbuf.h
@@ -15,12 +15,12 @@
 #ifndef _IA_CSS_CIRCBUF_H
 #define _IA_CSS_CIRCBUF_H
 
-#include <assert_support.h>
+#include <sp.h>
 #include <type_support.h>
 #include <math_support.h>
 #include <storage_class.h>
+#include <assert_support.h>
 #include <platform_support.h>
-#include <sp.h>
 #include "ia_css_circbuf_comm.h"
 #include "ia_css_circbuf_desc.h"
 #ifdef __SP
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/src/circbuf.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/src/circbuf.c
index e94f526..2493dd2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/src/circbuf.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/base/circbuf/src/circbuf.c
@@ -19,7 +19,9 @@
 #ifdef __SP
 #include <hive_isp_css_sp_api_modified.h>
 #include <ia_css_sp_file_id.sp.h>
+#ifndef SP_FILE_ID
 #define SP_FILE_ID SP_FILE_ID_CIRCBUF /* overrule default in ia_css_sp_assert_level.sp.h */
+#endif
 #include <ia_css_sp_assert_level.sp.h>
 #endif
 
@@ -317,6 +319,9 @@ ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
 		ia_css_circbuf_elem_cpy(&cb->elems[chunk_src],
 					     &cb->elems[chunk_dest]);
 
+		/* clear the source position */
+		ia_css_circbuf_elem_init(&cb->elems[chunk_src]);
+
 		/* adjust the source/terminal positions */
 		chunk_src = ia_css_circbuf_get_pos_at_offset(cb, chunk_src, -1);
 		chunk_dest = ia_css_circbuf_get_pos_at_offset(cb, chunk_dest, -1);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h
index 8ffc41d..b5b0e60 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h
@@ -117,7 +117,7 @@ extern enum ia_css_err ia_css_pipe_get_video_binarydesc(
  *
  */
 void ia_css_pipe_get_yuvscaler_binarydesc(
-	struct ia_css_pipe * const pipe,
+	struct ia_css_pipe const * const pipe,
 	struct ia_css_binary_descr *yuv_scaler_descr,
 	struct ia_css_frame_info *in_info,
 	struct ia_css_frame_info *out_info,
@@ -267,4 +267,20 @@ extern void ia_css_pipe_get_post_anr_binarydesc(
 	struct ia_css_frame_info *out_info,
 	struct ia_css_frame_info *vf_info);
 
+/** @brief Get a binary descriptor for ldc stage.
+ *
+ * @param[in/out] pipe
+ * @param[out] capture_pp_descr
+ * @param[in/out] in_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_ldc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *ldc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info);
+
+
 #endif /* __IA_CSS_PIPE_BINARYDESC_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c
index 20af57c..79996e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/camera/pipe/src/pipe_binarydesc.c
@@ -56,6 +56,7 @@ static void pipe_binarydesc_get_offline(
 	descr->enable_dz = true;
 	descr->enable_xnr = false;
 	descr->enable_dpc = false;
+	descr->enable_capture_pp_bli = false;
 	descr->enable_fractional_ds = false;
 	descr->dvs_env.width = 0;
 	descr->dvs_env.height = 0;
@@ -460,7 +461,7 @@ enum ia_css_err ia_css_pipe_get_video_binarydesc(
 }
 
 void ia_css_pipe_get_yuvscaler_binarydesc(
-	struct ia_css_pipe * const pipe,
+	struct ia_css_pipe const * const pipe,
 	struct ia_css_binary_descr *yuv_scaler_descr,
 	struct ia_css_frame_info *in_info,
 	struct ia_css_frame_info *out_info,
@@ -468,6 +469,7 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	struct ia_css_frame_info *vf_info)
 {
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame_info *this_vf_info = NULL;
 
 	assert(pipe != NULL);
 	assert(in_info != NULL);
@@ -488,11 +490,15 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	 * fails
 	 */
 
+	if (vf_info) {
+		this_vf_info = (vf_info->res.width == 0 &&
+			vf_info->res.height == 0) ? NULL : vf_info;
+	}
+
 	pipe_binarydesc_get_offline(pipe,
 			       IA_CSS_BINARY_MODE_CAPTURE_PP,
 			       yuv_scaler_descr,
-			       in_info, out_infos,
-			       (vf_info->res.width == 0 && vf_info->res.height == 0) ? NULL : vf_info);
+			       in_info, out_infos, this_vf_info);
 
 	yuv_scaler_descr->enable_fractional_ds = true;
 	IA_CSS_LEAVE_PRIVATE("");
@@ -533,6 +539,8 @@ void ia_css_pipe_get_capturepp_binarydesc(
 			       capture_pp_descr,
 			       in_info, out_infos, vf_info);
 
+	capture_pp_descr->enable_capture_pp_bli =
+		pipe->config.default_capture_config.enable_capture_pp_bli;
 	capture_pp_descr->enable_fractional_ds = true;
 	capture_pp_descr->enable_xnr =
 		pipe->config.default_capture_config.enable_xnr != 0;
@@ -558,7 +566,7 @@ void ia_css_pipe_get_primary_binarydesc(
 	struct ia_css_frame_info *vf_info,
 	unsigned int stage_idx)
 {
-	unsigned int pipe_version = pipe->config.isp_pipe_version;
+	enum ia_css_pipe_version pipe_version = pipe->config.isp_pipe_version;
 	int mode;
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -833,3 +841,33 @@ void ia_css_pipe_get_post_anr_binarydesc(
 	post_anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_PRIVATE("");
 }
+
+void ia_css_pipe_get_ldc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *ldc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	IA_CSS_ENTER_PRIVATE("");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_YUV420;
+	in_info->raw_bit_depth = 0;
+	ia_css_frame_info_set_width(in_info, in_info->res.width, 0);
+
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
+		out_infos[i] = NULL;
+
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_CAPTURE_PP,
+			       ldc_descr, in_info, out_infos, NULL);
+	ldc_descr->enable_dvs_6axis =
+		    pipe->extra_config.enable_dvs_6axis;
+	IA_CSS_LEAVE_PRIVATE("");
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/css_api_version.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/css_api_version.h
index 303fdf9..2685d1a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/css_api_version.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/css_api_version.h
@@ -35,7 +35,7 @@ The version string has four dot-separated numbers, read left to right:
 
 */
 
-#define CSS_API_VERSION_STRING	"2.1.11.2"
+#define CSS_API_VERSION_STRING	"2.1.14.18"
 
 /*
 Change log
@@ -229,32 +229,93 @@ v2.1.9.2, added IA_CSS_EVENT_TYPE_TIMER
 v2.1.10.0 (4 changes parallel), Add a flag "enable_dpc" to "struct ia_css_pipe_config"
 - Add a flag "enable_dpc" to "struct ia_css_pipe_config"
 
-v2.1.10.4 (4 changes parallel), fix IEFD's puclic API types
+v2.1.10.6 (6 changes parallel), change the pipe version type from integer to enum
+- add new enum to enumerate ISP pipe version
+- change the pipe version type in pipe_config from integer to enum
+
+v2.1.13.0 (8 changes parallel), Stop Support for Skycam B0
+- Remove a few pre-processor defines for Skycam B0/C0 as support
+
+v2.1.14.0 (23 changes parallel), change the pipe version type from integer to enum
+- remove the temporary workaround for backward compatability
+
+v2.1.14.0 (12 changes parallel), expose_gamma_enable_option
+- added enable param to gamma_corr_public_config
+- added documentation to rgbpp_public.h
+
+v2.1.14.0 (11 changes parallel), Remove deprecated FW_ERROR event.
+- Remove code for deprecated FW_ERROR event.
+
+v2.1.14.3 (5 changes parallel), fix IEFD's puclic API types
 - fix IEFD public API members types: rad_cu6_x1,rad_cu_unsharp_x1 & unsharp_amount
 
-v2.1.10.4 (4 changes parallel), Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH
+v2.1.14.3 (5 changes parallel), Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH
 - Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH enum to ia_css_fw_warning type
 
-v2.1.10.5 (5 changes parallel), change the pipe version type from integer to enum
-- add new enum to enumerate ISP pipe version
-- change the pipe version type in pipe_config from integer to enum
+v2.1.14.4 (5 changes parallel), new API getter functions for gdc in buffer information
+- ia_css_pipe_get_dvs_filter() added
+- ia_css_pipe_get_gdc_in_buffer_info() added
+
+v2.1.14.5 (8 changes parallel), Update CNR2 ineffective values
+- Fixed Incorrect ineffective values listed in ia_css_cnr_config
+- Correct Ineffective value is 8191
+
+v2.1.14.5 (8 changes parallel), af_roi_api
+- added a new function to set AF ROI ia_css_set_af_roi
+- added a new struct ia_css_s3a_roi_offset
+
+v2.1.14.5 (8 changes parallel), remove x_y_end_from_ae_and_awb
+- added a flag to prepare removal of x_end and y_end from ae grid public config
+- added a flag to prepare removal of x_end and y_end from awb grid public config
 
-v2.1.10.5 (2 changes parallel), Added public interface for setting the scaler LUT.
+v2.1.14.5 (4 changes parallel), Added public interface for setting the scaler LUT.
 - Added the public struct to output system and modified the global config struct.
 
-v2.1.10.6 (6 changes parallel), add_flag_to_disable_continous_viewfinder
+v2.1.14.6 (8 changes parallel), add_flag_to_disable_continous_viewfinder
 - add a new flag in stream_config to disable continuous viewfinder
 - in ZSL use case.
 
-v2.1.11.0 (2 changes parallel), Stop Support for Skycam B0
-- Remove a few pre-processor defines for Skycam B0/C0 as support
-
-v2.1.11.2 (3 changes parallel), Enlarge AF AWB_FR stats buffers
+v2.1.14.6 (8 changes parallel), Enlarge AF AWB_FR stats buffers
 - Enlarge AF and AWB_FR stats buffers to support max grid width per stripe as oppose to per frame
 
-v2.1.11.2 (2 changes parallel), new API getter functions for gdc in buffer information
-- ia_css_pipe_get_dvs_filter() added
-- ia_css_pipe_get_gdc_in_buffer_info() added
+v2.1.14.7 (5 changes parallel), pipe config option for vf output bci mode downscaling
+- vf downscaling using yuv_scale binary.
+
+v2.1.14.9 (6 changes parallel), Add scale mode GDC V2 LUT to CSS API
+- Allow client to set global LUT for gdc v2 (First step in this change. See wiki page for more details)
+
+v2.1.14.9 (7 changes parallel), Include added to type-support.h.
+- Include of hive/cell_support.h was added to type-support.h, in order to
+- have access to define HAVE_STDINT.
+
+v2.1.14.10 (6 changes parallel), Pipe configuration to enable BLI mode downscaling for
+- BLI mode downscaling for capture post-processing
+
+v2.1.14.13 (8 changes parallel), Fix copyright headers (no functional change)
+- No functional change; only fixes copyright headers
+
+v2.1.14.13 (5 changes parallel), Remove continuous mode special case handling in ia_css_pipe_set_isp_config
+- For continuous mode isp_config was being send to all pipes,
+- even though API ia_css_pipe_set_isp_config is for single pipe
+- Removed incorrect case
+
+v2.1.14.13 (5 changes parallel), DVS statistics grid produced by accelerator
+- Add DVS statistics produced by accelerator grid to pipe info
+- Add ia_css_pipe_has_dvs_stats function
+
+v2.1.14.14 (6 changes parallel), cont_remove_x_y_end_from_ae_and_awb
+- this patch doesn't introduce any new api change, it only fixes a recent
+- api merged change (#31938) , in order to have success CI i had to upload an api change request
+
+v2.1.14.15 (4 changes parallel), Add XNR3 blending strength to kernel interface
+- Added a blending strength field to the XNR3 kernel interface to add
+- support for blending.
+
+v2.1.14.17 (21 changes parallel), eliminate two_pixels_per_clock field
+- remove obsolete field two_pixels_per_clock
+
+v2.1.14.18 (2 changes parallel), Fix copyright headers (no functional change)
+- No functional change; only fixes copyright headers
 
 */
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/gdc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/gdc.c
index 288de8c..7567351 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/gdc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/gdc.c
@@ -66,6 +66,39 @@ void gdc_lut_store(
 return;
 }
 
+/*
+ * Input LUT format:
+ * c0[0-1023], c1[0-1023], c2[0-1023] c3[0-1023]
+ *
+ * Output LUT format (interleaved):
+ * c0[0], c1[0], c2[0], c3[0], c0[1], c1[1], c2[1], c3[1], ....
+ * c0[1023], c1[1023], c2[1023], c3[1023]
+ *
+ * The first format needs c0[0], c1[0] (which are 1024 words apart)
+ * to program gdc LUT registers. This makes it difficult to do piecemeal
+ * reads in SP side gdc_lut_store
+ *
+ * Interleaved format allows use of contiguous bytes to store into
+ * gdc LUT registers.
+ *
+ * See gdc_lut_store() definition in host/gdc.c vs sp/gdc_private.h
+ *
+ */
+void gdc_lut_convert_to_isp_format(const int in_lut[4][HRT_GDC_N],
+	int out_lut[4][HRT_GDC_N])
+{
+	unsigned int i;
+	int *out = (int *)out_lut;
+
+	for (i = 0; i < HRT_GDC_N; i++) {
+		out[0] = in_lut[0][i];
+		out[1] = in_lut[1][i];
+		out[2] = in_lut[2][i];
+		out[3] = in_lut[3][i];
+		out += 4;
+	}
+}
+
 int gdc_get_unity(
 	const gdc_ID_t		ID)
 {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/system_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/system_local.h
index 85f0424..baaef3d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/system_local.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2400_system/host/system_local.h
@@ -28,6 +28,8 @@
 #ifdef __FIST__
 #define HRT_ADDRESS_WIDTH	32		/* Surprise, this is a local property and even differs per platform */
 #else
+/* HRT assumes 32 by default (see Linux/include/hrt/hive_types.h), overrule it in case it is different */
+#undef HRT_ADDRESS_WIDTH
 #define HRT_ADDRESS_WIDTH	64		/* Surprise, this is a local property */
 #endif
 
@@ -85,6 +87,9 @@ static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
 static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
 	(hrt_address)0x0000000000300000ULL};
 
+static const hrt_address SP_PMEM_BASE[N_SP_ID] = {
+	(hrt_address)0x00000000000B0000ULL};
+
 /* MMU */
 #if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
 /*
@@ -204,6 +209,9 @@ static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
 static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
 	(hrt_address)0x00300000UL};
 
+static const hrt_address SP_PMEM_BASE[N_SP_ID] = {
+	(hrt_address)0x000B0000UL};
+
 /* MMU */
 #if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
 /*
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_states.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_states.h
index 570754c..d658a00 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_states.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_2401_system_generated/ia_css_isp_states.h
@@ -22,6 +22,9 @@
 #include "isp/kernels/ref/ref_1.0/ia_css_ref.host.h"
 #include "isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h"
 #include "isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h"
+#include "isp/kernels/iefd2_6/ia_css_iefd2_6.host.h"
+#include "isp/kernels/dpc2/ia_css_dpc2.host.h"
+#include "isp/kernels/eed1_8/ia_css_eed1_8.host.h"
 /* Generated code: do not edit or commmit. */
 
 #ifndef _IA_CSS_ISP_STATE_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/gdc_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/gdc_public.h
index 80ffda4..d27f87a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/gdc_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/gdc_public.h
@@ -37,6 +37,16 @@ STORAGE_CLASS_EXTERN void gdc_lut_store(
 	const gdc_ID_t		ID,
 	const int			data[4][HRT_GDC_N]);
 
+/*! Convert the bicubic interpolation table of GDC[ID] to the ISP-specific format
+
+ \param	ID[in]				GDC identifier
+ \param in_lut[in]			The data matrix to be converted
+ \param out_lut[out]			The data matrix as the output of conversion
+ */
+STORAGE_CLASS_EXTERN void gdc_lut_convert_to_isp_format(
+	const int in_lut[4][HRT_GDC_N],
+	int out_lut[4][HRT_GDC_N]);
+
 /*! Return the integer representation of 1.0 of GDC[ID]
  
  \param	ID[in]				GDC identifier
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_irq_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_irq_public.h
index 258bc73..c3e6f76 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_irq_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_irq_public.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __ISYS_IRQ_PUBLIC_H__
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_stream2mmio_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_stream2mmio_public.h
index d8ef806..5624cfc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_stream2mmio_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/isys_stream2mmio_public.h
@@ -41,7 +41,7 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_state(
  */
 STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_sid_state(
 		const stream2mmio_ID_t ID,
-		const uint32_t sid_id,
+		const stream2mmio_sid_ID_t sid_id,
 		stream2mmio_sid_state_t *state);
 /** end of NCI */
 
@@ -61,9 +61,9 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_sid_state(
  * @return the value of the register.
  */
 STORAGE_CLASS_STREAM2MMIO_H hrt_data stream2mmio_reg_load(
-	const stream2mmio_ID_t ID,
-	const uint32_t sid_id,
-	const uint32_t reg_idx);
+		const stream2mmio_ID_t ID,
+		const stream2mmio_sid_ID_t sid_id,
+		const uint32_t reg_idx);
 
 /**
  * @brief Dump the SID processor state.
@@ -93,9 +93,9 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_dump_state(
  *
  */
 STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_reg_store(
-	const stream2mmio_ID_t ID,
-	const hrt_address reg,
-	const hrt_data value);
+		const stream2mmio_ID_t ID,
+		const hrt_address reg,
+		const hrt_data value);
 /** end of DLI */
 
 #endif /* __ISYS_STREAM2MMIO_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func.h
index 8e8fcac..605d309 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func.h
@@ -1,28 +1,17 @@
 /*
- * INTEL CONFIDENTIAL
- *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
- *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
-
 #ifndef _REF_VECTOR_FUNC_H_INCLUDED_
 #define _REF_VECTOR_FUNC_H_INCLUDED_
 
@@ -173,6 +162,25 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H  tvector1w OP_1w_XCU(
 	xcu_ref_init_vectors init_vectors);
 
 
+/** @brief LXCU
+ *
+ * @param[in] x 		input
+ * @param[in] init_vectors 	LUT data structure
+ *
+ * @return   logarithmic piecewise linear estimated output.
+ * This block gets an input x and a set of input configuration points stored in a look-up
+ * table of 32 elements. It computes the interval in which the input lies.
+ * Then output is computed by performing linear interpolation based on the interval
+ * properties (i.e. x_prev, slope, * and offset).
+ * This BBB assumes spacing x-coordinates of "init vectors" increase exponentially as
+ * shown below.
+ * interval size :   2^0    2^1      2^2    2^3
+ * x-coordinates: x0<--->x1<---->x2<---->x3<---->
+ **/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_LXCU(
+	tvector1w x,
+	xcu_ref_init_vectors init_vectors);
+
 /** @brief Coring
  *
  * @param[in] coring_vec   Amount of coring based on brightness level
@@ -288,7 +296,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x3m_6dB_nrm_ph3 (
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x3m_6dB_nrm_calc_coeff (
 	const s_1w_1x3_matrix		m, tscalar1w_3bit coeff);
 
-/** @brief 3 tab FIR with coefficients [1,1,1]
+/** @brief 3 tap FIR with coefficients [1,1,1]
  *
  * @param[in] m	1x3 matrix with pixels
  *
@@ -472,15 +480,15 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x9m_box (
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x11m_box (
 	s_1w_1x11_matrix m);
 
-/** @brief Symmetric 7 tab filter with normalization
+/** @brief Symmetric 7 tap filter with normalization
  *
  *  @param[in] in 1x7 matrix with pixels
  *  @param[in] coeff 1x4 matrix with coefficients
  *  @param[in] out_shift output pixel shift value for normalization
  *
- *  @return symmetric 7 tab filter output
+ *  @return symmetric 7 tap filter output
  *
- * This function performs symmetric 7 tab filter over input pixels.
+ * This function performs symmetric 7 tap filter over input pixels.
  * Filter sum is normalized by shifting out_shift bits.
  * Filter sum: p0*c3 + p1*c2 + p2*c1 + p3*c0 + p4*c1 + p5*c2 + p6*c3
  * is implemented as: (p0 + p6)*c3 + (p1 + p5)*c2 + (p2 + p4)*c1 + p3*c0 to
@@ -493,23 +501,48 @@ fir1x7m_sym_nrm(s_1w_1x7_matrix in,
 		s_1w_1x4_matrix coeff,
 		tvector1w out_shift);
 
-/** @brief approximation for Symmetric 4 tap filter(-1,9,9,-1) with normalization
+/** @brief Symmetric 7 tap filter with normalization at input side
  *
- *  @param[in] in 1x4 matrix with pixels
+ *  @param[in] in 1x7 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
  *
- *  @return 4 tap filter output
+ *  @return symmetric 7 tap filter output
  *
- * this function is used by xnr4 upscale2
+ * This function performs symmetric 7 tap filter over input pixels.
+ * Filter sum: p0*c3 + p1*c2 + p2*c1 + p3*c0 + p4*c1 + p5*c2 + p6*c3
+ *          = (p0 + p6)*c3 + (p1 + p5)*c2 + (p2 + p4)*c1 + p3*c0
+ * Input pixels and coefficients are in Qn format, where n =
+ * ISP_VEC_ELEMBITS - 1 (ie Q15 for Broxton)
+ * To avoid double precision arithmetic input pixel sum and final sum is
+ * implemented using avgrnd and coefficient multiplication using qrmul.
+ * Final result is in Qm format where m = ISP_VEC_ELEMBITS - 2 (ie Q14 for
+ * Broxton)
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x7m_sym_innrm_approx(s_1w_1x7_matrix in,
+			 s_1w_1x4_matrix coeff);
+
+/** @brief Symmetric 7 tap filter with normalization at output side
  *
- * This function performs 4 tap filter over input pixels.
- * Filter sum is normalized by shifting out_shift bits.
- * Filter sum: p0*c0 + p1*c1 + p2*c2 + p3*c3
- * The coeeficients are -1, 9, 9, -1 with shift of 4
- * The below implementation is the approximation that consumes less cycles.
+ *  @param[in] in 1x7 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
+ *
+ *  @return symmetric 7 tap filter output
  *
+ * This function performs symmetric 7 tap filter over input pixels.
+ * Filter sum: p0*c3 + p1*c2 + p2*c1 + p3*c0 + p4*c1 + p5*c2 + p6*c3
+ *          = (p0 + p6)*c3 + (p1 + p5)*c2 + (p2 + p4)*c1 + p3*c0
+ * Input pixels are in Qn and coefficients are in Qm format, where n =
+ * ISP_VEC_ELEMBITS - 2 and m = ISP_VEC_ELEMBITS - 1 (ie Q14 and Q15
+ * respectively for Broxton)
+ * To avoid double precision arithmetic input pixel sum and final sum is
+ * implemented using addsat and coefficient multiplication using qrmul.
+ * Final sum is left shifted by 2 and saturated to produce result is Qm format
+ * (ie Q15 for Broxton)
 */
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
-fir1x4m_sym_nrm_minus1_9_9_minus1_appr(s_1w_1x4_matrix in);
+fir1x7m_sym_outnrm_approx(s_1w_1x7_matrix in,
+			 s_1w_1x4_matrix coeff);
 
 /** @brief 4 tap filter with normalization
  *
@@ -528,15 +561,53 @@ fir1x4m_nrm(s_1w_1x4_matrix in,
 		s_1w_1x4_matrix coeff,
 		tvector1w out_shift);
 
-/** @brief Symmetric 3 tab filter with normalization
+/** @brief 4 tap filter with normalization for half pixel interpolation
+ *
+ *  @param[in] in 1x4 matrix with pixels
+ *
+ *  @return 4 tap filter output with filter tap [-1 9 9 -1]/16
+ *
+ * This function performs 4 tap filter over input pixels.
+ * Filter sum: -p0 + 9*p1 + 9*p2 - p3
+ * This filter implementation is completely free from multiplication and double
+ * precision arithmetic.
+ * Typical usage of this filter is to half pixel interpolation of Bezier
+ * surface
+ * */
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x4m_bicubic_bezier_half(s_1w_1x4_matrix in);
+
+/** @brief 4 tap filter with normalization for quarter pixel interpolation
+ *
+ *  @param[in] in 1x4 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
+ *
+ *  @return 4 tap filter output
+ *
+ * This function performs 4 tap filter over input pixels.
+ * Filter sum: p0*c0 + p1*c1 + p2*c2 + p3*c3
+ * To avoid double precision arithmetic we implemented multiplication using
+ * qrmul and addition using avgrnd. Coefficients( c0 to c3) formats are assumed
+ * to be: Qm, Qn, Qo, Qm, where m = n + 2 and o = n + 1.
+ * Typical usage of this filter is to quarter pixel interpolation of Bezier
+ * surface with filter coefficients:[-9 111 29 -3]/128. For which coefficient
+ * values should be: [-9216/2^17  28416/2^15  1484/2^16 -3072/2^17] for
+ * ISP_VEC_ELEMBITS = 16.
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x4m_bicubic_bezier_quarter(s_1w_1x4_matrix in,
+			s_1w_1x4_matrix coeff);
+
+
+/** @brief Symmetric 3 tap filter with normalization
  *
  *  @param[in] in 1x3 matrix with pixels
  *  @param[in] coeff 1x2 matrix with coefficients
  *  @param[in] out_shift output pixel shift value for normalization
  *
- *  @return symmetric 3 tab filter output
+ *  @return symmetric 3 tap filter output
  *
- * This function performs symmetric 3 tab filter input pixels.
+ * This function performs symmetric 3 tap filter input pixels.
  * Filter sum is normalized by shifting out_shift bits.
  * Filter sum: p0*c1 + p1*c0 + p2*c1
  * is implemented as: (p0 + p2)*c1 + p1*c0 to reduce multiplication.
@@ -548,30 +619,25 @@ fir1x3m_sym_nrm(s_1w_1x3_matrix in,
 		s_1w_1x2_matrix coeff,
 		tvector1w out_shift);
 
-/** @brief Absolute gradient between two sets of 1x5 yuv matrices
+/** @brief Symmetric 3 tap filter with normalization
  *
- *  @param[in] in0_y	1x5 matrix with y components of the first set of pixels
- *  @param[in] in0_u	1x5 matrix with u components of the first set of pixels
- *  @param[in] in0_v	1x5 matrix with v components of the first set of pixels
- *  @param[in] in1_y	1x5 matrix with y components of the second set of pixels
- *  @param[in] in1_u	1x5 matrix with u components of the second set of pixels
- *  @param[in] in1_v	1x5 matrix with v components of the second set of pixels
+ *  @param[in] in 1x3 matrix with pixels
+ *  @param[in] coeff 1x2 matrix with coefficients
  *
- *  @return absolute gradient
+ *  @return symmetric 3 tap filter output
  *
- * This function finds the absolute gradient between two sets of 1x5 YUV
- * vectors, that is basically |(Y1+U1+V1) - (Y2+U2+V2)|. Since addition
- * and subtraction operations could overflow, "avgrnd" is used instead of
- * "add" and "subhalfrnd" is used instead of "sub". Thus, all intermediate
- * results are rounded.
- */
+ * This function performs symmetric 3 tap filter over input pixels.
+ * Filter sum: p0*c1 + p1*c0 + p2*c1 = (p0 + p2)*c1 + p1*c0
+ * Input pixels are in Qn and coefficient c0 is in Qm and c1 is in Qn format,
+ * where n = ISP_VEC_ELEMBITS - 1 and m = ISP_VEC_ELEMBITS - 2 ( ie Q15 and Q14
+ * respectively for Broxton)
+ * To avoid double precision arithmetic input pixel sum is implemented using
+ * avgrnd, coefficient multiplication using qrmul and final sum using addsat
+ * Final sum is Qm format (ie Q14 for Broxton)
+*/
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
-gradabs1x5_yuv(s_1w_1x5_matrix in0_y,
-	    s_1w_1x5_matrix in0_u,
-	    s_1w_1x5_matrix in0_v,
-	    s_1w_1x5_matrix in1_y,
-	    s_1w_1x5_matrix in1_u,
-	    s_1w_1x5_matrix in1_v);
+fir1x3m_sym_nrm_approx(s_1w_1x3_matrix in,
+		       s_1w_1x2_matrix coeff);
 
 /** @brief Mean of 1x3 matrix
  *
@@ -631,6 +697,17 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w mean4x4m(
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w mean2x3m(
 	s_1w_2x3_matrix m);
 
+/** @brief Mean of 1x5 matrix
+ *
+ *  @param[in] m 1x5 matrix with pixels
+ *
+ *  @return mean of 1x5 matrix
+ *
+ * This function calculates the mean of 1x5 matrix with pixels
+ * with a factor of 8/5.
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w mean1x5m(s_1w_1x5_matrix m);
+
 /** @brief Mean of 1x6 matrix
  *
  *  @param[in] m 1x6 matrix with pixels
@@ -743,6 +820,19 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w sad5x5m(
 	s_1w_5x5_matrix a,
 	s_1w_5x5_matrix b);
 
+/** @brief Absolute gradient between two sets of 1x5 matrices
+ *
+ *  @param[in] m0 first set of 1x5 matrix with pixels
+ *  @param[in] m1 second set of 1x5 matrix with pixels
+ *
+ *  @return absolute gradient between two 1x5 matrices
+ *
+ * This function computes mean of two input 1x5 matrices and returns
+ * absolute difference between two mean values.
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+absgrad1x5m(s_1w_1x5_matrix m0, s_1w_1x5_matrix m1);
+
 /** @brief Bi-linear Interpolation optimized(approximate)
  *
  * @param[in] a input0
@@ -927,10 +1017,10 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H bma_output_14_2 OP_1w_asp_bma_14_2_32way(
  * @param[in] central_pix - central pixel plane
  * @param[in] src_plane - src pixel plane
  *
- * @return   Bilateral filter output pixel
+ * @return   Bilateral filter output
  *
  * This function implements, 7x7 single bilateral filter.
- * Output = sum(pixel * weight) / sum(weight)
+ * Output = {sum(pixel * weight), sum(weight)}
  * Where sum is summation over 7x7 block set.
  * weight = spatial weight * range weight
  * spatial weights are loaded from spatial_weight_lut depending on src pixel
@@ -942,7 +1032,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H bma_output_14_2 OP_1w_asp_bma_14_2_32way(
  * Piecewise linear approximation technique is used to compute range weight
  * It computes absolute difference between central pixel and 61 src pixels.
  */
-STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_single_bfa_7x7(
+STORAGE_CLASS_REF_VECTOR_FUNC_H bfa_7x7_output OP_1w_single_bfa_7x7(
 	bfa_weights weights,
 	tvector1w threshold,
 	tvector1w central_pix,
@@ -958,10 +1048,10 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_single_bfa_7x7(
  * @param[in] central_pix1 - 2nd central pixel plane
  * @param[in] src1_plane - 2nd pixel plane
  *
- * @return   Joint bilateral filter output pixel
+ * @return   Joint bilateral filter output
  *
  * This function implements, 7x7 joint bilateral filter.
- * Output = sum(pixel * weight) / sum(weight)
+ * Output = {sum(pixel * weight), sum(weight)}
  * Where sum is summation over 7x7 block set.
  * weight = spatial weight * range weight
  * spatial weights are loaded from spatial_weight_lut depending on src pixel
@@ -973,7 +1063,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_single_bfa_7x7(
  * Piecewise linear approximation technique is used to compute range weight
  * It computes absolute difference between central pixel and 61 src pixels.
  */
-STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_joint_bfa_7x7(
+STORAGE_CLASS_REF_VECTOR_FUNC_H bfa_7x7_output OP_1w_joint_bfa_7x7(
 	bfa_weights weights,
 	tvector1w threshold0,
 	tvector1w central_pix0,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func_types.h
index 69037ef..e4e19f9 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/host/ref_vector_func_types.h
@@ -1,28 +1,17 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
-
 #ifndef __REF_VECTOR_FUNC_TYPES_H_INCLUDED__
 #define __REF_VECTOR_FUNC_TYPES_H_INCLUDED__
 
@@ -43,6 +32,7 @@
 #define OUTPUT_SCALE_FACTOR 10
 #define SLOPE_A_RESOLUTION 10
 #define CONFIG_UNIT_LUT_SIZE_32 32 /*XCU works for ISP_NWAY = 32 */
+#define LXCU_LUT_SIZE      16
 
 #define ONE_IN_Q14 (1<<(NUM_BITS-2))
 #define Q29_TO_Q15_SHIFT_VAL (NUM_BITS-2)
@@ -92,28 +82,46 @@ typedef struct {
   tvector1w     v1 ;
 } s_1w_2x1_matrix;
 
+#define S_1W_2X1_MATRIX_DEFAULT ((s_1w_2x1_matrix)\
+	{ 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
 } s_1w_1x2_matrix;
 
+#define S_1W_1X2_MATRIX_DEFAULT ((s_1w_1x2_matrix)\
+	{ 0, 0 })
+
 typedef struct {
   tvector1w     v00  ;
   tvector1w     v01 ;
   tvector1w     v02 ;
 } s_1w_1x3_matrix;
 
+#define S_1W_1X3_MATRIX_DEFAULT ((s_1w_1x3_matrix)\
+	{ 0, 0, 0, })
+
 typedef struct {
   tvector1w v00; tvector1w v01; tvector1w v02;
   tvector1w v10; tvector1w v11; tvector1w v12;
 } s_1w_2x3_matrix;
 
+#define S_1W_2X3_MATRIX_DEFAULT ((s_1w_2x3_matrix)\
+	{ 0, 0, 0, \
+	  0, 0, 0 })
+
 typedef struct {
   tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ;
   tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ;
   tvector1w     v20  ; tvector1w     v21 ; tvector1w     v22  ;
 } s_1w_3x3_matrix;
 
+#define S_1W_3X3_MATRIX_DEFAULT ((s_1w_3x3_matrix)\
+	{ 0, 0, 0, \
+	  0, 0, 0, \
+	  0, 0, 0 })
+
 typedef struct {
   tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ;
   tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ;
@@ -121,6 +129,12 @@ typedef struct {
   tvector1w     v30  ; tvector1w     v31 ; tvector1w     v32  ;
 } s_1w_4x3_matrix;
 
+#define S_1W_4X3_MATRIX_DEFAULT ((s_1w_4x3_matrix)\
+	{ 0, 0, 0, \
+	  0, 0, 0, \
+	  0, 0, 0, \
+	  0, 0, 0 })
+
 typedef struct {
   tvector1w     v00 ;
   tvector1w     v01 ;
@@ -129,6 +143,9 @@ typedef struct {
   tvector1w     v04 ;
 } s_1w_1x5_matrix;
 
+#define S_1W_1X5_MATRIX_DEFAULT ((s_1w_1x5_matrix)\
+	{ 0, 0, 0, 0, 0 })
+
 typedef struct {
   tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ; tvector1w     v03 ; tvector1w     v04  ;
   tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ; tvector1w     v13 ; tvector1w     v14  ;
@@ -137,6 +154,13 @@ typedef struct {
   tvector1w     v40  ; tvector1w     v41 ; tvector1w     v42  ; tvector1w     v43 ; tvector1w     v44  ;
 } s_1w_5x5_matrix;
 
+#define S_1W_5X5_MATRIX_DEFAULT ((s_1w_5x5_matrix)\
+	{ 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0 })
+	
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -147,6 +171,9 @@ typedef struct {
 	tvector1w v06;
 } s_1w_1x7_matrix;
 
+#define S_1W_1X7_MATRIX_DEFAULT ((s_1w_1x7_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -159,6 +186,9 @@ typedef struct {
 	tvector1w v08;
 } s_1w_1x9_matrix;
 
+#define S_1W_1X9_MATRIX_DEFAULT ((s_1w_1x9_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -166,6 +196,9 @@ typedef struct {
 	tvector1w v03;
 } s_1w_1x4_matrix;
 
+#define S_1W_1X4_MATRIX ((s_1w_1x4_matrix)\
+	{ 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03;
 	tvector1w v10; tvector1w v11; tvector1w v12; tvector1w v13;
@@ -173,6 +206,12 @@ typedef struct {
 	tvector1w v30; tvector1w v31; tvector1w v32; tvector1w v33;
 } s_1w_4x4_matrix;
 
+#define S_1W_4X4_MATRIX_DEFAULT ((s_1w_4x4_matrix)\
+	{ 0, 0, 0, 0, \
+	  0, 0, 0, 0, \
+	  0, 0, 0, 0, \
+	  0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -182,6 +221,9 @@ typedef struct {
 	tvector1w v05;
 } s_1w_1x6_matrix;
 
+#define S_1W_1X6_MATRIX_DEFAULT ((s_1w_1x6_matrix)\
+	{ 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03; tvector1w v04; tvector1w v05;
 	tvector1w v10; tvector1w v11; tvector1w v12; tvector1w v13; tvector1w v14; tvector1w v15;
@@ -191,6 +233,14 @@ typedef struct {
 	tvector1w v50; tvector1w v51; tvector1w v52; tvector1w v53; tvector1w v54; tvector1w v55;
 } s_1w_6x6_matrix;
 
+#define S_1W_6X6_MATRIX_DEFAULT ((s_1w_6x6_matrix)\
+	{ 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03; tvector1w v04;
 	tvector1w v05; tvector1w v06; tvector1w v07; tvector1w v08;
@@ -212,6 +262,17 @@ typedef struct {
 	tvector1w v85; tvector1w v86; tvector1w v87; tvector1w v88;
 } s_1w_9x9_matrix;
 
+#define S_1W_9X9_MATRIX_DEFAULT ((s_1w_9x9_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03; tvector1w v04;
 	tvector1w v05; tvector1w v06;
@@ -229,6 +290,15 @@ typedef struct {
 	tvector1w v65; tvector1w v66;
 } s_1w_7x7_matrix;
 
+#define S_1W_7X7_MATRIX_DEFAULT ((s_1w_7x7_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v0_0;
 	tvector1w v0_1;
@@ -243,6 +313,9 @@ typedef struct {
 	tvector1w v0_10;
 } s_1w_1x11_matrix;
 
+#define S_1W_1X11_MATRIX_DEFAULT ((s_1w_1x11_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w x_cord[MAX_CONFIG_POINTS];
 	tvector1w slope[MAX_CONFIG_POINTS-1];
@@ -291,4 +364,9 @@ typedef struct {
 	tvector1w range_weight_lut[BFA_RW_LUT_SIZE];
 } bfa_weights;
 
+/* Return type for BFA BBBs */
+typedef struct {
+	tvector2w sop; /* weighted sum of pixels */
+	tvector1w sow; /* sum of weights */
+} bfa_7x7_output;
 #endif /* __REF_VECTOR_FUNC_TYPES_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/isys_irq.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/isys_irq.h
index c43c1d1..cf858bc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/isys_irq.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/isys_irq.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_ISYS_IRQ_H__
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/math_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/math_support.h
index e96a6f7..5f85dc3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/math_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/math_support.h
@@ -62,6 +62,16 @@
 #define CEIL_SHIFT(a, b)     (((a) + (1 << (b)) - 1)>>(b))
 #define CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
 
+
+/*To Find next power of 2 number from x */
+#define bit2(x)            ((x)      | ((x) >> 1))
+#define bit4(x)            (bit2(x)  | (bit2(x) >> 2))
+#define bit8(x)            (bit4(x)  | (bit4(x) >> 4))
+#define bit16(x)           (bit8(x)  | (bit8(x) >> 8))
+#define bit32(x)           (bit16(x) | (bit16(x) >> 16))
+#define NEXT_POWER_OF_2(x) (bit32(x-1) + 1)
+
+
 /* min and max should not be macros as they will evaluate their arguments twice.
    if you really need a macro (e.g. for CPP or for initializing an array)
    use MIN() and MAX(), otherwise use min() and max().
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h
index 6ba419a..1f991bb 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/type_support.h
@@ -50,6 +50,9 @@
 #endif
 
 #elif defined(__HIVECC)
+#ifndef PIPE_GENERATION
+#include <hive/cell_support.h> /* for HAVE_STDINT */
+#endif
 #define __INDIRECT_STDINT_INCLUDE
 #include <stdint/stdint.h>
 #include <stdbool.h>
@@ -67,7 +70,9 @@
 #define HOST_ADDRESS(x) (unsigned long)(x)
 
 #elif defined(__GNUC__)
+#ifndef __STDC_LIMIT_MACROS
 #define __STDC_LIMIT_MACROS 1
+#endif
 #include <stdint.h>
 #include <stdbool.h>
 #include <stddef.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/vector_ops.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/vector_ops.h
index 898098e..261f873 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/vector_ops.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/hive_isp_css_include/vector_ops.h
@@ -21,7 +21,7 @@
 
 #ifndef __INLINE_VECTOR_OPS__
 #define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_VECTOR_OPS_C 
+#define STORAGE_CLASS_VECTOR_OPS_C
 #include "vector_ops_public.h"
 #else  /* __INLINE_VECTOR_OPS__ */
 #define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_INLINE
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h
index 712964d..93d96d4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h
index d503758..1da741b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_acc_types.h
@@ -57,6 +57,7 @@ enum ia_css_fw_type {
 	ia_css_sp1_firmware,	/**< Firmware for the SP1 */
 #endif
 	ia_css_isp_firmware,	/**< Firmware for the ISP */
+	ia_css_bootloader_firmware, /**< Firmware for the BootLoader */
 	ia_css_acc_firmware		/**< Firmware for accelrations */
 };
 
@@ -314,6 +315,18 @@ struct ia_css_binary_xinfo {
 	CSS_ALIGN(struct ia_css_binary_xinfo *next, 8);
 };
 
+/** Structure describing the Bootloader (an ISP binary).
+ * It contains several address, either in ddr, isp_dmem or
+ * the entry function in icache.
+ */
+struct ia_css_bl_info {
+	uint32_t num_dma_cmds;	/**< Number of cmds sent by CSS */
+	uint32_t dma_cmd_list;	/**< Dma command list sent by CSS */
+	uint32_t sw_state;	/**< Polled from css */
+	/* Entry functions */
+	uint32_t bl_entry;	/**< The SP entry function */
+};
+
 /** Structure describing the SP binary.
  * It contains several address, either in ddr, sp_dmem or
  * the entry function in pmem.
@@ -371,6 +384,7 @@ union ia_css_fw_union {
 #if defined(IS_ISP_2500_SYSTEM)
 	struct ia_css_sp_info		sp1;  /**< SP1 info */
 #endif
+	struct ia_css_bl_info           bl;  /**< Bootloader info */
 	struct ia_css_acc_info		acc; /**< Accelerator info */
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h
index 0956d94..572e4e5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_err.h
@@ -41,23 +41,6 @@ enum ia_css_err {
 	IA_CSS_ERR_NOT_SUPPORTED
 };
 
-/** Unrecoverable FW errors. This enum contains a value for each
- * error that the SP FW could encounter.
- */
-enum ia_css_fw_err {
-	IA_CSS_FW_SUCCESS,
-	IA_CSS_FW_ERR_TAGGER_FULL,
-	IA_CSS_FW_ERR_NO_VBUF_HANDLE,
-	IA_CSS_FW_ERR_BUFFER_QUEUE_FULL,
-	IA_CSS_FW_ERR_INVALID_QUEUE,
-	IA_CSS_FW_ERR_INVALID_DMA_CHANNEL,
-	IA_CSS_FW_ERR_CIRCBUF_EMPTY,
-	IA_CSS_FW_ERR_CIRCBUF_FULL,
-	IA_CSS_FW_ERR_TOKEN_MAP_RECEIVE,
-	IA_CSS_FW_ERR_INVALID_PORT,
-	IA_CSS_FW_ERR_OUT_OF_SP_DMEM,
-};
-
 /** FW warnings. This enum contains a value for each warning that
  * the SP FW could indicate potential performance issue
  */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_event_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_event_public.h
index ae3bfbf..fb02799 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_event_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_event_public.h
@@ -63,18 +63,16 @@ enum ia_css_event_type {
              32-bit timer value from the SP */
 	IA_CSS_EVENT_TYPE_PORT_EOF			= 1 << 13,
 	/**< End Of Frame event, sent when in buffered sensor mode. */
-	IA_CSS_EVENT_TYPE_FW_ERROR			= 1 << 14,
-	/**< @deprecated{Unrecoverable error encounter by FW } */
-	IA_CSS_EVENT_TYPE_FW_WARNING			= 1 << 15,
+	IA_CSS_EVENT_TYPE_FW_WARNING			= 1 << 14,
 	/**< Performance warning encounter by FW */
-	IA_CSS_EVENT_TYPE_FW_ASSERT			= 1 << 16,
+	IA_CSS_EVENT_TYPE_FW_ASSERT			= 1 << 15,
 	/**< Assertion hit by FW */
 };
 
 #define IA_CSS_EVENT_TYPE_NONE 0
 
 /** IA_CSS_EVENT_TYPE_ALL is a mask for all pipe related events.
- * The other events (such as PORT_EOF and FW_ERROR) cannot be enabled/disabled
+ * The other events (such as PORT_EOF) cannot be enabled/disabled
  * and are hence excluded from this macro.
  */
 #define IA_CSS_EVENT_TYPE_ALL \
@@ -124,8 +122,6 @@ struct ia_css_event {
 	uint32_t               fw_handle;
 	/**< Firmware Handle for ACC_STAGE_COMPLETE event (not valid for other
 	     events). */
-	enum ia_css_fw_err     fw_error;
-	/**< @deprecated{This field is deprecated since ERROR events are no longer sent and will be removed. } */
 	enum ia_css_fw_warning fw_warning;
 	/**< Firmware warning code, only for WARNING events. */
 	uint8_t                fw_assert_module_id;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h
index d28e15d..9d33f38 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_host_data.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe.h
index 9c62f91..a05fd0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe.h
@@ -56,6 +56,7 @@ struct ia_css_capture_settings {
 	struct ia_css_binary post_isp_binary;
 	struct ia_css_binary capture_pp_binary;
 	struct ia_css_binary vf_pp_binary;
+	struct ia_css_binary capture_ldc_binary;
 	struct ia_css_binary *yuv_scaler_binary;
 	struct ia_css_frame *delay_frames[MAX_NUM_VIDEO_DELAY_FRAMES];
 	bool *is_output_stage;
@@ -72,6 +73,7 @@ struct ia_css_capture_settings {
 	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* post_isp_binary */\
 	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* capture_pp_binary */\
 	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* vf_pp_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* capture_ldc_binary */\
 	NULL,				/* yuv_scaler_binary */ \
 	{ NULL },			/* delay_frames[ref_frames] */ \
 	NULL,				/* is_output_stage */ \
@@ -128,6 +130,8 @@ struct ia_css_yuvpp_settings {
 	0,					/* num_output */ \
 }
 
+struct osys_object;
+
 struct ia_css_pipe {
 	/* TODO: Remove stop_requested and use stop_requested in the pipeline */
 	bool                            stop_requested;
@@ -160,6 +164,8 @@ struct ia_css_pipe {
 		struct ia_css_capture_settings capture;
 		struct ia_css_yuvpp_settings yuvpp;
 	} pipe_settings;
+	hrt_vaddress scaler_pp_lut;
+	struct osys_object *osys_obj;
 
 	/* This number is unique per pipe each instance of css. This number is
 	 * reused as pipeline number also. There is a 1-1 mapping between pipe_num
@@ -195,6 +201,8 @@ struct ia_css_pipe {
 	{ NULL },				/* continuous_frames */ \
 	{ NULL },				/* cont_md_buffers */ \
 	{ IA_CSS_DEFAULT_PREVIEW_SETTINGS },	/* pipe_settings */ \
+	0,					/* scaler_pp_lut */ \
+	NULL,					/* osys object */ \
 	PIPE_ENTRY_EMPTY_TOKEN,			/* pipe_num */\
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe_public.h
index 0d66b24..254e83d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_pipe_public.h
@@ -50,33 +50,15 @@ enum ia_css_pipe_mode {
 /* Temporary define  */
 #define IA_CSS_PIPE_MODE_NUM (IA_CSS_PIPE_MODE_YUVPP + 1)
 
-
-/**
- * Enumeration of pipe versions.
- * the order should match with definition in sh_css_defs.h
- */
-/*enum ia_css_pipe_version {*/
-/*	IA_CSS_PIPE_VERSION_1 = 1,*/		/**< ISP1.0 pipe */
-/*	IA_CSS_PIPE_VERSION_2_2 = 2,*/		/**< ISP2.2 pipe */
-/*	IA_CSS_PIPE_VERSION_2_6_1 = 3*/		/**< ISP2.6.1 pipe */
-/*};*/
-
 /**
  * Enumeration of pipe versions.
  * the order should match with definition in sh_css_defs.h
  */
-#define IA_CSS_PIPE_VERSION_1 1
-/**
- * Enumeration of pipe versions.
- * the order should match with definition in sh_css_defs.h
- */
-#define IA_CSS_PIPE_VERSION_2_2 2
-/**
- * Enumeration of pipe versions.
- * the order should match with definition in sh_css_defs.h
- */
-#define IA_CSS_PIPE_VERSION_2_6_1 3
-
+enum ia_css_pipe_version {
+	IA_CSS_PIPE_VERSION_1 = 1,		/**< ISP1.0 pipe */
+	IA_CSS_PIPE_VERSION_2_2 = 2,		/**< ISP2.2 pipe */
+	IA_CSS_PIPE_VERSION_2_6_1 = 3		/**< ISP2.6.1 pipe */
+};
 
 /**
  * Pipe configuration structure.
@@ -84,7 +66,7 @@ enum ia_css_pipe_mode {
 struct ia_css_pipe_config {
 	enum ia_css_pipe_mode mode;
 	/**< mode, indicates which mode the pipe should use. */
-	unsigned int isp_pipe_version;
+	enum ia_css_pipe_version isp_pipe_version;
 	/**< pipe version, indicates which imaging pipeline the pipe should use. */
 	struct ia_css_resolution input_effective_res;
 	/**< input effective resolution */
@@ -122,6 +104,10 @@ struct ia_css_pipe_config {
 	bool enable_dpc;
 	/**< Disabling "Defect Pixel Correction" for a pipeline, if this is set
 	     to false. In some use cases this provides better performance. */
+	bool enable_vfpp_bci;
+	/**< Enabling BCI mode will cause yuv_scale binary to be picked up
+	     instead of vf_pp. This only applies to viewfinder post
+	     processing stages. */
 	struct ia_css_isp_config *p_isp_config;
 	/**< Pointer to ISP configuration */
 	struct ia_css_resolution gdc_in_buffer_res;
@@ -153,6 +139,7 @@ struct ia_css_pipe_config {
 	-1,					/* acc_num_execs */ \
 	false,					/* enable_dz */ \
 	false,					/* enable_dpc */ \
+	false,					/* enable_vfpp_bci */ \
 	NULL,					/* p_isp_config */\
 	{ 0, 0 },				/* gdc_in_buffer_res */ \
 	{ 0, 0 }				/* gdc_in_buffer_offset */ \
@@ -486,4 +473,32 @@ ia_css_pipe_get_qos_ext_state (struct ia_css_pipe *pipe,
 void
 ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
 			     struct ia_css_isp_config *config);
+
+/** @brief Set the scaler lut on this pipe. A copy of lut is made in the inuit
+ *         address space. So the LUT can be freed by caller.
+ * @param[in]  pipe        Pipe handle.
+ * @param[in]  lut         Look up tabel
+ *
+ * @return
+ * IA_CSS_SUCCESS 			: Success
+ * IA_CSS_ERR_INVALID_ARGUMENTS		: Invalid Parameters
+ *
+ * Note:
+ * 1) Note that both GDC's are programmed with the same table.
+ * 2) Current implementation ignores the pipe and overrides the
+ *    global lut. This will be fixed in the future
+ * 3) This function must be called before stream start
+ * 4) For 2500, the function is a no-op.
+ *
+ */
+enum ia_css_err
+ia_css_pipe_set_bci_scaler_lut( struct ia_css_pipe *pipe,
+				const void *lut);
+/** @brief Checking of DVS statistics ability
+ * @param[in]	pipe_info	The pipe info.
+ * @return		true - has DVS statistics ability
+ * 			false - otherwise
+ */
+bool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info);
+
 #endif /* __IA_CSS_PIPE_PUBLIC_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_stream_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_stream_public.h
index 7a5975e..357395c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_stream_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_stream_public.h
@@ -104,16 +104,8 @@ struct ia_css_stream_config {
 	unsigned int sensor_binning_factor; /**< Binning factor used by sensor
 						 to produce image data. This is
 						 used for shading correction. */
-	/** The next field is only for backward compatibility for CSS API 2.0
-	 *  TO BE REMOVED when all drivers move to CSS API 2.1
-	 *  Effectively below two lines are implemented internally:
-	 *  if ( pixels_per_clock == 0 )
-	 *	pixels_per_clock = two_pixels_per_clock ? 2 : 1;
-	 * @deprecated{Replaced by pixels_per_clock for CSS API 2.1}
-	 */
-	bool two_pixels_per_clock; /**< Enable/disable 2 pixels per clock */
 	unsigned int pixels_per_clock; /**< Number of pixels per clock, which can be
-					    1, 2 or 4. 0 is used as legacy support. */
+					    1, 2 or 4. */
 	bool online; /**< offline will activate RAW copy on SP, use this for
 			  continuous capture. */
 		/* ISYS2401 usage: ISP receives data directly from sensor, no copy. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h
index a7446a8..a940673 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
@@ -61,6 +61,9 @@
 #include "isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h"
 #include "isp/kernels/output/output_1.0/ia_css_output_types.h"
 
+#define IA_CSS_DVS_STAT_GRID_INFO_SUPPORTED
+/**< Should be removed after Driver adaptation will be done */
+
 #define IA_CSS_VERSION_MAJOR    2
 #define IA_CSS_VERSION_MINOR    0
 #define IA_CSS_VERSION_REVISION 2
@@ -234,7 +237,8 @@ struct ia_css_grid_info {
 	/** @}*/
 
 	struct ia_css_3a_grid_info  s3a_grid; /**< 3A grid info */
-	struct ia_css_dvs_grid_info dvs_grid; /**< DVS grid info */
+	union ia_css_dvs_grid_u dvs_grid;
+		/**< All types of DVS statistics grid info union */
 
 	enum ia_css_vamem_type vamem_type;
 };
@@ -332,6 +336,7 @@ struct ia_css_capture_config {
 	enum ia_css_capture_mode mode; /**< Still capture mode */
 	uint32_t enable_xnr;	       /**< Enable/disable XNR */
 	uint32_t enable_raw_output;
+	bool enable_capture_pp_bli;    /**< Enable capture_pp_bli mode */
 };
 
 /** default settings for ia_css_capture_config structs */
@@ -339,7 +344,8 @@ struct ia_css_capture_config {
 { \
 	IA_CSS_CAPTURE_MODE_PRIMARY,	/* mode (capture) */ \
 	false,				/* enable_xnr */ \
-	false				/* enable_raw_output */ \
+	false,				/* enable_raw_output */ \
+	false				/* enable_capture_pp_bli */ \
 }
 
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h
index 7c48c58..4db742e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/ia_css_version_data.h
@@ -22,7 +22,7 @@
 #define __IA_CSS_VERSION_DATA_H
 
 
-#define CSS_VERSION_STRING "REL:20150131_05.6_0526; API:2.1.11.2; GIT:irci_20150130_1500__5ef052#5ef052995cc2fc8b1d29fa5ed307c5f5bb2d73a7; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
+#define CSS_VERSION_STRING "REL:20150303_10.2_1549; API:2.1.14.18; GIT:irci_20150303_0640_#2f52b0e481d6fb566cc2a43e52e1246fd4c7f865; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
 
 
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
index df88292..3af107d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
@@ -20,6 +20,19 @@
 #endif
 #include <assert_support.h>
 
+#define BNLM_DIV_LUT_SIZE	(12)
+static const int32_t div_lut_nearests[BNLM_DIV_LUT_SIZE] = {
+	0, 454, 948, 1484, 2070, 2710, 3412, 4184, 5035, 5978, 7025, 8191
+};
+
+static const int32_t div_lut_slopes[BNLM_DIV_LUT_SIZE] = {
+	-7760, -6960, -6216, -5536, -4912, -4344, -3832, -3360, -2936, -2552, -2208, -2208
+};
+
+static const int32_t div_lut_intercepts[BNLM_DIV_LUT_SIZE] = {
+	8184, 7752, 7336, 6928, 6536, 6152, 5776, 5416, 5064, 4728, 4408, 4408
+};
+
 /* Encodes a look-up table from BNLM public parameters to vmem parameters.
  * Input:
  *	lut	:	bnlm_lut struct containing encoded vmem parameters look-up table
@@ -30,19 +43,21 @@
 static inline void
 bnlm_lut_encode(struct bnlm_lut *lut, const int32_t *lut_thr, const int32_t *lut_val, const uint32_t lut_size)
 {
-	int blk, i;
-	const int block_size = 16;
-	const int total_blocks = (ISP_VEC_NELEMS / block_size);
+	uint32_t blk, i;
+	const uint32_t block_size = 16;
+	const uint32_t total_blocks = (ISP_VEC_NELEMS / block_size);
 
 	/* Create VMEM LUTs from the threshold and value arrays.
 	 *
+	 * Min size of the LUT is 2 entries.
+	 *
 	 * Max size of the LUT is 16 entries, so that the LUT can fit into a
 	 * single group of 16 elements inside a vector.
 	 * Then these elements are copied into other groups inside the same
 	 * vector. If the LUT size is less than 16, then remaining elements are
 	 * set to 0.
 	 * */
-	assert(lut_size <= block_size);
+	assert((lut_size >= 2) && (lut_size <= block_size));
 	/* array lut_thr has (lut_size-1) entries */
 	for (i = 0; i < lut_size-2; i++) {
 		/* Check if the lut_thr is monotonically increasing */
@@ -82,8 +97,8 @@ ia_css_bnlm_vmem_encode(
 			const struct ia_css_bnlm_config *from,
 			size_t size)
 {
-	(void)size;
 	int i;
+	(void)size;
 
 	/* Initialize LUTs in VMEM parameters */
 	bnlm_lut_encode(&to->mu_root_lut, from->mu_root_lut_thr, from->mu_root_lut_val, 16);
@@ -98,17 +113,22 @@ ia_css_bnlm_vmem_encode(
 
 	/* Initialize arrays in VMEM parameters */
 	memset(to->nl_th, 0, sizeof(to->nl_th));
-	memcpy(to->nl_th, from->nl_th, sizeof(from->nl_th));
+	to->nl_th[0][0] = from->nl_th[0];
+	to->nl_th[0][1] = from->nl_th[1];
+	to->nl_th[0][2] = from->nl_th[2];
 
 	memset(to->match_quality_max_idx, 0, sizeof(to->match_quality_max_idx));
-	memcpy(to->match_quality_max_idx, from->match_quality_max_idx, sizeof(from->match_quality_max_idx));
+	to->match_quality_max_idx[0][0] = from->match_quality_max_idx[0];
+	to->match_quality_max_idx[0][1] = from->match_quality_max_idx[1];
+	to->match_quality_max_idx[0][2] = from->match_quality_max_idx[2];
+	to->match_quality_max_idx[0][3] = from->match_quality_max_idx[3];
 
-	/* ToDo: Clean up below parameters using new implementation from ATE */
-	memset(&to->exp_lut, 0, sizeof(to->exp_lut));
-	memset(to->div_lut_thr, 0, sizeof(to->div_lut_thr));
-	memset(to->div_lut_nearests, 0, sizeof(to->div_lut_nearests));
-	memset(to->div_lut_slopes, 0, sizeof(to->div_lut_slopes));
+	bnlm_lut_encode(&to->div_lut, div_lut_nearests, div_lut_slopes, BNLM_DIV_LUT_SIZE);
 	memset(to->div_lut_intercepts, 0, sizeof(to->div_lut_intercepts));
+	for(i = 0; i < BNLM_DIV_LUT_SIZE; i++) {
+		to->div_lut_intercepts[0][i] = div_lut_intercepts[i];
+	}
+
 	memset(to->power_of_2, 0, sizeof(to->power_of_2));
 	for (i = 0; i < (ISP_VEC_ELEMBITS-1); i++) {
 		to->power_of_2[0][i] = 1 << i;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
index 85095ba..2f4be43 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
@@ -36,13 +36,10 @@ struct bnlm_vmem_params {
 	struct bnlm_lut nl_2_lut;
 	struct bnlm_lut nl_3_lut;
 
-	/* ToDo: Remove this after implementing coefficients based aprroximtaion */
-	struct bnlm_lut exp_lut;
-	/* ToDo: Remove div tables after using new ATE implementation */
-	VMEM_ARRAY(div_lut_thr, ISP_VEC_NELEMS);
-	VMEM_ARRAY(div_lut_nearests, ISP_VEC_NELEMS);
-	VMEM_ARRAY(div_lut_slopes, ISP_VEC_NELEMS);
+	/* LUTs used for division approximiation */
+	struct bnlm_lut div_lut;
 	VMEM_ARRAY(div_lut_intercepts, ISP_VEC_NELEMS);
+
 	/* 240x does not have an ISP instruction to left shift each element of a
 	 * vector by different shift value. Hence it will be simulated by multiplying
 	 * the elements by required 2^shift. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_state.h
new file mode 100644
index 0000000..79cce0e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_state.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_BNLM_STATE_H
+#define __IA_CSS_BNLM_STATE_H
+
+
+#include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
+#include "bnlm.isp.h"
+
+struct bnlm_vmem_state {
+	/* State buffers required for BNLM */
+	VMEM_ARRAY(buf[BNLM_STATE_BUF_HEIGHT], BNLM_STATE_BUF_WIDTH*ISP_NWAY);
+};
+
+
+
+#endif /* __IA_CSS_BNLM_STATE_H */
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
index 6ab6a95..219fb83 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
@@ -15,62 +15,92 @@
 #ifndef __IA_CSS_BNLM_TYPES_H
 #define __IA_CSS_BNLM_TYPES_H
 
+/** @file
+* CSS-API header file for Bayer Non-Linear Mean parameters.
+*/
+
 #include "type_support.h" /* int32_t */
 
-/**
+/** Bayer Non-Linear Mean configuration
+ *
  * \brief BNLM public parameters.
  * \details Struct with all parameters for the BNLM kernel that can be set
  * from the CSS API.
+ *
+ * ISP2.6.1: BNLM is used.
  */
 struct ia_css_bnlm_config {
-	bool rad_enable; /* Enable a radial dependency in a weight calculation */
-	int32_t rad_x_origin; /* Initial x coordinate for a radius calculation */
-	int32_t rad_y_origin; /* Initial x coordinate for a radius calculation */
+	bool		rad_enable;	/**< Enable a radial dependency in a weight calculation */
+	int32_t		rad_x_origin;	/**< Initial x coordinate for a radius calculation */
+	int32_t		rad_y_origin;	/**< Initial x coordinate for a radius calculation */
 	/* a threshold for average of weights if this < Th, do not denoise pixel */
-	int32_t avg_min_th;
+	int32_t		avg_min_th;
 	/* minimum weight for denoising if max < th, do not denoise pixel */
-	int32_t max_min_th;
+	int32_t		max_min_th;
 
-	/* Coefficient for approximation, in the form of (1 + x / N)^N,
+	/**@{*/
+	/** Coefficient for approximation, in the form of (1 + x / N)^N,
 	 * that fits the first-order exp() to default exp_lut in BNLM sheet
 	 * */
-	int32_t exp_coeff_a;
-	uint32_t exp_coeff_b;
-	int32_t exp_coeff_c;
-	uint32_t exp_exponent;
+	int32_t		exp_coeff_a;
+	uint32_t	exp_coeff_b;
+	int32_t		exp_coeff_c;
+	uint32_t	exp_exponent;
+	/**@}*/
+
+	int32_t nl_th[3];	/**< Detail thresholds */
 
-	int32_t nl_th[3]; /* detail thresholds */
-	/* Index for n-th maximum candidate weight for each detail group */
+	/** Index for n-th maximum candidate weight for each detail group */
 	int32_t match_quality_max_idx[4];
 
-	/* A lookup table for 1/sqrt(1+mu) approximation */
+	/**@{*/
+	/** A lookup table for 1/sqrt(1+mu) approximation */
 	int32_t mu_root_lut_thr[15];
 	int32_t mu_root_lut_val[16];
-	/* A lookup table for SAD normalization */
+	/**@}*/
+	/**@{*/
+	/** A lookup table for SAD normalization */
 	int32_t sad_norm_lut_thr[15];
 	int32_t sad_norm_lut_val[16];
-	/* A lookup table that models a weight's dependency on textures */
+	/**@}*/
+	/**@{*/
+	/** A lookup table that models a weight's dependency on textures */
 	int32_t sig_detail_lut_thr[15];
 	int32_t sig_detail_lut_val[16];
-	/* A lookup table that models a weight's dependency on a pixel's radial distance */
+	/**@}*/
+	/**@{*/
+	/** A lookup table that models a weight's dependency on a pixel's radial distance */
 	int32_t sig_rad_lut_thr[15];
 	int32_t sig_rad_lut_val[16];
-	/* A lookup table to control denoise power depending on a pixel's radial distance */
+	/**@}*/
+	/**@{*/
+	/** A lookup table to control denoise power depending on a pixel's radial distance */
 	int32_t rad_pow_lut_thr[15];
 	int32_t rad_pow_lut_val[16];
-	/* Non linear transfer functions to calculate the blending coefficient depending on detail group */
-	/* detail group 0 */
+	/**@}*/
+	/**@{*/
+	/** Non linear transfer functions to calculate the blending coefficient depending on detail group */
+	/** detail group 0 */
+	/**@{*/
 	int32_t nl_0_lut_thr[15];
 	int32_t nl_0_lut_val[16];
-	/* detail group 1 */
+	/**@}*/
+	/**@{*/
+	/** detail group 1 */
 	int32_t nl_1_lut_thr[15];
 	int32_t nl_1_lut_val[16];
-	/* detail group 2 */
+	/**@}*/
+	/**@{*/
+	/** detail group 2 */
 	int32_t nl_2_lut_thr[15];
 	int32_t nl_2_lut_val[16];
-	/* detail group 3 */
+	/**@}*/
+	/**@{*/
+	/** detail group 3 */
 	int32_t nl_3_lut_thr[15];
 	int32_t nl_3_lut_val[16];
+	/**@}*/
+	/**@}*/
 };
 
 #endif /* __IA_CSS_BNLM_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
index da4d0c4..a7de6ec 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
@@ -84,7 +84,7 @@ ia_css_bnr2_2_encode(
 
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_bnr2_2_debug_trace(
+ia_css_bnr2_2_debug_dtrace(
 	const struct ia_css_bnr2_2_config *bnr,
 	unsigned level)
 {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
index d7a7324..59349c1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
@@ -28,7 +28,7 @@ ia_css_bnr2_2_encode(
 
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_bnr2_2_debug_trace(
+ia_css_bnr2_2_debug_dtrace(
 	const struct ia_css_bnr2_2_config *config,
 	unsigned level);
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
index 7e8b4b6..be80f70 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
@@ -15,42 +15,57 @@
 #ifndef __IA_CSS_BNR2_2_TYPES_H
 #define __IA_CSS_BNR2_2_TYPES_H
 
+/** @file
+* CSS-API header file for Bayer Noise Reduction parameters.
+*/
+
 #include "type_support.h" /* int32_t */
 
-/**
+/** Bayer Noise Reduction 2.2 configuration
+ *
  * \brief BNR2_2 public parameters.
  * \details Struct with all parameters for the BNR2.2 kernel that can be set
  * from the CSS API.
+ *
+ * ISP2.6.1: BNR2.2 is used.
  */
 struct ia_css_bnr2_2_config {
-	/* Directional variance gain for R/G/B components in dark region */
+	/**@{*/
+	/** Directional variance gain for R/G/B components in dark region */
 	int32_t d_var_gain_r;
 	int32_t d_var_gain_g;
 	int32_t d_var_gain_b;
-	/* Slope of Directional variance gain between dark and bright region */
+	/**@}*/
+	/**@{*/
+	/** Slope of Directional variance gain between dark and bright region */
 	int32_t d_var_gain_slope_r;
 	int32_t d_var_gain_slope_g;
 	int32_t d_var_gain_slope_b;
-	/* Non-Directional variance gain for R/G/B components in dark region */
+	/**@}*/
+	/**@{*/
+	/** Non-Directional variance gain for R/G/B components in dark region */
 	int32_t n_var_gain_r;
 	int32_t n_var_gain_g;
 	int32_t n_var_gain_b;
-	/* Slope of Non-Directional variance gain between dark and bright region */
+	/**@}*/
+	/**@{*/
+	/** Slope of Non-Directional variance gain between dark and bright region */
 	int32_t n_var_gain_slope_r;
 	int32_t n_var_gain_slope_g;
 	int32_t n_var_gain_slope_b;
+	/**@}*/
 
-	int32_t dir_thres;		/* Threshold for directional filtering */
-	int32_t dir_thres_w;		/* Threshold width for directional filtering */
-	int32_t var_offset_coef;	/* Variance offset coefficient */
-	int32_t dir_gain;		/* Gain for directional coefficient */
-	int32_t detail_gain;		/* Gain for low contrast texture control */
-	int32_t detail_gain_divisor;	/* Gain divisor for low contrast texture control */
-	int32_t detail_level_offset;	/* Bias value for low contrast texture control */
-	int32_t d_var_th_min;		/* Minimum clipping value for directional variance*/
-	int32_t d_var_th_max;		/* Maximum clipping value for diretional variance*/
-	int32_t n_var_th_min;		/* Minimum clipping value for non-directional variance*/
-	int32_t n_var_th_max;		/* Maximum clipping value for non-directional variance*/
+	int32_t dir_thres;		/**< Threshold for directional filtering */
+	int32_t dir_thres_w;		/**< Threshold width for directional filtering */
+	int32_t var_offset_coef;	/**< Variance offset coefficient */
+	int32_t dir_gain;		/**< Gain for directional coefficient */
+	int32_t detail_gain;		/**< Gain for low contrast texture control */
+	int32_t detail_gain_divisor;	/**< Gain divisor for low contrast texture control */
+	int32_t detail_level_offset;	/**< Bias value for low contrast texture control */
+	int32_t d_var_th_min;		/**< Minimum clipping value for directional variance*/
+	int32_t d_var_th_max;		/**< Maximum clipping value for diretional variance*/
+	int32_t n_var_th_min;		/**< Minimum clipping value for non-directional variance*/
+	int32_t n_var_th_max;		/**< Maximum clipping value for non-directional variance*/
 };
 
 #endif /* __IA_CSS_BNR2_2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
index 059a777..6df6c2b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
@@ -38,17 +38,17 @@ struct ia_css_cnr_config {
 	uint16_t coring_v;	/**< Coring level of V.
 				u0.13, [0,8191], default/ineffective 0 */
 	uint16_t sense_gain_vy;	/**< Sensitivity of horizontal edge of Y.
-				u13.0, [0,8191], default 100, ineffective 0 */
+				u13.0, [0,8191], default 100, ineffective 8191 */
 	uint16_t sense_gain_vu;	/**< Sensitivity of horizontal edge of U.
-				u13.0, [0,8191], default 100, ineffective 0 */
+				u13.0, [0,8191], default 100, ineffective 8191 */
 	uint16_t sense_gain_vv;	/**< Sensitivity of horizontal edge of V.
-				u13.0, [0,8191], default 100, ineffective 0 */
+				u13.0, [0,8191], default 100, ineffective 8191 */
 	uint16_t sense_gain_hy;	/**< Sensitivity of vertical edge of Y.
-				u13.0, [0,8191], default 50, ineffective 0 */
+				u13.0, [0,8191], default 50, ineffective 8191 */
 	uint16_t sense_gain_hu;	/**< Sensitivity of vertical edge of U.
-				u13.0, [0,8191], default 50, ineffective 0 */
+				u13.0, [0,8191], default 50, ineffective 8191 */
 	uint16_t sense_gain_hv;	/**< Sensitivity of vertical edge of V.
-				u13.0, [0,8191], default 50, ineffective 0 */
+				u13.0, [0,8191], default 50, ineffective 8191 */
 };
 
 #endif /* __IA_CSS_CNR2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
index 32f2433..45e1ea8 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
@@ -19,6 +19,10 @@
 #include "ia_css_isp_configs.h"
 #include "isp.h"
 
+static const struct ia_css_copy_output_configuration default_config = {
+	.enable = false,
+};
+
 void
 ia_css_copy_output_config(
 	struct sh_css_isp_copy_output_isp_config      *to,
@@ -34,8 +38,10 @@ ia_css_copy_output_configure(
 	const struct ia_css_binary     *binary,
 	bool enable)
 {
-	const struct ia_css_copy_output_configuration config =
-		{ enable };
+	struct ia_css_copy_output_configuration config = default_config;
+
+	config.enable = enable;
+
 	ia_css_configure_copy_output(binary, &config);
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
index 75daff5..9290522 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
@@ -21,6 +21,10 @@
 #include "isp.h"
 #include "ia_css_crop.host.h"
 
+static const struct ia_css_crop_configuration default_config = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
 void
 ia_css_crop_encode(
 	struct sh_css_isp_crop_isp_params *to,
@@ -52,7 +56,9 @@ ia_css_crop_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_crop_configuration config =
-		{ info };
+	struct ia_css_crop_configuration config = default_config;
+
+	config.info = info;
+
 	ia_css_configure_crop(binary, &config);
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
index 4f6384f..c8b4b33 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #include "ia_css_types.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
index c53399e..3733aee 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_CTC2_HOST_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
index 4cc81c6..c66e823 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_CTC2_PARAM_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
index 0afe822..7b75f01 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_CTC2_TYPES_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
index 46e8bbc..126d0d3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
@@ -18,7 +18,11 @@
 #include "type_support.h"
 
 #include "vmem.h"
+#if NEED_BDS_OTHER_THAN_1_00
+#define MAX_VECTORS_PER_DP_LINE MAX_VECTORS_PER_BUF_INPUT_LINE
+#else
 #define MAX_VECTORS_PER_DP_LINE MAX_VECTORS_PER_BUF_LINE
+#endif
 
 /* DP (Defect Pixel Correction) */
 struct sh_css_isp_dp_vmem_state {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
index c98ccf0..bc14b85 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
@@ -42,3 +42,24 @@ ia_css_dpc2_encode(
 	to->wb_gain_gb = from->wb_gain_gb;
 }
 
+/* TODO: AM: This needs a proper implementation. */
+void
+ia_css_init_dpc2_state(
+	void *state,
+	size_t size)
+{
+	(void)state;
+	(void)size;
+}
+
+#ifndef IA_CSS_NO_DEBUG
+/* TODO: AM: This needs a proper implementation. */
+void
+ia_css_dpc2_debug_dtrace(
+	const struct ia_css_dpc2_config *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.h
index c9c5c16..641564b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2.host.h
@@ -25,4 +25,16 @@ ia_css_dpc2_encode(
 	const struct ia_css_dpc2_config *from,
 	size_t size);
 
+void
+ia_css_init_dpc2_state(
+	void *state,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_dpc2_debug_dtrace(
+	const struct ia_css_dpc2_config *config,
+	unsigned level);
+#endif
+
 #endif /* __IA_CSS_DPC2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c
index ab02137..c102601 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c
@@ -12,3 +12,15 @@
  * more details.
  */
 
+#include "ia_css_dpc2_types.h"
+
+const struct ia_css_dpc2_config default_dpc2_config = {
+	.metric1 = 1638,
+	.metric2 =  128,
+	.metric3 = 1638,
+	.wb_gain_gr = 512,
+	.wb_gain_r  = 512,
+	.wb_gain_b  = 512,
+	.wb_gain_gb = 512
+};
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h
index ab02137..a1527ce 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h
@@ -12,3 +12,12 @@
  * more details.
  */
 
+#ifndef __IA_CSS_DPC2_DEFAULT_HOST_H
+#define __IA_CSS_DPC2_DEFAULT_HOST_H
+
+#include "ia_css_dpc2_types.h"
+
+extern const struct ia_css_dpc2_config default_dpc2_config;
+
+#endif /* __IA_CSS_DPC2_DEFAULT_HOST_H */
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
index 4034328..b2c9741 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
@@ -15,14 +15,35 @@
 #ifndef __IA_CSS_DPC2_TYPES_H
 #define __IA_CSS_DPC2_TYPES_H
 
+/** @file
+* CSS-API header file for Defect Pixel Correction 2 (DPC2) parameters.
+*/
+
 #include "type_support.h"
+
+/**@{*/
+/** Floating point constants for different metrics. */
 #define METRIC1_ONE_FP	(1<<12)
 #define METRIC2_ONE_FP	(1<<5)
 #define METRIC3_ONE_FP	(1<<12)
 #define WBGAIN_ONE_FP	(1<<9)
+/**@}*/
 
-
+/**@{*/
+/** Defect Pixel Correction 2 configuration.
+ *
+ * \brief DPC2 public parameters.
+ * \details Struct with all parameters for the Defect Pixel Correction 2
+ * kernel that can be set from the CSS API.
+ *
+ * ISP block: DPC1 (DPC after WB)
+ *            DPC2 (DPC before WB)
+ * ISP1: DPC1 is used.
+ * ISP2: DPC2 is used.
+ *
+ */
 struct ia_css_dpc2_config {
+	/**@{*/
 	int32_t metric1;
 	int32_t metric2;
 	int32_t metric3;
@@ -30,7 +51,9 @@ struct ia_css_dpc2_config {
 	int32_t wb_gain_r;
 	int32_t wb_gain_b;
 	int32_t wb_gain_gb;
+	/**@}*/
 };
+/**@}*/
 
 #endif /* __IA_CSS_DPC2_TYPES_H */
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
index dee174d..fe342f2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
@@ -27,6 +27,9 @@
 
 #include "ia_css_dvs.host.h"
 
+static const struct ia_css_dvs_configuration default_config = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
 
 void
 ia_css_dvs_config(
@@ -46,8 +49,10 @@ ia_css_dvs_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_dvs_configuration config =
-		{ info };
+	struct ia_css_dvs_configuration config = default_config;
+
+	config.info = info;
+
 	ia_css_configure_dvs(binary, &config);
 }
 
@@ -76,7 +81,7 @@ convert_coords_to_ispparams(
 	unsigned int num_blocks_x =  (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(o_width)  : DVS_NUM_BLOCKS_X(o_width)  ); // round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even
 
 
-	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL << uv_flag;
+	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL;
 	unsigned width, height;
 	unsigned int *xbuff = NULL;
 	unsigned int *ybuff = NULL;
@@ -220,8 +225,9 @@ convert_coords_to_ispparams(
 
 struct ia_css_host_data *
 convert_allocate_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
-	const struct ia_css_binary *binary)
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info)
 {
 	unsigned int i_stride;
 	unsigned int o_width;
@@ -229,45 +235,58 @@ convert_allocate_dvs_6axis_config(
 	struct ia_css_host_data *me;
 	struct gdc_warp_param_mem_s *isp_data_ptr;
 
-	assert(params != NULL);
 	assert(binary != NULL);
-	assert(params->dvs_6axis_config != NULL);
+	assert(dvs_6axis_config != NULL);
+	assert(dvs_in_frame_info != NULL);
 
 	me = ia_css_host_data_allocate((size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3));
 
 	if (!me)
 		return NULL;
 
+	/*DVS only supports input frame of YUV420 or NV12. Fail for all other cases*/
+	assert((dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_NV12)
+		|| (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420));
+
 	isp_data_ptr = (struct gdc_warp_param_mem_s *)me->address;
-	/* bgz115: replaced binary->in_frame_info.res.width for
-	   'padded_width=stride' */
-	i_stride  = binary->internal_frame_info.padded_width;
+
+	i_stride  = dvs_in_frame_info->padded_width;
+
 	o_width  = binary->out_frame_info[0].res.width;
 	o_height = binary->out_frame_info[0].res.height;
 
 	/* Y plane */
-	convert_coords_to_ispparams(me, params->dvs_6axis_config,
+	convert_coords_to_ispparams(me, dvs_6axis_config,
 				    i_stride, o_width, o_height, 0);
+
+	if (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420) {
+		/*YUV420 has half the stride for U/V plane*/
+		i_stride /=2;
+	}
+
 	/* UV plane (packed inside the y plane) */
-	convert_coords_to_ispparams(me, params->dvs_6axis_config,
-				    i_stride/2, o_width/2, o_height/2, 1);
+	convert_coords_to_ispparams(me, dvs_6axis_config,
+				    i_stride, o_width/2, o_height/2, 1);
 
 	return me;
 }
 
 enum ia_css_err
 store_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
 	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info,
 	hrt_vaddress ddr_addr_y)
 {
 
 	struct ia_css_host_data *me;
-	assert(params != NULL);
+	assert(dvs_6axis_config != NULL);
 	assert(ddr_addr_y != mmgr_NULL);
+	assert(dvs_in_frame_info != NULL);
 
-	me = convert_allocate_dvs_6axis_config(params,
-				 binary);
+	me = convert_allocate_dvs_6axis_config(dvs_6axis_config,
+				 binary,
+				 dvs_in_frame_info);
 
 	if (!me) {
 		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
@@ -279,7 +298,6 @@ store_dvs_6axis_config(
 				me);
 	ia_css_host_data_free(me);
 
-	params->isp_params_changed = true;
 	return IA_CSS_SUCCESS;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
index dd1f507..2f513e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
@@ -46,13 +46,15 @@ convert_dvs_6axis_config(
 
 struct ia_css_host_data *
 convert_allocate_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
-	const struct ia_css_binary *binary);
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info);
 
 enum ia_css_err
 store_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
 	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info,
 	hrt_vaddress ddr_addr_y);
 
 #endif /* __IA_CSS_DVS_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
index 66e5bb6..1e50392 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
@@ -19,6 +19,7 @@
 
 #include "type_support.h"
 #include "assert_support.h"
+#include "math_support.h" /* for min and max */
 
 #include "ia_css_eed1_8.host.h"
 
@@ -87,9 +88,10 @@ ia_css_eed1_8_vmem_encode(
 
 	/* Init */
 	for (i = 0; i < ISP_VEC_NELEMS; i++) {
-		to->e_cuedge_x[0][i] = 0;
-		to->e_cuedge_a[0][i] = 0;
-		to->e_cuedge_b[0][i] = 0;
+		to->e_dew_enh_x[0][i] = 0;
+		to->e_dew_enh_y[0][i] = 0;
+		to->e_dew_enh_a[0][i] = 0;
+		to->e_dew_enh_f[0][i] = 0;
 		to->chgrinv_x[0][i] = 0;
 		to->chgrinv_a[0][i] = 0;
 		to->chgrinv_b[0][i] = 0;
@@ -159,21 +161,25 @@ ia_css_eed1_8_vmem_encode(
 		base = shuffle_block * i;
 
 		for (j = 0; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
-			to->e_cuedge_x[0][base + j] = from->dew_enhance_seg_x[j];
-			to->e_cuedge_b[0][base + j] = from->dew_enhance_seg_y[j];
+			to->e_dew_enh_x[0][base + j] = min(max(from->dew_enhance_seg_x[j], 0), 8191);
+			to->e_dew_enh_y[0][base + j] = min(max(from->dew_enhance_seg_y[j], -8192), 8191);
 		}
 
-		/* TODO: the calculation of the slope is not included in the KFS.
-		 * Till implementation is available the result of the slope calculation is
-		 * mulitplied with 1024 (just to increase the precision of the slope, since
-		 * the slopes for the default set of x and y is between 0 and 3.
-		 */
-		for (j = 1; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
-			to->e_cuedge_a[0][base + j - 1] = 1024 * (from->dew_enhance_seg_y[j] - from->dew_enhance_seg_y[j - 1]) / (from->dew_enhance_seg_x[j] - from->dew_enhance_seg_x[j - 1]);
+		for (j = 0; j < (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1); j++) {
+			to->e_dew_enh_a[0][base + j] = min(max(from->dew_enhance_seg_slope[j], -8192), 8191);
+			/* Convert dew_enhance_seg_exp to flag:
+			 * 0 -> 0
+			 * 1...13 -> 1
+			 */
+			to->e_dew_enh_f[0][base + j] = (min(max(from->dew_enhance_seg_exp[j], 0), 13) > 0);
 		}
 
-		/* Hard-coded to 0, see KFS for more details */
-		to->e_cuedge_a[0][base + IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1] = 0;
+		/* Hard-coded to 0, in order to be able to handle out of
+		 * range input in the same way as the other segments.
+		 * See KFS for more details.
+		 */
+		to->e_dew_enh_a[0][base + (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] = 0;
+		to->e_dew_enh_f[0][base + (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] = 0;
 
 		for (j = 0; j < NUMBER_OF_CHGRINV_POINTS; j++) {
 			to->chgrinv_x[0][base + j] = chgrinv_x[j];
@@ -206,6 +212,7 @@ ia_css_eed1_8_encode(
 	size_t size)
 {
 	int i;
+	int min_exp = 0;
 
 	(void)size;
 
@@ -247,17 +254,28 @@ ia_css_eed1_8_encode(
 	to->margin_neg0 = from->neg_margin0;
 	to->margin_neg_diff = (from->neg_margin1 - from->neg_margin0);
 
-	for (i = 0; i < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; i++) {
-		to->dew_enhance_seg_x[i] = from->dew_enhance_seg_x[i];
-		to->dew_enhance_seg_y[i] = from->dew_enhance_seg_y[i];
+	/* Encode DEWEnhance exp (e_dew_enh_asr) */
+	for (i = 0; i < (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1); i++) {
+		min_exp = max(min_exp, from->dew_enhance_seg_exp[i]);
 	}
+	to->e_dew_enh_asr = 13 - min(max(min_exp, 0), 13);
 
 	to->dedgew_max = from->dedgew_max;
 }
 
+
+void
+ia_css_init_eed1_8_state(
+	void *state,
+	size_t size)
+{
+	memset(state, 0, size);
+}
+
+
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_eed1_8_debug_trace(
+ia_css_eed1_8_debug_dtrace(
 	const struct ia_css_eed1_8_config *eed,
 	unsigned level)
 {
@@ -297,6 +315,8 @@ ia_css_eed1_8_debug_trace(
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "pos_margin1", eed->pos_margin1);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin0", eed->neg_margin0);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin1", eed->neg_margin1);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dedgew_max", eed->dedgew_max);
 }
 #endif
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
index 46e8bbe..355ff13 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
@@ -31,9 +31,14 @@ ia_css_eed1_8_encode(
 	const struct ia_css_eed1_8_config *from,
 	size_t size);
 
+void
+ia_css_init_eed1_8_state(
+	void *state,
+	size_t size);
+
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_eed1_8_debug_trace(
+ia_css_eed1_8_debug_dtrace(
 	const struct ia_css_eed1_8_config *config,
 	unsigned level);
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c
index 4456541..3622719 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c
@@ -70,5 +70,25 @@ const struct ia_css_eed1_8_config default_eed1_8_config = {
 		6094,
 		8191
 		},
+	.dew_enhance_seg_slope = {
+		4608,
+		3308,
+		2757,
+		2417,
+		2186,
+		8033,
+		7473,
+		7020
+		},
+	.dew_enhance_seg_exp = {
+		2,
+		2,
+		2,
+		2,
+		2,
+		0,
+		0,
+		0
+		},
 	.dedgew_max = 6144
 };
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
index 0260e6c..bc3a07f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
@@ -39,21 +39,19 @@
 /* Define size of the state..... TODO: check if this is the correct place */
 /* 4 planes : GR, R, B, GB */
 #define NUM_PLANES	4
-/* 6 lines state per color plane input_line_state */
-#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(5 * NUM_PLANES)
 
-/* ToDo: Move this to testsetup */
-#define MAX_FRAME_SIMDWIDTH	30
+/* 5 lines state per color plane input_line_state */
+#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(5 * NUM_PLANES)
 
 /* Each plane has width equal to half frame line */
 #define EED1_8_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
-/* 2 lines state per color plane LD_H state */
-#define EED1_8_STATE_LD_H_HEIGHT	(2 * NUM_PLANES)
+/* 1 line state per color plane LD_H state */
+#define EED1_8_STATE_LD_H_HEIGHT	(1 * NUM_PLANES)
 #define EED1_8_STATE_LD_H_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
-/* 2 lines state per color plane LD_V state */
-#define EED1_8_STATE_LD_V_HEIGHT	(2 * NUM_PLANES)
+/* 1 line state per color plane LD_V state */
+#define EED1_8_STATE_LD_V_HEIGHT	(1 * NUM_PLANES)
 #define EED1_8_STATE_LD_V_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line (single plane) state for D_Hr state */
@@ -72,7 +70,7 @@
 #define EED1_8_STATE_D_VB_HEIGHT	2
 #define EED1_8_STATE_D_VB_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
-/* 3 lines state for R and B (= 2 planes) rb_zipped_state */
+/* 2 lines state for R and B (= 2 planes) rb_zipped_state */
 #define EED1_8_STATE_RB_ZIPPED_HEIGHT	(2 * 2)
 #define EED1_8_STATE_RB_ZIPPED_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
@@ -95,9 +93,10 @@
 #endif
 
 struct eed1_8_vmem_params {
-	VMEM_ARRAY(e_cuedge_x, ISP_VEC_NELEMS);
-	VMEM_ARRAY(e_cuedge_a, ISP_VEC_NELEMS);
-	VMEM_ARRAY(e_cuedge_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_y, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_f, ISP_VEC_NELEMS);
 	VMEM_ARRAY(chgrinv_x, ISP_VEC_NELEMS);
 	VMEM_ARRAY(chgrinv_a, ISP_VEC_NELEMS);
 	VMEM_ARRAY(chgrinv_b, ISP_VEC_NELEMS);
@@ -148,8 +147,7 @@ struct eed1_8_dmem_params {
 	int32_t margin_neg0;
 	int32_t margin_neg_diff;
 
-	int32_t dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];
-	int32_t dew_enhance_seg_y[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];
+	int32_t e_dew_enh_asr;
 	int32_t dedgew_max;
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h
index 89c3e31..07651f0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h
@@ -15,6 +15,11 @@
 #ifndef __IA_CSS_EED1_8_TYPES_H
 #define __IA_CSS_EED1_8_TYPES_H
 
+/** @file
+* CSS-API header file for Edge Enhanced Demosaic parameters.
+*/
+
+
 #include "type_support.h"
 
 /**
@@ -23,7 +28,7 @@
  * from the CSS API.
  */
 
-/* parameter list is based on ISP261 CSS API public parameter list_all.xlsx from 12-09-2014 */
+/* parameter list is based on ISP261 CSS API public parameter list_all.xlsx from 28-01-2015 */
 
 /* Number of segments + 1 segment used in edge reliability enhancement
  * Ineffective: N/A
@@ -31,45 +36,51 @@
  */
 #define IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS	9
 
+/** Edge Enhanced Demosaic configuration
+ *
+ * ISP2.6.1: EED1_8 is used.
+ */
 
 struct ia_css_eed1_8_config {
-	int32_t rbzp_strength;	/**Strength of zipper reduction. */
-
-	int32_t fcstrength;	/**Strength of false color reduction. */
-	int32_t fcthres_0;	/**Threshold to prevent chroma coring due to nois or green disparity in dark region. */
-	int32_t fcthres_1;	/**Threshold to prevent chroma coring due to nois or green disparity in bright region. */
-	int32_t fc_sat_coef;	/**How much color saturation to maintain in high color saturation region. */
-	int32_t fc_coring_prm;	/**Chroma coring coefficient for tint color suppression. */
-
-	int32_t aerel_thres0;	/**Threshold for Non-Directional Reliability at dark region. */
-	int32_t aerel_gain0;	/**Gain for Non-Directional Reliability at dark region. */
-	int32_t aerel_thres1;	/**Threshold for Non-Directional Reliability at bright region. */
-	int32_t aerel_gain1;	/**Gain for Non-Directional Reliability at bright region. */
-
-	int32_t derel_thres0;	/**Threshold for Directional Reliability at dark region. */
-	int32_t derel_gain0;	/**Gain for Directional Reliability at dark region. */
-	int32_t derel_thres1;	/**Threshold for Directional Reliability at bright region. */
-	int32_t derel_gain1;	/**Gain for Directional Reliability at bright region. */
-
-	int32_t coring_pos0;	/**Positive Edge Coring Threshold in dark region. */
-	int32_t coring_pos1;	/**Positive Edge Coring Threshold in bright region. */
-	int32_t coring_neg0;	/**Negative Edge Coring Threshold in dark region. */
-	int32_t coring_neg1;	/**Negative Edge Coring Threshold in bright region. */
-
-	int32_t gain_exp;	/**Common Exponent of Gain. */
-	int32_t gain_pos0;	/**Gain for Positive Edge in dark region. */
-	int32_t gain_pos1;	/**Gain for Positive Edge in bright region. */
-	int32_t gain_neg0;	/**Gain for Negative Edge in dark region. */
-	int32_t gain_neg1;	/**Gain for Negative Edge in bright region. */
-
-	int32_t pos_margin0;	/**Margin for Positive Edge in dark region. */
-	int32_t pos_margin1;	/**Margin for Positive Edge in bright region. */
-	int32_t neg_margin0;	/**Margin for Negative Edge in dark region. */
-	int32_t neg_margin1;	/**Margin for Negative Edge in bright region. */
-
-	int32_t dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];	/**Segment data for directional edge weight. */
-	int32_t dew_enhance_seg_y[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];	/**Segment data for directional edge weight. */
-	int32_t dedgew_max;	/**Max Weight for Directional Edge. */
+	int32_t rbzp_strength;	/**< Strength of zipper reduction. */
+
+	int32_t fcstrength;	/**< Strength of false color reduction. */
+	int32_t fcthres_0;	/**< Threshold to prevent chroma coring due to noise or green disparity in dark region. */
+	int32_t fcthres_1;	/**< Threshold to prevent chroma coring due to noise or green disparity in bright region. */
+	int32_t fc_sat_coef;	/**< How much color saturation to maintain in high color saturation region. */
+	int32_t fc_coring_prm;	/**< Chroma coring coefficient for tint color suppression. */
+
+	int32_t aerel_thres0;	/**< Threshold for Non-Directional Reliability at dark region. */
+	int32_t aerel_gain0;	/**< Gain for Non-Directional Reliability at dark region. */
+	int32_t aerel_thres1;	/**< Threshold for Non-Directional Reliability at bright region. */
+	int32_t aerel_gain1;	/**< Gain for Non-Directional Reliability at bright region. */
+
+	int32_t derel_thres0;	/**< Threshold for Directional Reliability at dark region. */
+	int32_t derel_gain0;	/**< Gain for Directional Reliability at dark region. */
+	int32_t derel_thres1;	/**< Threshold for Directional Reliability at bright region. */
+	int32_t derel_gain1;	/**< Gain for Directional Reliability at bright region. */
+
+	int32_t coring_pos0;	/**< Positive Edge Coring Threshold in dark region. */
+	int32_t coring_pos1;	/**< Positive Edge Coring Threshold in bright region. */
+	int32_t coring_neg0;	/**< Negative Edge Coring Threshold in dark region. */
+	int32_t coring_neg1;	/**< Negative Edge Coring Threshold in bright region. */
+
+	int32_t gain_exp;	/**< Common Exponent of Gain. */
+	int32_t gain_pos0;	/**< Gain for Positive Edge in dark region. */
+	int32_t gain_pos1;	/**< Gain for Positive Edge in bright region. */
+	int32_t gain_neg0;	/**< Gain for Negative Edge in dark region. */
+	int32_t gain_neg1;	/**< Gain for Negative Edge in bright region. */
+
+	int32_t pos_margin0;	/**< Margin for Positive Edge in dark region. */
+	int32_t pos_margin1;	/**< Margin for Positive Edge in bright region. */
+	int32_t neg_margin0;	/**< Margin for Negative Edge in dark region. */
+	int32_t neg_margin1;	/**< Margin for Negative Edge in bright region. */
+
+	int32_t dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];		/**< Segment data for directional edge weight: X. */
+	int32_t dew_enhance_seg_y[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];		/**< Segment data for directional edge weight: Y. */
+	int32_t dew_enhance_seg_slope[(IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)];	/**< Segment data for directional edge weight: Slope. */
+	int32_t dew_enhance_seg_exp[(IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)];	/**< Segment data for directional edge weight: Exponent. */
+	int32_t dedgew_max;	/**< Max Weight for Directional Edge. */
 };
 
 #endif /* __IA_CSS_EED1_8_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
index 9fdd597..1fb9f27 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
@@ -71,20 +71,19 @@ ia_css_fpn_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_frame_info my_info =
-		{ { CEIL_DIV(info->res.width, 2), /* Packed by 2x */
-		    info->res.height
-		  },
-		  CEIL_DIV(info->padded_width, 2), /* Packed by 2x */
-		  info->format,
-		  FPN_BITS_PER_PIXEL,
-		  info->raw_bayer_order,
-		  { info->crop_info.start_column,
-		    info->crop_info.start_line
-		  }
-		};
-	const struct ia_css_fpn_configuration config =
-		{ &my_info };
+	struct ia_css_frame_info my_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
+	const struct ia_css_fpn_configuration config = {
+		&my_info
+	};
+
+	my_info.res.width       = CEIL_DIV(info->res.width, 2);		/* Packed by 2x */
+	my_info.res.height      = info->res.height;
+	my_info.padded_width    = CEIL_DIV(info->padded_width, 2);	/* Packed by 2x */
+	my_info.format          = info->format;
+	my_info.raw_bit_depth   = FPN_BITS_PER_PIXEL;
+	my_info.raw_bayer_order = info->raw_bayer_order;
+	my_info.crop_info       = info->crop_info;
+
 	ia_css_configure_fpn(binary, &config);
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c
index e2e828b..8a746f1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.c
@@ -1,27 +1,17 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #include "ia_css_hdr.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h
index d2197b1..34c6a13 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr.host.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h
index b55ff4b..455d741 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_param.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h
index a8fca14..8b2e4f0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/hdr/ia_css_hdr_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
index 4a974e7..270f423 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
@@ -105,7 +105,19 @@ ia_css_iefd2_6_vmem_encode(
 			to->e_curad_b[0][base+j] = from->cu_radial_slopes_b[j-1];
 		}
 		to->e_curad_x[0][base+6] = from->cu_radial_points_x[5];
+
+		/* Init asrrnd_lut */
+		to->asrrnd_lut[0][base] = 8192;
+		to->asrrnd_lut[0][base+1] = 4096;
+		to->asrrnd_lut[0][base+2] = 2048;
+		to->asrrnd_lut[0][base+3] = 1024;
+		to->asrrnd_lut[0][base+4] = 512;
+		to->asrrnd_lut[0][base+5] = 256;
+		to->asrrnd_lut[0][base+6] = 128;
+		to->asrrnd_lut[0][base+7] = 64;
+		to->asrrnd_lut[0][base+8] = 32;
 	}
+
 }
 
 void
@@ -159,10 +171,24 @@ ia_css_iefd2_6_encode(
 	/* Setup for configurable units */
 	to->e_cued2_a		= from->cu_ed2_slopes_a;
 	to->e_cu_vssnlm_a	= from->cu_vssnlm_slopes_a;
-	to->e_cued2_b		= from->cu_ed2_points_x[0];
-	to->e_cu_vssnlm_b	= ((0-from->cu_vssnlm_points_x[1]) * from->cu_vssnlm_slopes_a)>>4;
+	to->e_cued2_x1		= from->cu_ed2_points_x[0];
+	to->e_cued2_x_diff	= from->cu_ed2_points_x[1] - from->cu_ed2_points_x[0];
+	to->e_cu_vssnlm_x1	= from->cu_vssnlm_points_x[0];
+	to->e_cu_vssnlm_x_diff  = from->cu_vssnlm_points_x[1] - from->cu_vssnlm_points_x[0];
+}
+
+/* TODO: AM: This needs a proper implementation. */
+void
+ia_css_init_iefd2_6_state(
+	void *state,
+	size_t size)
+{
+	(void)state;
+	(void)size;
 }
 
+#ifndef IA_CSS_NO_DEBUG
+/* TODO: AM: This needs a proper implementation. */
 void
 ia_css_iefd2_6_debug_dtrace(
 	const struct ia_css_iefd2_6_config *config,
@@ -171,3 +197,4 @@ ia_css_iefd2_6_debug_dtrace(
 	(void)config;
 	(void)level;
 }
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
index d0e7ce8..580d51fe 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
@@ -32,8 +32,15 @@ ia_css_iefd2_6_encode(
 	size_t size);
 
 void
+ia_css_init_iefd2_6_state(
+	void *state,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
 ia_css_iefd2_6_debug_dtrace(
 	const struct ia_css_iefd2_6_config *config, unsigned level)
 ;
+#endif
 
 #endif /* __IA_CSS_IEFD2_6_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
index 3ca31f2..3079096 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
@@ -31,6 +31,7 @@ struct iefd2_6_vmem_params {
 	VMEM_ARRAY(e_curad_x, ISP_VEC_NELEMS);
 	VMEM_ARRAY(e_curad_a, ISP_VEC_NELEMS);
 	VMEM_ARRAY(e_curad_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(asrrnd_lut, ISP_VEC_NELEMS);
 };
 
 struct iefd2_6_dmem_params {
@@ -72,9 +73,11 @@ struct iefd2_6_dmem_params {
 	int32_t vssnlm_y2;
 	int32_t vssnlm_y3;
 	int32_t e_cued2_a;
-	int32_t e_cued2_b;
+	int32_t e_cued2_x1;
+	int32_t e_cued2_x_diff;
 	int32_t e_cu_vssnlm_a;
-	int32_t e_cu_vssnlm_b;
+	int32_t e_cu_vssnlm_x1;
+	int32_t e_cu_vssnlm_x_diff;
 };
 
 #endif /* __IA_CSS_IEFD2_6_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
index 56fd44f..0915f14 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _IA_CSS_IEFD2_6_STATE_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
index 4a6ed56..b0eadab 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
@@ -97,7 +97,7 @@ struct ia_css_iefd2_6_config {
 	int32_t rad_inv_r2;		   /**< Radial R^-2 normelized to (0.5..1).
 						u(8-m_rad_NF).m_rad_NF, [0,255], default 157,
 						ineffective 0 */
-	bool vssnlm_enable;		   /**< Enable bit to use VSSNLM output filter. 
+	bool vssnlm_enable;		   /**< Enable bit to use VSSNLM output filter.
 						bool, [false, true], default true, ineffective false */
 	int32_t vssnlm_x0;		   /**< Vssnlm LUT x0.
 						u8.0, [0,255], default 24, ineffective 0 */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h
index 24b2545..70e3600 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_COMMON_IO_PARAM
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h
index e9af0e6..9d29105 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_COMMON_IO_TYPES
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h
index 9300568..a5e5f62 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_PLANE_IO_PARAM_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h
index 57ed18f..34e88d4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_PLANE_IO_TYPES_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
index c17917d..9e41cc0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #include "ia_css_iterator.host.h"
@@ -29,6 +19,10 @@
 #define IA_CSS_INCLUDE_CONFIGURATIONS
 #include "ia_css_isp_configs.h"
 
+static const struct ia_css_iterator_configuration default_config = {
+	.input_info = (struct ia_css_frame_info *)NULL,
+};
+
 void
 ia_css_iterator_config(
 	struct sh_css_isp_iterator_isp_config *to,
@@ -48,13 +42,15 @@ ia_css_iterator_configure(
 	const struct ia_css_binary *binary,
 	const struct ia_css_frame_info *in_info)
 {
-	struct ia_css_frame_info my_info;
-	struct ia_css_iterator_configuration config = {
-		&binary->in_frame_info,
-		&binary->internal_frame_info,
-		&binary->out_frame_info[0],
-		&binary->vf_frame_info,
-		&binary->dvs_envelope };
+	struct ia_css_frame_info my_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
+	struct ia_css_iterator_configuration config = default_config;
+
+	config.input_info    = &binary->in_frame_info;
+	config.internal_info = &binary->internal_frame_info;
+	config.output_info   = &binary->out_frame_info[0];
+	config.vf_info       = &binary->vf_frame_info;
+	config.dvs_envelope  = &binary->dvs_envelope;
+
 	/* Use in_info iso binary->in_frame_info.
 	 * They can differ in padded width in case of scaling, e.g. for capture_pp.
 	 * Find out why.
@@ -77,6 +73,8 @@ ia_css_iterator_configure(
 		my_info.res.width    <<= binary->vf_downscale_log2;
 		my_info.res.height   <<= binary->vf_downscale_log2;
 	}
-	ia_css_configure_iterator (binary, &config);
+
+	ia_css_configure_iterator(binary, &config);
+
 	return IA_CSS_SUCCESS;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
index a436a4d..d8f249c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_ITERATOR_HOST_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
index 01b1cfd..d308126 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_ITERATOR_PARAM_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
index ad1ab4d..3d510bf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
@@ -15,6 +15,16 @@
 #ifndef __IA_CSS_MACC1_5_TYPES_H
 #define __IA_CSS_MACC1_5_TYPES_H
 
+/** @file
+* CSS-API header file for Multi-Axis Color Conversion algorithm parameters.
+*/
+
+/** Multi-Axis Color Conversion configuration
+ *
+ * ISP2.6.1: MACC1_5 is used.
+ */
+
+
 /** Number of axes in the MACC table. */
 #define IA_CSS_MACC_NUM_AXES           16
 /** Number of coefficients per MACC axes. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h
index ffffdac..eeaadfe 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h
@@ -15,6 +15,15 @@
 #ifndef __IA_CSS_OB2_TYPES_H
 #define __IA_CSS_OB2_TYPES_H
 
+/** @file
+* CSS-API header file for Optical Black algorithm parameters.
+*/
+
+/** Optical Black configuration
+ *
+ * ISP2.6.1: OB2 is used.
+ */
+
 #include "ia_css_frac.h"
 
 struct ia_css_ob2_config {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
index 5bf1e22..fd891ac 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
@@ -105,7 +105,7 @@ ia_css_ob_vmem_encode(
 		unsigned sp_obarea_length_bq = ob->area_length_bq;
 		unsigned low = sp_obarea_start_bq;
 		unsigned high = low + sp_obarea_length_bq;
-		unsigned all_ones = ~0U;
+		uint16_t all_ones = ~0;
 
 		for (i = 0; i < OBAREA_MASK_SIZE; i++) {
 			if (i >= low && i < high)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/output/output_1.0/ia_css_output.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/output/output_1.0/ia_css_output.host.c
index 817fb1e..8fdf47c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/output/output_1.0/ia_css_output.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/output/output_1.0/ia_css_output.host.c
@@ -26,6 +26,18 @@ const struct ia_css_output_config default_output_config = {
 	0
 };
 
+static const struct ia_css_output_configuration default_output_configuration = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
+static const struct ia_css_output0_configuration default_output0_configuration = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
+static const struct ia_css_output1_configuration default_output1_configuration = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
 void
 ia_css_output_encode(
 	struct sh_css_isp_output_params *to,
@@ -81,10 +93,14 @@ ia_css_output_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_output_configuration config =
-		{ info };
-	if (info)
+	if (NULL != info) {
+		struct ia_css_output_configuration config =
+				default_output_configuration;
+
+		config.info = info;
+
 		ia_css_configure_output(binary, &config);
+	}
 }
 
 void
@@ -92,10 +108,14 @@ ia_css_output0_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_output0_configuration config =
-		{ info };
-	if (info)
+	if (NULL != info) {
+		struct ia_css_output0_configuration config =
+				default_output0_configuration;
+
+		config.info = info;
+
 		ia_css_configure_output0(binary, &config);
+	}
 }
 
 void
@@ -103,10 +123,15 @@ ia_css_output1_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_output1_configuration config =
-		{ info };
-	if (info)
+
+	if (NULL != info) {
+		struct ia_css_output1_configuration config =
+				default_output1_configuration;
+
+		config.info = info;
+
 		ia_css_configure_output1(binary, &config);
+	}
 }
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
index 18a22e4..d1fb4b1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
@@ -23,6 +23,10 @@
 
 #include "ia_css_qplane.host.h"
 
+static const struct ia_css_qplane_configuration default_config = {
+	.pipe = (struct sh_css_sp_pipeline *)NULL,
+};
+
 void
 ia_css_qplane_config(
 	struct sh_css_isp_qplane_isp_config *to,
@@ -38,7 +42,7 @@ ia_css_qplane_config(
 	/* Assume divisiblity here, may need to generalize to fixed point. */
 	assert (elems_a % to->port_b.elems == 0);
 
-	to->inout_port_config       = from->pipe->inout_port_config;
+	to->inout_port_config = from->pipe->inout_port_config;
 	to->format = from->info->format;
 }
 
@@ -48,7 +52,10 @@ ia_css_qplane_configure(
 	const struct ia_css_binary      *binary,
 	const struct ia_css_frame_info  *info)
 {
-	const struct ia_css_qplane_configuration config =
-		{ pipe, info };
+	struct ia_css_qplane_configuration config = default_config;
+
+	config.pipe = pipe;
+	config.info = info;
+
 	ia_css_configure_qplane(binary, &config);
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
index f353ef3..68a27f0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
@@ -24,6 +24,11 @@
 
 #include "ia_css_raw.host.h"
 
+
+static const struct ia_css_raw_configuration default_config = {
+	.pipe = (struct sh_css_sp_pipeline *)NULL,
+};
+
 static inline unsigned
 sh_css_elems_bytes_from_info (unsigned raw_bit_depth)
 {
@@ -88,21 +93,21 @@ ia_css_raw_config(
 
 #endif
 	ia_css_dma_configure_from_info(&to->port_b, in_info);
-	to->width_a_over_b = elems_a / to->port_b.elems;
 
 	/* Assume divisiblity here, may need to generalize to fixed point. */
-	assert (in_info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED ||
-		elems_a % to->port_b.elems == 0);
+	assert((in_info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED) ||
+		   (elems_a % to->port_b.elems == 0));
 
-	to->inout_port_config       = from->pipe->inout_port_config;
-	to->format = in_info->format;
+	to->width_a_over_b      = elems_a / to->port_b.elems;
+	to->inout_port_config   = from->pipe->inout_port_config;
+	to->format              = in_info->format;
 	to->required_bds_factor = from->pipe->required_bds_factor;
-	to->two_ppc = from->two_ppc;
-	to->stream_format = css2isp_stream_format(from->stream_format);
-	to->deinterleaved = from->deinterleaved;
+	to->two_ppc             = from->two_ppc;
+	to->stream_format       = css2isp_stream_format(from->stream_format);
+	to->deinterleaved       = from->deinterleaved;
 #if (defined(USE_INPUT_SYSTEM_VERSION_2401) || defined(CONFIG_CSI2_PLUS))
-	to->start_column = in_info->crop_info.start_column;
-	to->start_line = in_info->crop_info.start_line;
+	to->start_column        = in_info->crop_info.start_column;
+	to->start_line          = in_info->crop_info.start_line;
 	to->enable_left_padding = from->enable_left_padding;
 #endif
 }
@@ -117,7 +122,15 @@ ia_css_raw_configure(
 	bool deinterleaved)
 {
 	uint8_t enable_left_padding = (uint8_t)((binary->left_padding) ? 1 : 0);
-	const struct ia_css_raw_configuration config =
-		{ pipe, in_info, internal_info, two_ppc, binary->input_format, deinterleaved, enable_left_padding};
+	struct ia_css_raw_configuration config = default_config;
+
+	config.pipe                = pipe;
+	config.in_info             = in_info;
+	config.internal_info       = internal_info;
+	config.two_ppc             = two_ppc;
+	config.stream_format       = binary->input_format;
+	config.deinterleaved       = deinterleaved;
+	config.enable_left_padding = enable_left_padding;
+
 	ia_css_configure_raw(binary, &config);
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
index 638e359..12168b2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
@@ -30,8 +30,8 @@ struct sh_css_isp_raw_isp_config {
 	uint32_t two_ppc;
 	uint32_t stream_format; /* enum sh_stream_format */
 	uint32_t deinterleaved;
-	uint8_t start_column; /*left crop offset*/
-	uint8_t start_line; /*top crop offset*/
+	uint32_t start_column; /*left crop offset*/
+	uint32_t start_line; /*top crop offset*/
 	uint8_t enable_left_padding; /*need this for multiple binary case*/
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
index 8c29e42..f57ed1e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
@@ -97,7 +97,22 @@ struct ia_css_3a_grid_info {
 #endif
 };
 
+
 #if defined(SYSTEM_css_skycam_c0_system)
+#if defined USE_NEW_AE_STRUCT || defined USE_NEW_AWB_STRUCT
+#define DEFAULT_3A_GRID_INFO \
+{ \
+	0,				/* ae_enable */ \
+	{0,0,0,0,0,0,0},	        /* AE:     width,height,b_width,b_height,x_start,y_start*/ \
+	0,				/* awb_enable */ \
+	{0,0,0,0,0,0},			/* AWB:    width,height,b_width,b_height,x_start,y_start*/ \
+	0,				/* af_enable */ \
+	{0,0,0,0,0,0,0},		/* AF:     width,height,b_width,b_height,x_start,y_start,ff_en*/ \
+	0,				/* awb_fr_enable */ \
+	{0,0,0,0,0,0,0},                  /* AWB_FR: width,height,b_width,b_height,x_start,y_start,ff_en*/ \
+	0,				/* elem_bit_depth */ \
+}
+#else
 #define DEFAULT_3A_GRID_INFO \
 { \
 	0,				/* ae_enable */ \
@@ -110,6 +125,8 @@ struct ia_css_3a_grid_info {
 	{0,0,0,0,0,0,0},                  /* AWB_FR: width,height,b_width,b_height,x_start,y_start,ff_en*/ \
 	0,				/* elem_bit_depth */ \
 }
+#endif /* USE_NEW_AE_STRUCT || defined USE_NEW_AWB_STRUCT */
+
 #else
 #define DEFAULT_3A_GRID_INFO \
 { \
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h
index f0863ad..4eb4910 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _IA_CSS_SDIS_COMMON_HOST_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h
index 3102975..295dc60 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h
@@ -120,16 +120,113 @@ struct ia_css_dvs_grid_info {
 	uint32_t num_ver_coefs;	/**< Number of vertical coefficients. */
 };
 
-#define DEFAULT_DVS_GRID_INFO \
+/** Number of DVS statistics levels
+ */
+#define IA_CSS_DVS_STAT_NUM_OF_LEVELS	3
+
+/** DVS statistics generated by accelerator global configuration
+ */
+struct dvs_stat_public_dvs_global_cfg {
+	unsigned char kappa;
+	/**< DVS statistics global configuration - kappa */
+	unsigned char match_shift;
+	/**< DVS statistics global configuration - match_shift */
+	unsigned char ybin_mode;
+	/**< DVS statistics global configuration - y binning mode */
+};
+
+/** DVS statistics generated by accelerator level grid
+ *  configuration
+ */
+struct dvs_stat_public_dvs_level_grid_cfg {
+	unsigned char grid_width;
+	/**< DVS statistics grid width */
+	unsigned char grid_height;
+	/**< DVS statistics grid height */
+	unsigned char block_width;
+	/**< DVS statistics block width */
+	unsigned char block_height;
+	/**< DVS statistics block  height */
+};
+
+/** DVS statistics generated by accelerator level grid start
+ *  configuration
+ */
+struct dvs_stat_public_dvs_level_grid_start {
+	unsigned short x_start;
+	/**< DVS statistics level x start */
+	unsigned short y_start;
+	/**< DVS statistics level y start */
+	unsigned char enable;
+	/**< DVS statistics level enable */
+};
+
+/** DVS statistics generated by accelerator level grid end
+ *  configuration
+ */
+struct dvs_stat_public_dvs_level_grid_end {
+	unsigned short x_end;
+	/**< DVS statistics level x end */
+	unsigned short y_end;
+	/**< DVS statistics level y end */
+};
+
+/** DVS statistics generated by accelerator Feature Extraction
+ *  Region Of Interest (FE-ROI) configuration
+ */
+struct dvs_stat_public_dvs_level_fe_roi_cfg {
+	unsigned char x_start;
+	/**< DVS statistics fe-roi level x start */
+	unsigned char y_start;
+	/**< DVS statistics fe-roi level y start */
+	unsigned char x_end;
+	/**< DVS statistics fe-roi level x end */
+	unsigned char y_end;
+	/**< DVS statistics fe-roi level y end */
+};
+
+/** DVS statistics generated by accelerator public configuration
+ */
+struct dvs_stat_public_dvs_grd_cfg {
+	struct dvs_stat_public_dvs_level_grid_cfg    grd_cfg;
+	/**< DVS statistics level grid configuration */
+	struct dvs_stat_public_dvs_level_grid_start  grd_start;
+	/**< DVS statistics level grid start configuration */
+	struct dvs_stat_public_dvs_level_grid_end    grd_end;
+	/**< DVS statistics level grid end configuration */
+};
+
+/** DVS statistics grid generated by accelerator
+ */
+struct ia_css_dvs_stat_grid_info {
+	struct dvs_stat_public_dvs_global_cfg       dvs_gbl_cfg;
+	/**< DVS statistics global configuration (kappa, match, binning) */
+	struct dvs_stat_public_dvs_grd_cfg       grd_cfg[IA_CSS_DVS_STAT_NUM_OF_LEVELS];
+	/**< DVS statistics grid configuration (blocks and grids) */
+	struct dvs_stat_public_dvs_level_fe_roi_cfg fe_roi_cfg[IA_CSS_DVS_STAT_NUM_OF_LEVELS];
+	/**< DVS statistics FE ROI (region of interest) configuration */
+};
+
+/** DVS statistics generated by accelerator default grid info
+ */
+#define DEFAULT_DVS_GRID_INFO { \
 { \
-	0,				/* enable */ \
-	0,				/* width */ \
-	0,				/* aligned_width */ \
-	0,				/* height */ \
-	0,				/* aligned_height */ \
-	0,				/* bqs_per_grid_cell */ \
-	0,				/* num_hor_coefs */ \
-	0,				/* num_ver_coefs */ \
+	{ 0, 0, 0},	/* GBL CFG reg: kappa, match_shifrt, binning mode*/ \
+	{{{0, 0, 0, 0}, {0, 0, 0}, {0, 0} }, \
+	{{0, 0, 0, 0}, {0, 0, 0}, {0, 0} }, \
+	{{0, 0, 0, 0}, {0, 0, 0}, {0, 0} } }, \
+	{{0, 0, 0, 0}, {4, 0, 0, 0}, {0, 0, 0, 0} } } \
 }
 
+
+/** Union that holds all types of DVS statistics grid info in
+ *  CSS format
+ * */
+union ia_css_dvs_grid_u {
+	struct ia_css_dvs_stat_grid_info dvs_stat_grid_info;
+	/**< DVS statistics produced by accelerator grid info */
+	struct ia_css_dvs_grid_info dvs_grid_info;
+	/**< DVS (DVS1/DVS2) grid info */
+};
+
 #endif /* __IA_CSS_SDIS_COMMON_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
index c899c6d..0dde842 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
@@ -40,18 +40,19 @@ void ia_css_sdis_horicoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_width = from->grid.aligned_width * from->grid.bqs_per_grid_cell;
-	unsigned	 width = from->grid.num_hor_coefs;
+	unsigned width         = from->grid.num_hor_coefs;
 	int      padding       = aligned_width-width;
-	unsigned stride	       = size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
+	unsigned stride        = size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
 	unsigned total_bytes   = aligned_width*IA_CSS_DVS_NUM_COEF_TYPES*sizeof(short);
+	short   *public        = from->hor_coefs;
+	short   *private       = (short*)to;
 	unsigned type;
-	short *public  = from->hor_coefs;
-	short *private = (short*)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
 	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES*ISP_VEC_NELEMS*sizeof(short)) == 0);
+
 	for (type = 0; type < IA_CSS_DVS_NUM_COEF_TYPES; type++) {
 		fill_row(&private[type*stride], &public[type*width], width, padding);
 	}
@@ -63,18 +64,19 @@ void ia_css_sdis_vertcoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_height = from->grid.aligned_height * from->grid.bqs_per_grid_cell;
-	unsigned	 height = from->grid.num_ver_coefs;
-	int      padding	= aligned_height-height;
-	unsigned stride		= size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
-	unsigned total_bytes	= aligned_height*IA_CSS_DVS_NUM_COEF_TYPES*sizeof(short);
+	unsigned height         = from->grid.num_ver_coefs;
+	int      padding        = aligned_height-height;
+	unsigned stride         = size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
+	unsigned total_bytes    = aligned_height*IA_CSS_DVS_NUM_COEF_TYPES*sizeof(short);
+	short   *public         = from->ver_coefs;
+	short   *private        = (short*)to;
 	unsigned type;
-	short *public  = from->ver_coefs;
-	short *private = (short*)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
 	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES*ISP_VEC_NELEMS*sizeof(short)) == 0);
+
 	for (type = 0; type < IA_CSS_DVS_NUM_COEF_TYPES; type++) {
 		fill_row(&private[type*stride], &public[type*height], height, padding);
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
index 270c723..930061d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
@@ -36,11 +36,11 @@ void ia_css_sdis2_horicoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_width = from->grid.aligned_width * from->grid.bqs_per_grid_cell;
-	unsigned	 width = from->grid.num_hor_coefs;
+	unsigned width         = from->grid.num_hor_coefs;
 	int      padding       = aligned_width-width;
-	unsigned stride	       = size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
+	unsigned stride        = size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
 	unsigned total_bytes   = aligned_width*IA_CSS_DVS2_NUM_COEF_TYPES*sizeof(short);
-	short *private = (short*)to;
+	short   *private       = (short*)to;
 
 
 	/* Copy the table, add padding */
@@ -59,11 +59,11 @@ void ia_css_sdis2_vertcoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_height = from->grid.aligned_height * from->grid.bqs_per_grid_cell;
-	unsigned	 height = from->grid.num_ver_coefs;
-	int      padding	= aligned_height-height;
-	unsigned stride		= size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
-	unsigned total_bytes	= aligned_height*IA_CSS_DVS2_NUM_COEF_TYPES*sizeof(short);
-	short *private = (short*)to;
+	unsigned height         = from->grid.num_ver_coefs;
+	int      padding        = aligned_height-height;
+	unsigned stride         = size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
+	unsigned total_bytes    = aligned_height*IA_CSS_DVS2_NUM_COEF_TYPES*sizeof(short);
+	short   *private        = (short*)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
@@ -114,12 +114,12 @@ void ia_css_get_isp_dvs2_coefficients(
 	IA_CSS_ENTER("void");
 
 	assert(stream != NULL);
-	assert(hor_coefs_odd_real != NULL);
-	assert(hor_coefs_odd_imag != NULL);
+	assert(hor_coefs_odd_real  != NULL);
+	assert(hor_coefs_odd_imag  != NULL);
 	assert(hor_coefs_even_real != NULL);
 	assert(hor_coefs_even_imag != NULL);
-	assert(ver_coefs_odd_real != NULL);
-	assert(ver_coefs_odd_imag != NULL);
+	assert(ver_coefs_odd_real  != NULL);
+	assert(ver_coefs_odd_imag  != NULL);
 	assert(ver_coefs_even_real != NULL);
 	assert(ver_coefs_even_imag != NULL);
 
@@ -150,12 +150,12 @@ void ia_css_get_isp_dvs2_coefficients(
 void ia_css_sdis2_clear_coefficients(
 	struct ia_css_dvs2_coefficients *dvs2_coefs)
 {
-	dvs2_coefs->hor_coefs.odd_real = NULL;
-	dvs2_coefs->hor_coefs.odd_imag = NULL;
+	dvs2_coefs->hor_coefs.odd_real  = NULL;
+	dvs2_coefs->hor_coefs.odd_imag  = NULL;
 	dvs2_coefs->hor_coefs.even_real = NULL;
 	dvs2_coefs->hor_coefs.even_imag = NULL;
-	dvs2_coefs->ver_coefs.odd_real = NULL;
-	dvs2_coefs->ver_coefs.odd_imag = NULL;
+	dvs2_coefs->ver_coefs.odd_real  = NULL;
+	dvs2_coefs->ver_coefs.odd_imag  = NULL;
 	dvs2_coefs->ver_coefs.even_real = NULL;
 	dvs2_coefs->ver_coefs.even_imag = NULL;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
index d8324fe..e775af5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
@@ -37,8 +37,8 @@ ia_css_tdf_vmem_encode(
 
 	for (i = 0; i < ISP_VEC_NELEMS; i++) {
 		to->pyramid[0][i]          = g_pyramid[i/8][i%8];
-		to->threshold_flat[0][i]   = from->TdfThres_flat_table[i];
-		to->threshold_detail[0][i] = from->TdfThres_detail_table[i];
+		to->threshold_flat[0][i]   = from->thres_flat_table[i];
+		to->threshold_detail[0][i] = from->thres_detail_table[i];
 	}
 
 }
@@ -50,19 +50,19 @@ ia_css_tdf_encode(
 	size_t size)
 {
 	(void)size;
-	to->Epsilon_0        = from->TdfEpsilon_0;
-	to->Epsilon_1        = from->TdfEpsilon_1;
-	to->EpsScaleText     = from->TdfEpsScaleText;
-	to->EpsScaleEdge     = from->TdfEpsScaleEdge;
-	to->Sepa_flat 	     = from->TdfSepa_flat;
-	to->Sepa_Edge 	     = from->TdfSepa_Edge;
-	to->Blend_Flat 	     = from->TdfBlend_Flat;
-	to->Blend_Text 	     = from->TdfBlend_Text;
-	to->Blend_Edge 	     = from->TdfBlend_Edge;
-	to->Shading_Gain     = from->TdfShading_Gain;
-	to->Shading_baseGain = from->TdfShading_baseGain;
-	to->LocalY_Gain      = from->TdfLocalY_Gain;
-	to->LocalY_baseGain  = from->TdfLocalY_baseGain;
+	to->Epsilon_0        = from->epsilon_0;
+	to->Epsilon_1        = from->epsilon_1;
+	to->EpsScaleText     = from->eps_scale_text;
+	to->EpsScaleEdge     = from->eps_scale_edge;
+	to->Sepa_flat	     = from->sepa_flat;
+	to->Sepa_Edge	     = from->sepa_edge;
+	to->Blend_Flat	     = from->blend_flat;
+	to->Blend_Text	     = from->blend_text;
+	to->Blend_Edge	     = from->blend_edge;
+	to->Shading_Gain     = from->shading_gain;
+	to->Shading_baseGain = from->shading_base_gain;
+	to->LocalY_Gain      = from->local_y_gain;
+	to->LocalY_baseGain  = from->local_y_base_gain;
 }
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c
index 2944820..9bb42da 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c
@@ -15,20 +15,22 @@
 #include "ia_css_tdf_types.h"
 
 const struct ia_css_tdf_config default_tdf_config = {
-	.TdfThres_flat_table = {0},
-	.TdfThres_detail_table = {0},
-	.TdfEpsilon_0 = 4095,
-	.TdfEpsilon_1 = 5733,
-	.TdfEpsScaleText = 409,
-	.TdfEpsScaleEdge = 3686,
-	.TdfSepa_flat = 1294,
-	.TdfSepa_Edge = 4095,
-	.TdfBlend_Flat = 819,
-	.TdfBlend_Text = 819,
-	.TdfBlend_Edge = 8191,
-	.TdfShading_Gain = 1024,
-	.TdfShading_baseGain = 8191,
-	.TdfLocalY_Gain = 0,
-	.TdfLocalY_baseGain = 2047
+	.thres_flat_table = {0},
+	.thres_detail_table = {0},
+	.epsilon_0 = 4095,
+	.epsilon_1 = 5733,
+	.eps_scale_text = 409,
+	.eps_scale_edge = 3686,
+	.sepa_flat = 1294,
+	.sepa_edge = 4095,
+	.blend_flat = 819,
+	.blend_text = 819,
+	.blend_edge = 8191,
+	.shading_gain = 1024,
+	.shading_base_gain = 8191,
+	.local_y_gain = 0,
+	.local_y_base_gain = 2047,
+	.rad_x_origin = 0,
+	.rad_y_origin = 0
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
index 7a5f940..cc47a50 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
@@ -15,24 +15,38 @@
 #ifndef __IA_CSS_TDF_TYPES_H
 #define __IA_CSS_TDF_TYPES_H
 
+/** @file
+* CSS-API header file for Transform Domain Filter parameters.
+*/
+
 #include "type_support.h"
 
+/** Transform Domain Filter configuration
+ *
+ * \brief TDF public parameters.
+ * \details Struct with all parameters for the TDF kernel that can be set
+ * from the CSS API.
+ *
+ * ISP2.6.1: TDF is used.
+ */
 struct ia_css_tdf_config {
-	int32_t TdfThres_flat_table[64];
-	int32_t TdfThres_detail_table[64];
-	int32_t TdfEpsilon_0;
-	int32_t TdfEpsilon_1;
-	int32_t TdfEpsScaleText;
-	int32_t TdfEpsScaleEdge;
-	int32_t TdfSepa_flat;
-	int32_t TdfSepa_Edge;
-	int32_t TdfBlend_Flat;
-	int32_t TdfBlend_Text;
-	int32_t TdfBlend_Edge;
-	int32_t TdfShading_Gain;
-	int32_t TdfShading_baseGain;
-	int32_t TdfLocalY_Gain;
-	int32_t TdfLocalY_baseGain;
+	int32_t thres_flat_table[64];	/**< Final optimized strength table of NR for flat region. */
+	int32_t thres_detail_table[64];	/**< Final optimized strength table of NR for detail region. */
+	int32_t epsilon_0;		/**< Coefficient to control variance for dark area (for flat region). */
+	int32_t epsilon_1;		/**< Coefficient to control variance for bright area (for flat region). */
+	int32_t eps_scale_text;		/**< Epsilon scaling coefficient for texture region. */
+	int32_t eps_scale_edge;		/**< Epsilon scaling coefficient for edge region. */
+	int32_t sepa_flat;		/**< Threshold to judge flat (edge < m_Flat_thre). */
+	int32_t sepa_edge;		/**< Threshold to judge edge (edge > m_Edge_thre). */
+	int32_t blend_flat;		/**< Blending ratio at flat region. */
+	int32_t blend_text;		/**< Blending ratio at texture region. */
+	int32_t blend_edge;		/**< Blending ratio at edge region. */
+	int32_t shading_gain;		/**< Gain of Shading control. */
+	int32_t shading_base_gain;	/**< Base Gain of Shading control. */
+	int32_t local_y_gain;		/**< Gain of local luminance control. */
+	int32_t local_y_base_gain;	/**< Base gain of local luminance control. */
+	int32_t rad_x_origin;		/**< Initial x coord. for radius computation. */
+	int32_t rad_y_origin;		/**< Initial y coord. for radius computation. */
 };
 
 #endif /* __IA_CSS_TDF_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c
new file mode 100644
index 0000000..7e86bc8
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c
@@ -0,0 +1,155 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include "type_support.h"
+#include "math_support.h"
+#include "sh_css_defs.h"
+#include "assert_support.h"
+#include "ia_css_xnr3_0_11.host.h"
+
+/*
+ * XNR 3.0.11 division look-up table
+ */
+#define XNR3_0_11_LOOK_UP_TABLE_POINTS 16
+
+static const int16_t x[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+512, 637, 782, 952, 1147, 1372, 1627, 1917, 2242,
+2597, 2992, 3427, 3907, 4432, 5007, 5632};
+
+static const int16_t a[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+-6587, -4309, -2886, -1970, -1362, -7710, -5508,
+-4008, -2931, -2219, -1676, -1280, -999, -769, -616, 0};
+
+static const int16_t b[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+4096, 3292, 2682, 2203, 1828, 1529, 1289, 1094,
+935, 808, 701, 612, 537, 473, 419, 372};
+
+static const int16_t c[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+
+/*
+ * Default kernel parameters (weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+ */
+const struct ia_css_xnr3_0_11_config default_xnr3_0_11_config = {
+	7, 7, 7, 7, 7, 2 };
+
+
+/* (void) = ia_css_xnr3_0_11_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_11_vmem_encode(
+	struct sh_css_isp_xnr3_0_11_vmem_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size)
+{
+	unsigned i, j, base;
+	const unsigned total_blocks = 4;
+	const unsigned shuffle_block = 16;
+
+	(void)from;
+	(void)size;
+
+	/* Init */
+	for (i = 0; i < ISP_VEC_NELEMS; i++) {
+		to->x[0][i] = 0;
+		to->a[0][i] = 0;
+		to->b[0][i] = 0;
+		to->c[0][i] = 0;
+	}
+
+
+	/* Constraints on "x":
+	 * - values should be greater or equal to 0.
+	 * - values should be ascending.
+	 */
+	assert(x[0] >= 0);
+
+	for (j = 1; j < XNR3_0_11_LOOK_UP_TABLE_POINTS; j++) {
+		assert(x[j] >= 0);
+		assert(x[j] > x[j-1]);
+
+	}
+
+
+	/* The implementation of the calulating 1/x is based on the availability
+	 * of the OP_vec_shuffle16 operation.
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* TODO: guard this code with above assumptions */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block * i;
+
+		for (j = 0; j < XNR3_0_11_LOOK_UP_TABLE_POINTS; j++) {
+			to->x[0][base + j] = x[j];
+			to->a[0][base + j] = a[j];
+			to->b[0][base + j] = b[j];
+			to->c[0][base + j] = c[j];
+		}
+	}
+
+}
+
+
+
+/* (void) = ia_css_xnr3_0_11_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void
+ia_css_xnr3_0_11_encode(
+	struct sh_css_isp_xnr3_0_11_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size)
+{
+	int kernel_size = XNR_FILTER_SIZE;
+	/* The adjust factor is the next power of 2
+	   w.r.t. the kernel size*/
+	int adjust_factor = ceil_pow2(kernel_size);
+
+	int32_t weight_y0 = from->weight_y0;
+	int32_t weight_y1 = from->weight_y1;
+	int32_t weight_u0 = from->weight_u0;
+	int32_t weight_u1 = from->weight_u1;
+	int32_t weight_v0 = from->weight_v0;
+	int32_t weight_v1 = from->weight_v1;
+
+	(void)size;
+
+	to->weight_y0 = weight_y0;
+	to->weight_u0 = weight_u0;
+	to->weight_v0 = weight_v0;
+	to->weight_ydiff = (weight_y1 - weight_y0) * adjust_factor / kernel_size;
+	to->weight_udiff = (weight_u1 - weight_u0) * adjust_factor / kernel_size;
+	to->weight_vdiff = (weight_v1 - weight_v0) * adjust_factor / kernel_size;
+}
+
+/* (void) = ia_css_xnr3_0_11_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_11_debug_dtrace(
+	const struct ia_css_xnr3_0_11_config *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h
new file mode 100644
index 0000000..8e8b85f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h
@@ -0,0 +1,58 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_11_HOST_H
+#define __IA_CSS_XNR3_0_11_HOST_H
+
+#include "ia_css_xnr3_0_11_param.h"
+#include "ia_css_xnr3_0_11_types.h"
+
+/*
+ * Default kernel parameters (weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+ */
+extern const struct ia_css_xnr3_0_11_config default_xnr3_0_11_config;
+
+
+/* (void) = ia_css_xnr3_0_11_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_11_vmem_encode(
+	struct sh_css_isp_xnr3_0_11_vmem_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_11_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void
+ia_css_xnr3_0_11_encode(
+	struct sh_css_isp_xnr3_0_11_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_11_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_11_debug_dtrace(
+	const struct ia_css_xnr3_0_11_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_XNR3_0_11_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h
new file mode 100644
index 0000000..a28cfd4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_11_PARAM_H
+#define __IA_CSS_XNR3_0_11_PARAM_H
+
+#include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+/* XNR3.0.11 filter size */
+#define XNR_FILTER_SIZE             11
+
+/*
+ * STRUCT sh_css_isp_xnr3_0_11_vmem_params
+ * -----------------------------------------------
+ * XNR3.0.11 ISP VMEM parameters
+ */
+struct sh_css_isp_xnr3_0_11_vmem_params {
+	VMEM_ARRAY(x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(c, ISP_VEC_NELEMS);
+};
+
+ /*
+ * STRUCT sh_css_isp_xnr3_0_11_params
+ * -----------------------------------------------
+ * XNR3.0.11 ISP parameters
+ */
+struct sh_css_isp_xnr3_0_11_params {
+	int32_t weight_y0;
+	int32_t weight_u0;
+	int32_t weight_v0;
+	int32_t weight_ydiff;
+	int32_t weight_udiff;
+	int32_t weight_vdiff;
+};
+
+#endif  /*__IA_CSS_XNR3_0_11_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h
new file mode 100644
index 0000000..b6bf449
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_11_TYPES_H
+#define __IA_CSS_XNR3_0_11_TYPES_H
+
+ /*
+ * STRUCT ia_css_xnr3_0_11_config
+ * -----------------------------------------------
+ * Struct with all parameters for the XNR3.0.11 kernel that can be set
+ * from the CSS API
+ */
+struct ia_css_xnr3_0_11_config {
+	int32_t weight_y0;     /**< Weight for Y range similarity in dark area */
+	int32_t weight_y1;     /**< Weight for Y range similarity in bright area */
+	int32_t weight_u0;     /**< Weight for U range similarity in dark area */
+	int32_t weight_u1;     /**< Weight for U range similarity in bright area */
+	int32_t weight_v0;     /**< Weight for V range similarity in dark area */
+	int32_t weight_v1;     /**< Weight for V range similarity in bright area */
+};
+
+#endif /* __IA_CSS_XNR3_0_11_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c
new file mode 100644
index 0000000..d29b314
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c
@@ -0,0 +1,154 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include "type_support.h"
+#include "math_support.h"
+#include "sh_css_defs.h"
+#include "assert_support.h"
+#include "ia_css_xnr3_0_5.host.h"
+
+/*
+ * XNR 3.0.5 division look-up table
+ */
+#define XNR3_0_5_LOOK_UP_TABLE_POINTS 16
+
+static const int16_t x[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+1024, 1164, 1320, 1492, 1680, 1884, 2108, 2352,
+2616, 2900, 3208, 3540, 3896, 4276, 4684, 5120};
+
+static const int16_t a[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+-7213, -5580, -4371, -3421, -2722, -2159, -6950, -5585,
+-4529, -3697, -3010, -2485, -2070, -1727, -1428, 0};
+
+static const int16_t b[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+4096, 3603, 3178, 2811, 2497, 2226, 1990, 1783,
+1603, 1446, 1307, 1185, 1077, 981, 895, 819};
+
+static const int16_t c[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+/*
+ * Default kernel parameters(weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+ */
+const struct ia_css_xnr3_0_5_config default_xnr3_0_5_config = {
+	8191, 8191, 8191, 8191, 8191, 8191 };
+
+
+/* (void) = ia_css_xnr3_0_5_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_5_vmem_encode(
+	struct sh_css_isp_xnr3_0_5_vmem_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size)
+{
+	unsigned i, j, base;
+	const unsigned total_blocks = 4;
+	const unsigned shuffle_block = 16;
+
+	(void)from;
+	(void)size;
+
+	/* Init */
+	for (i = 0; i < ISP_VEC_NELEMS; i++) {
+		to->x[0][i] = 0;
+		to->a[0][i] = 0;
+		to->b[0][i] = 0;
+		to->c[0][i] = 0;
+	}
+
+
+	/* Constraints on "x":
+	 * - values should be greater or equal to 0.
+	 * - values should be ascending.
+	 */
+	assert(x[0] >= 0);
+
+	for (j = 1; j < XNR3_0_5_LOOK_UP_TABLE_POINTS; j++) {
+		assert(x[j] >= 0);
+		assert(x[j] > x[j-1]);
+
+	}
+
+
+	/* The implementation of the calulating 1/x is based on the availability
+	 * of the OP_vec_shuffle16 operation.
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* TODO: guard this code with above assumptions */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block * i;
+
+		for (j = 0; j < XNR3_0_5_LOOK_UP_TABLE_POINTS; j++) {
+			to->x[0][base + j] = x[j];
+			to->a[0][base + j] = a[j];
+			to->b[0][base + j] = b[j];
+			to->c[0][base + j] = c[j];
+		}
+	}
+
+}
+
+
+
+/* (void) = ia_css_xnr3_0_5_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void
+ia_css_xnr3_0_5_encode(
+	struct sh_css_isp_xnr3_0_5_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size)
+{
+	int kernel_size = XNR_FILTER_SIZE;
+	/* The adjust factor is the next power of 2
+	   w.r.t. the kernel size*/
+	int adjust_factor = ceil_pow2(kernel_size);
+
+	int32_t weight_y0 = from->weight_y0;
+	int32_t weight_y1 = from->weight_y1;
+	int32_t weight_u0 = from->weight_u0;
+	int32_t weight_u1 = from->weight_u1;
+	int32_t weight_v0 = from->weight_v0;
+	int32_t weight_v1 = from->weight_v1;
+
+	(void)size;
+
+	to->weight_y0 = weight_y0;
+	to->weight_u0 = weight_u0;
+	to->weight_v0 = weight_v0;
+	to->weight_ydiff = (weight_y1 - weight_y0) * adjust_factor / kernel_size;
+	to->weight_udiff = (weight_u1 - weight_u0) * adjust_factor / kernel_size;
+	to->weight_vdiff = (weight_v1 - weight_v0) * adjust_factor / kernel_size;
+}
+
+/* (void) = ia_css_xnr3_0_5_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_5_debug_dtrace(
+	const struct ia_css_xnr3_0_5_config *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h
new file mode 100644
index 0000000..69817a6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h
@@ -0,0 +1,59 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_5_HOST_H
+#define __IA_CSS_XNR3_0_5_HOST_H
+
+#include "ia_css_xnr3_0_5_param.h"
+#include "ia_css_xnr3_0_5_types.h"
+
+/*
+ * Default kernel parameters (weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+*/
+extern const struct ia_css_xnr3_0_5_config default_xnr3_0_5_config;
+
+
+
+/* (void) = ia_css_xnr3_0_5_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_5_vmem_encode(
+	struct sh_css_isp_xnr3_0_5_vmem_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_5_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_5_encode(
+	struct sh_css_isp_xnr3_0_5_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_5_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_5_debug_dtrace(
+	const struct ia_css_xnr3_0_5_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_XNR3_0_5_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h
new file mode 100644
index 0000000..fc1d9cc
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_5_PARAM_H
+#define __IA_CSS_XNR3_0_5_PARAM_H
+
+#include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+/* XNR3.0.5 filter size */
+#define XNR_FILTER_SIZE             5
+
+/*
+ * STRUCT sh_css_isp_xnr3_0_5_vmem_params
+ * -----------------------------------------------
+ * XNR3.0.5 ISP VMEM parameters
+ */
+struct sh_css_isp_xnr3_0_5_vmem_params {
+	VMEM_ARRAY(x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(c, ISP_VEC_NELEMS);
+};
+
+/*
+ * STRUCT sh_css_isp_xnr3_0_5_params
+ * -----------------------------------------------
+ * XNR3.0.5 ISP parameters
+ */
+struct sh_css_isp_xnr3_0_5_params {
+	int32_t weight_y0;
+	int32_t weight_u0;
+	int32_t weight_v0;
+	int32_t weight_ydiff;
+	int32_t weight_udiff;
+	int32_t weight_vdiff;
+};
+
+#endif  /*__IA_CSS_XNR3_0_5_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h
new file mode 100644
index 0000000..ba7c81e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_5_TYPES_H
+#define __IA_CSS_XNR3_0_5_TYPES_H
+
+/*
+ * STRUCT ia_css_xnr3_0_5_config
+ * -----------------------------------------------
+ * Struct with all parameters for the XNR3.0.5 kernel that can be set
+ * from the CSS API
+*/
+struct ia_css_xnr3_0_5_config {
+	int32_t weight_y0;     /**< Weight for Y range similarity in dark area */
+	int32_t weight_y1;     /**< Weight for Y range similarity in bright area */
+	int32_t weight_u0;     /**< Weight for U range similarity in dark area */
+	int32_t weight_u1;     /**< Weight for U range similarity in bright area */
+	int32_t weight_v0;     /**< Weight for V range similarity in dark area */
+	int32_t weight_v1;     /**< Weight for V range similarity in bright area */
+};
+
+#endif /* __IA_CSS_XNR3_0_5_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
index 8149303..3018100 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
@@ -42,9 +42,9 @@ ia_css_xnr_encode(
 	unsigned size)
 {
 	(void)size;
-	
+
 	to->threshold =
-		uDIGIT_FITTING(from->threshold, 16, SH_CSS_ISP_YUV_BITS);
+		(uint16_t)uDIGIT_FITTING(from->threshold, 16, SH_CSS_ISP_YUV_BITS);
 }
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
index a630a2c..b56d9fd 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
@@ -34,7 +34,9 @@ const struct ia_css_xnr3_config default_xnr3_config = {
 	/* sigma */
 	{ 0, 0, 0, 0, 0, 0 },
 	/* coring */
-	{ 0, 0, 0, 0 }
+	{ 0, 0, 0, 0 },
+	/* blending */
+	{ 0 }
 };
 
 /*
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
index 8ddd266..8f14d10 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
@@ -31,6 +31,12 @@
  */
 #define IA_CSS_XNR3_CORING_SCALE (1 << 15)
 
+/**
+ * \brief Scale of the XNR blending parameter.
+ * \details The define specifies which fixed-point value represents 1.0.
+ */
+#define IA_CSS_XNR3_BLENDING_SCALE (1 << 11)
+
 
 /**
  * \brief XNR3 Sigma Parameters.
@@ -65,13 +71,28 @@ struct ia_css_xnr3_coring_params {
 };
 
 /**
+ * \brief XNR3 Blending Parameters
+ * \details Blending parameters define the blending strength of filtered
+ * output pixels with the original chroma pixels from before xnr3. The
+ * blending strength is a fixed-point value between 0.0 and 1.0 (inclusive),
+ * scaled with IA_CSS_XNR3_BLENDING_SCALE.
+ * A higher number applies xnr filtering more strongly. A value of 1.0
+ * disables the blending and returns the xnr3 filtered output, while a
+ * value of 0.0 bypasses the entire xnr3 filter.
+ */
+struct ia_css_xnr3_blending_params {
+	int strength;   /**< Blending strength */
+};
+
+/**
  * \brief XNR3 public parameters.
  * \details Struct with all parameters for the XNR3 kernel that can be set
  * from the CSS API.
  */
 struct ia_css_xnr3_config {
-	struct ia_css_xnr3_sigma_params  sigma;   /**< XNR3 sigma parameters */
-	struct ia_css_xnr3_coring_params coring;  /**< XNR3 coring parameters */
+	struct ia_css_xnr3_sigma_params    sigma;    /**< XNR3 sigma parameters */
+	struct ia_css_xnr3_coring_params   coring;   /**< XNR3 coring parameters */
+	struct ia_css_xnr3_blending_params blending; /**< XNR3 blending parameters */
 };
 
 #endif /* __IA_CSS_XNR3_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h
index ea9fb1d..b1ce736 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_const.h
@@ -1,26 +1,17 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
+
 #ifndef _COMMON_ISP_CONST_H_
 #define _COMMON_ISP_CONST_H_
 
@@ -113,15 +104,8 @@
 #define SH_CSS_BINARY_ID_ACCELERATION           57
 #define SH_CSS_BINARY_ID_PRE_DE_ISP2            58
 #define SH_CSS_BINARY_ID_KERNEL_TEST_LOAD_STORE 59
-
-/* skycam product pipelines */
-#define SH_CSS_BINARY_ID_PRIMARY                            101
-#define SH_CSS_BINARY_ID_PRIMARY_PP                         102
-#define SH_CSS_BINARY_ID_VIDEO                              103
-#define SH_CSS_BINARY_ID_SC_VIDEO_HIGH_RESOLUTION           104
-#define SH_CSS_BINARY_ID_VIDEO_C0                           105
-#define SH_CSS_BINARY_ID_SC_VIDEO_C0_HIGH_RESOLUTION        106
-#define SH_CSS_BINARY_ID_SC_VIDEO_HIRES                     107
+#define SH_CSS_BINARY_ID_CAPTURE_PP_BLI         60
+#define SH_CSS_BINARY_ID_CAPTURE_PP_LDC         61
 
 /* skycam kerneltest pipelines */
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_NORM              120
@@ -142,7 +126,6 @@
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR               136
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_STRIPED       137
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_TNR_BLOCK         139
-#define SH_CSS_BINARY_ID_VIDEO_PARTIALPIPE_INPUTCOR_FULL    140
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_ACC_AE            141
 #define SH_CSS_BINARY_ID_VIDEO_RAW                          142
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_ACC_AWB_FR        143
@@ -155,7 +138,6 @@
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_TNR_STRIPED       150
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_DVS_STRIPED       151
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_OBGRID_STRIPED    152
-#define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_BDS_DVS_STRIPED   153
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_COPY_YUV          155
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_COPY_YUV_BLOCK    156
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_COPY_YUV16_BLOCK  157
@@ -169,7 +151,6 @@
 
 
 /* skycam partial test pipelines*/
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_DVS              199
 #define SH_CSS_BINARY_ID_IF_TO_DPC                          201
 #define SH_CSS_BINARY_ID_IF_TO_BDS                          202
 #define SH_CSS_BINARY_ID_IF_TO_NORM                         203
@@ -177,24 +158,16 @@
 #define SH_CSS_BINARY_ID_IF_TO_LIN                          205
 #define SH_CSS_BINARY_ID_IF_TO_SHD                          206
 #define SH_CSS_BINARY_ID_IF_TO_BNR                          207
-#define SH_CSS_BINARY_ID_IF_TO_DM_WO_ANR_STATS              208
-#define SH_CSS_BINARY_ID_IF_TO_DM_3A_WO_ANR                 209
 #define SH_CSS_BINARY_ID_IF_TO_RGBPP                        210
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1                        211
-#define SH_CSS_BINARY_ID_IF_TO_DM_WO_STATS                  213
 #define SH_CSS_BINARY_ID_IF_TO_DM                           214
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_C0                     216
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_ANR_VIA_ISP            217
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_DVS                    218
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_TNR                    219
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_BNR_STRIPED        220
 #define SH_CSS_BINARY_ID_IF_TO_BDS_STRIPED                  224
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_ANR_STRIPED         225
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AWB_BNR_STRIPED    226
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_YUVP2_STRIPED       227
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AF_BNR_STRIPED     228
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AWBFR_BNR_STRIPED  229
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AE_BNR_STRIPED     232
 #define SH_CSS_BINARY_ID_IF_TO_REF                          236
 #define SH_CSS_BINARY_ID_IF_TO_DVS_STRIPED                  237
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_STRIPED                238
@@ -206,34 +179,18 @@
 #define SH_CSS_BINARY_ID_IF_TO_LIN_STRIPED                  244
 #define SH_CSS_BINARY_ID_IF_TO_OB_STRIPED                   245
 #define SH_CSS_BINARY_ID_IF_TO_NORM_STRIPED                 248
-#define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STATS_C0          251
-#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE            252
 #define SH_CSS_BINARY_ID_COPY_KERNELTEST_OUTPUT_SYSTEM      253
-#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE_C0         254
-#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE_HR         255
 #define SH_CSS_BINARY_ID_IF_TO_XNR                          256
 #define SH_CSS_BINARY_ID_IF_TO_XNR_STRIPED                  257
 #define SH_CSS_BINARY_ID_IF_TO_REF_STRIPED                  258
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS                   259
-#define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_C0_STRIPED        260
-#define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_C0                261
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1_C0                     262
 #define SH_CSS_BINARY_ID_IF_TO_XNR_PRIMARY                  263
 #define SH_CSS_BINARY_ID_IF_TO_XNR_PRIMARY_STRIPED          264
 #define SH_CSS_BINARY_ID_IF_TO_ANR                          265
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_DVS_STAT_C0         266
-#define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_LACE_STAT_C0        267
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR                  268
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_STRIPED          269
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_STRIPED           270
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_DVS_STRIPED      271
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_NO_TNR     272
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_NO_TNR_STRIPED 273
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS            274
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_STRIPED    275
 #define SH_CSS_BINARY_ID_IF_TO_OSYS_PRIMARY                 276
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_PRIMARY          277
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_PRIMARY_STRIPED  278
 #define SH_CSS_BINARY_ID_IF_TO_OSYS_PRIMARY_STRIPED         279
 
 #define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_exprs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_exprs.h
index 4b0a95d..03f845f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_exprs.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_exprs.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _COMMON_ISP_EXPRS_H_
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_types.h
index b4ba1c8..7a73702 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/isp/modes/interface/isp_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _ISP_TYPES_H_
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/interface/ia_css_binary.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/interface/ia_css_binary.h
index b7010f9..78f6c08 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/interface/ia_css_binary.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/interface/ia_css_binary.h
@@ -102,6 +102,7 @@ struct ia_css_binary_descr {
 	bool enable_xnr;
 	bool enable_fractional_ds;
 	bool enable_dpc;
+	bool enable_capture_pp_bli;
 	struct ia_css_resolution dvs_env;
 	enum ia_css_stream_format stream_format;
 	struct ia_css_frame_info *in_info;		/* the info of the input-frame with the
@@ -232,6 +233,12 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 			    struct ia_css_grid_info *info,
 			    struct ia_css_pipe *pipe);
 
+void
+ia_css_binary_dvs_stat_grid_info(
+	const struct ia_css_binary *binary,
+	struct ia_css_grid_info *info,
+	struct ia_css_pipe *pipe);
+
 unsigned
 ia_css_binary_max_vf_width(void);
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c
index eff89fc..48fa021 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/binary/src/binary.c
@@ -36,6 +36,7 @@
 #include "camera/pipe/interface/ia_css_pipe_binarydesc.h"
 #if defined(HAS_RES_MGR)
 #include <components/resolutions_mgr/src/host/resolutions_mgr.host.h>
+#include <components/acc_cluster/acc_dvs_stat/host/dvs_stat.host.h>
 #endif
 
 #include "memory_access.h"
@@ -320,6 +321,18 @@ ia_css_binary_get_shading_info(const struct ia_css_binary *binary,			/* [in] */
 	return err;
 }
 
+static void sh_css_binary_common_grid_info(const struct ia_css_binary *binary,
+				struct ia_css_grid_info *info)
+{
+	assert(binary != NULL);
+	assert(info != NULL);
+
+	info->isp_in_width = binary->internal_frame_info.res.width;
+	info->isp_in_height = binary->internal_frame_info.res.height;
+
+	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
+}
+
 void
 ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 			    struct ia_css_grid_info *info,
@@ -331,7 +344,7 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 	assert(binary != NULL);
 	assert(info != NULL);
 
-	dvs_info = &info->dvs_grid;
+	dvs_info = &info->dvs_grid.dvs_grid_info;
 
 	/* for DIS, we use a division instead of a ceil_div. If this is smaller
 	 * than the 3a grid size, it indicates that the outer values are not
@@ -346,10 +359,37 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 	dvs_info->num_hor_coefs     = binary->dis.coef.dim.width;
 	dvs_info->num_ver_coefs     = binary->dis.coef.dim.height;
 
-#if defined(IS_ISP_2500_SYSTEM)
-	assert(pipe != NULL);
-	dvs_info->enable            = binary->info->sp.enable.dvs_stats;
+	sh_css_binary_common_grid_info(binary, info);
+}
+
+void
+ia_css_binary_dvs_stat_grid_info(
+	const struct ia_css_binary *binary,
+	struct ia_css_grid_info *info,
+	struct ia_css_pipe *pipe)
+{
+#if defined(HAS_RES_MGR)
+	struct ia_css_dvs_stat_grid_info *dvs_stat_info;
+	unsigned int i;
+
+	assert(binary != NULL);
+	assert(info != NULL);
+	dvs_stat_info = &info->dvs_grid.dvs_stat_grid_info;
+
+	if (binary->info->sp.enable.dvs_stats) {
+		for (i = 0; i < IA_CSS_SKC_DVS_STAT_NUM_OF_LEVELS; i++) {
+			dvs_stat_info->grd_cfg[i].grd_start.enable = 1;
+		}
+		ia_css_dvs_stat_grid_calculate(pipe, dvs_stat_info);
+	}
+	else {
+		memset(dvs_stat_info, 0, sizeof(struct ia_css_dvs_stat_grid_info));
+	}
+
 #endif
+	(void)pipe;
+	sh_css_binary_common_grid_info(binary, info);
+	return;
 }
 
 enum ia_css_err
@@ -954,6 +994,7 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 	bool enable_high_speed;
 	bool enable_dvs_6axis;
 	bool enable_reduced_pipe;
+	bool enable_capture_pp_bli;
 	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
 	bool continuous;
 	unsigned int isp_pipe_version;
@@ -993,6 +1034,7 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 	enable_high_speed = descr->enable_high_speed;
 	enable_dvs_6axis  = descr->enable_dvs_6axis;
 	enable_reduced_pipe = descr->enable_reduced_pipe;
+	enable_capture_pp_bli = descr->enable_capture_pp_bli;
 	continuous = descr->continuous;
 	striped = descr->striped;
 	isp_pipe_version = descr->isp_pipe_version;
@@ -1276,6 +1318,13 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 			continue;
 		}
 
+		if (candidate->uds.use_bci && enable_capture_pp_bli) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
+				__LINE__, candidate->uds.use_bci,
+				descr->enable_capture_pp_bli);
+			continue;
+		}
 
 		/* reconfigure any variable properties of the binary */
 		err = ia_css_binary_fill_info(xcandidate, online, two_ppc,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h
index f9807a7..2a47fc4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/interface/ia_css_debug.h
@@ -68,11 +68,11 @@ enum ia_css_debug_enable_param_dump {
 
 #define IA_CSS_ERROR(fmt, ...) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, \
-		"%s(): error: " fmt "\n", __func__, ##__VA_ARGS__)
+		"%s() %d: error: " fmt "\n", __func__, __LINE__, ##__VA_ARGS__)
 
 #define IA_CSS_WARNING(fmt, ...) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_WARNING, \
-		"%s(): warning: " fmt "\n", __func__, ##__VA_ARGS__)
+		"%s() %d: warning: " fmt "\n", __func__, __LINE__, ##__VA_ARGS__)
 
 /* Logging macros for public functions (API functions) */
 #define IA_CSS_ENTER(fmt, ...) \
@@ -91,7 +91,7 @@ enum ia_css_debug_enable_param_dump {
 /* Shorthand for returning an enum ia_css_err return value */
 #define IA_CSS_LEAVE_ERR(__err) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \
-		"%s(): leave: return_err=%d\n", __func__, __err)
+		"%s() %d: leave: return_err=%d\n", __func__, __LINE__, __err)
 
 /* Use this macro for logging other than enter/leave.
  * Note that this macro always uses the PRIVATE logging level.
@@ -112,7 +112,7 @@ enum ia_css_debug_enable_param_dump {
 /* Shorthand for returning an enum ia_css_err return value */
 #define IA_CSS_LEAVE_ERR_PRIVATE(__err) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \
-		"%s(): leave: return_err=%d\n", __func__, __err)
+		"%s() %d: leave: return_err=%d\n", __func__, __LINE__, __err)
 
 /* Use this macro for small functions that do not call other functions. */
 #define IA_CSS_ENTER_LEAVE_PRIVATE(fmt, ...) \
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c
index f863d16..b71a9a1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/debug/src/ia_css_debug.c
@@ -3282,8 +3282,6 @@ ia_css_debug_dump_stream_config(
 			config->input_config.bayer_order);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sensor_binning_factor: %d\n",
 			config->sensor_binning_factor);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "two_pixels_per_clock: %d\n",
-			config->two_pixels_per_clock);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "pixels_per_clock: %d\n",
 			config->pixels_per_clock);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "online: %d\n",
@@ -3347,7 +3345,7 @@ static void debug_dump_one_trace(TRACE_CORE_ID proc_id)
 	uint32_t tmp;
 	int i, j, max_trace_points, point_num, limit = -1;
 	/* using a static buffer here as the driver has issues allocating memory */
-	static uint32_t trace_read_buf[TRACE_BUFF_SIZE];
+	static uint32_t trace_read_buf[TRACE_BUFF_SIZE] = {0};
 
 	/* read the header and parse it */
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "~~~ Tracer ");
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/csi_rx_rmgr.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/csi_rx_rmgr.c
index c2d67b3..990a3e0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/csi_rx_rmgr.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/isys/src/csi_rx_rmgr.c
@@ -44,8 +44,8 @@ bool ia_css_isys_csi_rx_lut_rmgr_acquire(
 	csi_rx_backend_lut_entry_t	*entry)
 {
 	bool retval = false;
-	uint16_t max_num_packets_of_type;
-	uint16_t num_active_of_type;
+	uint32_t max_num_packets_of_type;
+	uint32_t num_active_of_type;
 	isys_csi_rx_rsrc_t *cur_rsrc = NULL;
 	uint16_t i;
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/queue/src/queue_access.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/queue/src/queue_access.h
index 9700492..c2281dd 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/queue/src/queue_access.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/queue/src/queue_access.h
@@ -41,13 +41,13 @@
 	QUEUE_IGNORE_END_FLAG	  | \
 	QUEUE_IGNORE_STEP_FLAG)
 
-#define QUEUE_CB_DESC_INIT(cb_desc) \
-	do { \
-		(cb_desc)->size = 0;		\
-		(cb_desc)->step = 0;		\
-		(cb_desc)->start = 0;		\
-		(cb_desc)->end = 0;		\
-	} while (0)
+#define QUEUE_CB_DESC_INIT(cb_desc)	\
+	do {				\
+		(cb_desc)->size  = 0;	\
+		(cb_desc)->step  = 0;	\
+		(cb_desc)->start = 0;	\
+		(cb_desc)->end   = 0;	\
+	} while(0)
 
 struct ia_css_queue {
 	uint8_t type;        /* Specify remote/local type of access */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c
index e737aef..8718361 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/runtime/spctrl/src/spctrl.c
@@ -79,8 +79,8 @@ enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
 	if (sizeof(hrt_vaddress) > sizeof(hrt_data)) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
 				    "size of hrt_vaddress can not be greater than hrt_data\n");
-		mmgr_free(spctrl_cfg->code_size);
-		spctrl_cfg->code_size = mmgr_NULL;
+		mmgr_free(code_addr);
+		code_addr = mmgr_NULL;
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	}
 
@@ -88,8 +88,8 @@ enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
 	if ((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) != 0) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
 				    "DDR address pointer is not properly aligned for DMA transfer\n");
-		mmgr_free(spctrl_cfg->code_size);
-		spctrl_cfg->code_size = mmgr_NULL;
+		mmgr_free(code_addr);
+		code_addr = mmgr_NULL;
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	}
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c
index 61caf40..fd6474d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css.c
@@ -100,6 +100,10 @@ static int thread_alive;
 #include "components/acc_cluster/gen/host/acc_cluster.host.h"
 #endif
 
+#if defined(IS_ISP_2500_SYSTEM)
+#include "components/dvs/sc_dvs_1.0/host/dvs.host.h"
+#endif
+
 /* Name of the sp program: should not be built-in */
 #define SP_PROG_NAME "sp"
 #if defined(HAS_SEC_SP)
@@ -184,10 +188,7 @@ static bool fw_explicitly_loaded = false;
  * Local prototypes
  */
 static enum ia_css_err
-allocate_delay_frames(enum ia_css_pipe_id mode,
-		struct ia_css_video_settings *mycs_video,
-		struct ia_css_capture_settings *mycs_capture,
-		unsigned int dvs_frame_delay);
+allocate_delay_frames(struct ia_css_pipe *pipe);
 
 static enum ia_css_err
 sh_css_pipe_start(struct ia_css_stream *stream);
@@ -208,7 +209,7 @@ sh_css_init_host_sp_control_vars(void);
 static void
 sh_css_mmu_set_page_table_base_index(hrt_data base_index);
 
-static enum ia_css_err set_num_primary_stages(unsigned int *num, unsigned int version);
+static enum ia_css_err set_num_primary_stages(unsigned int *num, enum ia_css_pipe_version version);
 
 static bool
 need_capture_pp(const struct ia_css_pipe *pipe);
@@ -228,6 +229,8 @@ static bool
 need_downscaling(const struct ia_css_resolution in_res,
 		const struct ia_css_resolution out_res);
 
+static bool need_capt_ldc(const struct ia_css_pipe *pipe);
+
 static enum ia_css_err
 sh_css_pipe_load_binaries(struct ia_css_pipe *pipe);
 
@@ -1791,6 +1794,10 @@ ia_css_init(const struct ia_css_env *env,
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 #endif
 
+#if !defined(IS_ISP_2500_SYSTEM)
+	sh_css_params_map_and_store_default_gdc_lut();
+#endif
+
 	IA_CSS_LEAVE_ERR(err);
 	return err;
 }
@@ -2475,6 +2482,11 @@ ia_css_pipe_destroy(struct ia_css_pipe *pipe)
 		break;
 	}
 
+	if (pipe->scaler_pp_lut != mmgr_NULL) {
+		mmgr_free(pipe->scaler_pp_lut);
+		pipe->scaler_pp_lut = mmgr_NULL;
+	}
+
 	my_css.active_pipes[ia_css_pipe_get_pipe_num(pipe)] = NULL;
 	sh_css_pipe_free_shading_table(pipe);
 
@@ -2499,6 +2511,11 @@ ia_css_uninit(void)
 	print_pc_histogram();
 #endif
 
+#if !defined(IS_ISP_2500_SYSTEM)
+	sh_css_params_free_default_gdc_lut();
+#endif
+
+
 	/* TODO: JB: implement decent check and handling of freeing mipi frames */
 	//assert(ref_count_mipi_allocation == 0); //mipi frames are not freed
 	/* cleanup generic data */
@@ -4555,7 +4572,6 @@ static enum ia_css_event_type convert_event_sp_to_host_domain[] = {
 	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE,	/**< Extension stage executed. */
 	IA_CSS_EVENT_TYPE_TIMER,		/**< Timing measurement data. */
 	IA_CSS_EVENT_TYPE_PORT_EOF,		/**< End Of Frame event, sent when in buffered sensor mode. */
-	IA_CSS_EVENT_TYPE_FW_ERROR,		/**< Unrecoverable error encountered by FW. */
 	IA_CSS_EVENT_TYPE_FW_WARNING,		/**< Performance warning encountered by FW */
 	IA_CSS_EVENT_TYPE_FW_ASSERT,		/**< Assertion hit by FW */
 	0,					/** error if sp passes  SH_CSS_SP_EVENT_NR_OF_TYPES as a valid event. */
@@ -4608,7 +4624,6 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	event->pipe = NULL;
 	event->port = IA_CSS_CSI2_PORT0;
 	event->exp_id = 0;
-	event->fw_error = IA_CSS_FW_SUCCESS;
 	event->fw_warning = IA_CSS_FW_WARNING_NONE;
 	event->fw_handle = 0;
 	event->timer_data = 0;
@@ -4616,7 +4631,7 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	event->timer_subcode = 0;
 
 	if (event->type == IA_CSS_EVENT_TYPE_TIMER) {
-		/* timer event  get the 2nd event and decode the data into the event struct */
+		/* timer event ??? get the 2nd event and decode the data into the event struct */
 		uint32_t tmp_data;
 		/* 1st event: LSB 16-bit timer data and code */
 		event->timer_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));
@@ -4624,7 +4639,7 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 		payload[0] = payload[1] = payload[2] = payload[3] = 0;
 		ret_err = ia_css_bufq_dequeue_psys_event(payload);
 		if (ret_err != IA_CSS_SUCCESS) {
-			/* no 2nd event  an error */
+			/* no 2nd event ??? an error */
 			/* Putting IA_CSS_ERROR is resulting in failures in
 			 * Merrifield smoke testing  */
 			IA_CSS_WARNING("Timer: Error de-queuing the 2nd TIMER event!!!\n");
@@ -4655,8 +4670,6 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	if (event->type == IA_CSS_EVENT_TYPE_PORT_EOF) {
 		event->port = (enum ia_css_csi2_port)payload[1];
 		event->exp_id = payload[3];
-	} else if (event->type == IA_CSS_EVENT_TYPE_FW_ERROR) {
-		event->fw_error = (enum ia_css_fw_err)payload[1];
 	} else if (event->type == IA_CSS_EVENT_TYPE_FW_WARNING) {
 		event->fw_warning = (enum ia_css_fw_warning)payload[1];
 		/* exp_id is only available in these warning types */
@@ -5100,7 +5113,6 @@ sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
 
 	binary = ia_css_pipe_get_s3a_binary(pipe);
 
-
 	if (binary) {
 		err = ia_css_binary_3a_grid_info(binary, info, pipe);
 		if (err != IA_CSS_SUCCESS)
@@ -5110,10 +5122,15 @@ sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
 
 	binary = ia_css_pipe_get_sdis_binary(pipe);
 
-	if (binary)
+	if (binary) {
 		ia_css_binary_dvs_grid_info(binary, info, pipe);
-	else
-		memset(&info->dvs_grid, 0, sizeof(info->dvs_grid));
+		ia_css_binary_dvs_stat_grid_info(binary, info, pipe);
+	} else {
+		memset(&info->dvs_grid.dvs_grid_info, 0,
+			   sizeof(info->dvs_grid.dvs_grid_info));
+		memset(&info->dvs_grid.dvs_stat_grid_info, 0,
+			   sizeof(info->dvs_grid.dvs_stat_grid_info));
+	}
 
 	if (binary != NULL) {
 		/* copy pipe does not have ISP binary*/
@@ -5278,10 +5295,12 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 					 &mycs->video_binary);
 
 		if (err != IA_CSS_SUCCESS) {
+#if !defined(IS_ISP_2500_SYSTEM)
 			if (video_vf_info) {
 				/* This will do another video binary lookup later for YUV_LINE format*/
 				need_vf_pp = true;
 			} else
+#endif
 				return err;
 		} else if (video_vf_info) {
 			/* The first video binary lookup is successful, but we may
@@ -5310,7 +5329,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 
 			vf_info_format = video_vf_info->format;
 
-			ia_css_frame_info_set_format(video_vf_info,
+			if (!pipe->config.enable_vfpp_bci)
+				ia_css_frame_info_set_format(video_vf_info,
 					IA_CSS_FRAME_FORMAT_YUV_LINE);
 
 			ia_css_binary_destroy_isp_parameters(&mycs->video_binary);
@@ -5369,9 +5389,20 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {
 		struct ia_css_binary_descr vf_pp_descr;
 
-		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
-			&mycs->video_binary.vf_frame_info,
-			pipe_vf_out_info);
+		if (mycs->video_binary.vf_frame_info.format
+				== IA_CSS_FRAME_FORMAT_YUV_LINE) {
+			ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
+				&mycs->video_binary.vf_frame_info,
+				pipe_vf_out_info);
+		} else {
+			/* output from main binary is not yuv line. currently this is
+			 * possible only when bci is enabled on vfpp output */
+			assert(pipe->config.enable_vfpp_bci == true);
+			ia_css_pipe_get_yuvscaler_binarydesc(pipe, &vf_pp_descr,
+				&mycs->video_binary.vf_frame_info,
+				pipe_vf_out_info, NULL, NULL);
+		}
+
 		err = ia_css_binary_find(&vf_pp_descr,
 				&mycs->vf_pp_binary);
 		if (err != IA_CSS_SUCCESS)
@@ -5379,7 +5410,7 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	}
 #endif
 
-	err = allocate_delay_frames(pipe->mode, mycs, NULL, pipe->dvs_frame_delay);
+	err = allocate_delay_frames(pipe);
 
 	if (err != IA_CSS_SUCCESS)
 		return err;
@@ -5653,7 +5684,16 @@ static bool need_capture_pp(
 	return false;
 }
 
-static enum ia_css_err set_num_primary_stages(unsigned int *num, unsigned int version)
+static bool need_capt_ldc(
+	const struct ia_css_pipe *pipe)
+{
+	IA_CSS_ENTER_LEAVE_PRIVATE("");
+	assert(pipe != NULL);
+	assert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);
+	return (pipe->extra_config.enable_dvs_6axis) ? true:false;
+}
+
+static enum ia_css_err set_num_primary_stages(unsigned int *num, enum ia_css_pipe_version version)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
@@ -5684,6 +5724,7 @@ static enum ia_css_err load_primary_binaries(
 	bool continuous = false;
 	bool need_pp = false;
 	bool need_isp_copy_binary = false;
+	bool need_ldc = false;
 #ifdef USE_INPUT_SYSTEM_VERSION_2401
 	bool sensor = false;
 #endif
@@ -5691,7 +5732,8 @@ static enum ia_css_err load_primary_binaries(
 				 prim_out_info,
 				 capt_pp_out_info, vf_info,
 				 *vf_pp_in_info, *pipe_out_info,
-				 *pipe_vf_out_info;
+				 *pipe_vf_out_info, *capt_pp_in_info,
+				 capt_ldc_out_info;
 #if defined(HAS_RES_MGR)
 	struct ia_css_frame_info bds_out_info;
 #endif
@@ -5837,12 +5879,17 @@ static enum ia_css_err load_primary_binaries(
 		capt_pp_out_info = pipe->output_info[0];
 	}
 
+	/* TODO Do we disable ldc for skycam */
+	need_ldc = need_capt_ldc(pipe);
+
 	/* we build up the pipeline starting at the end */
 	/* Capture post-processing */
 	if (need_pp) {
 		struct ia_css_binary_descr capture_pp_descr;
+		capt_pp_in_info = need_ldc ? &capt_ldc_out_info : &prim_out_info;
+
 		ia_css_pipe_get_capturepp_binarydesc(pipe,
-			&capture_pp_descr, &prim_out_info,
+			&capture_pp_descr, capt_pp_in_info,
 			&capt_pp_out_info, &vf_info);
 #if defined(HAS_RES_MGR)
 			bds_out_info.res = pipe->config.bayer_ds_out_res;
@@ -5854,6 +5901,20 @@ static enum ia_css_err load_primary_binaries(
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
+
+		if(need_ldc) {
+			struct ia_css_binary_descr capt_ldc_descr;
+			ia_css_pipe_get_ldc_binarydesc(pipe,
+				&capt_ldc_descr, &prim_out_info,
+				&capt_ldc_out_info);
+
+			err = ia_css_binary_find(&capt_ldc_descr,
+						&mycs->capture_ldc_binary);
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
+				return err;
+			}
+		}
 	} else {
 		prim_out_info = *pipe_out_info;
 	}
@@ -5916,7 +5977,7 @@ static enum ia_css_err load_primary_binaries(
 		}
 	}
 #endif
-	err = allocate_delay_frames(pipe->mode, NULL, mycs, pipe->dvs_frame_delay);
+	err = allocate_delay_frames(pipe);
 
 	if (err != IA_CSS_SUCCESS)
 		return err;
@@ -5945,67 +6006,87 @@ static enum ia_css_err load_primary_binaries(
 }
 
 static enum ia_css_err
-allocate_delay_frames(enum ia_css_pipe_id mode,
-		struct ia_css_video_settings *mycs_video,
-		struct ia_css_capture_settings *mycs_capture,
-		unsigned int dvs_frame_delay)
+allocate_delay_frames(struct ia_css_pipe *pipe)
 {
 	unsigned int num_delay_frames = 0, i = 0;
+	unsigned int dvs_frame_delay = 0;
 	struct ia_css_frame_info ref_info;
 	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum ia_css_pipe_id mode = IA_CSS_PIPE_ID_VIDEO;
+	struct ia_css_frame **delay_frames = NULL;
 
-	if (((mode == IA_CSS_PIPE_ID_CAPTURE) && (mycs_capture == NULL)) ||
-	    ((mode == IA_CSS_PIPE_ID_VIDEO) && (mycs_video == NULL))) {
+	if (pipe == NULL) {
+		IA_CSS_ERROR("Invalid args - pipe %x", pipe);
 		return IA_CSS_ERR_INVALID_ARGUMENTS;
-	 }
+	}
 
-	if (mode == IA_CSS_PIPE_ID_CAPTURE) {
-#if defined (IS_ISP_2500_SYSTEM)
-		ref_info               = mycs_capture->primary_binary[0].internal_frame_info;
-		ref_info.format        = IA_CSS_FRAME_FORMAT_YUV420_16;
-		ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
+	mode = pipe->mode;
+	dvs_frame_delay = pipe->dvs_frame_delay;
+
+	if (dvs_frame_delay > 0)
+		num_delay_frames = dvs_frame_delay + 1;
+
+	switch (mode) {
+		case IA_CSS_PIPE_ID_CAPTURE:
+		{
+			struct ia_css_capture_settings *mycs_capture = &pipe->pipe_settings.capture;
+#ifndef IS_ISP_2500_SYSTEM
+			(void)mycs_capture;
+			return err;
 #else
-		return err;
+			ref_info = mycs_capture->primary_binary[0].internal_frame_info;
+			ref_info.format = IA_CSS_FRAME_FORMAT_YUV420_16;
+			/* There should be atleast 1 delay/ref frame for capture mode */
+			if (num_delay_frames == 0)
+				num_delay_frames = 1;
+			delay_frames = mycs_capture->delay_frames;
 #endif
-	} else if (mode == IA_CSS_PIPE_ID_VIDEO) {
-		ref_info               = mycs_video->video_binary.internal_frame_info;
-#if defined (IS_ISP_2500_SYSTEM)
-		ref_info.format        = IA_CSS_FRAME_FORMAT_YUV420_16;
+		}
+		break;
+		case IA_CSS_PIPE_ID_VIDEO:
+		{
+			struct ia_css_video_settings *mycs_video = &pipe->pipe_settings.video;
+			ref_info = mycs_video->video_binary.internal_frame_info;
+#ifdef IS_ISP_2500_SYSTEM
+			ref_info.format = IA_CSS_FRAME_FORMAT_YUV420_16;
 #else
-		ref_info.format        = IA_CSS_FRAME_FORMAT_YUV420;
+			/*The ref frame expects
+			 * 	1. Y plane
+			 * 	2. UV plane with line interleaving, like below
+			 * 		UUUUUU(width/2 times) VVVVVVVV..(width/2 times)
+			 *
+			 *	This format is not YUV420(which has Y, U and V planes).
+			 *	Its closer to NV12, except that the UV plane has UV 
+			 *	interleaving, like UVUVUVUVUVUVUVUVU...
+			 *
+			 *	TODO: make this ref_frame format as a separate frame format
+			 */
+			ref_info.format        = IA_CSS_FRAME_FORMAT_NV12;
 #endif
-		ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
-	} else {
-		return IA_CSS_ERR_INVALID_ARGUMENTS;
+			delay_frames = mycs_video->delay_frames;
+		}
+		break;
+		default:
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+
 	}
 
-	if (dvs_frame_delay > 0)
-		num_delay_frames = dvs_frame_delay + 1;
-	else {
-		if (mode == IA_CSS_PIPE_ID_CAPTURE)
-			num_delay_frames = 1; /* There should be atleast 1 delay/ref frame for capture mode */
-		else if (mode == IA_CSS_PIPE_ID_VIDEO)
-			num_delay_frames = 0;
-		else
-			return IA_CSS_ERR_INVALID_ARGUMENTS;
+	ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
+
+#ifdef IS_ISP_2500_SYSTEM
+	err = dvs_calc_gdc_in_buff_padding(&pipe->config, &ref_info);
+	if (err != IA_CSS_SUCCESS) {
+		return err;
 	}
+#endif
 
+	assert(num_delay_frames <= MAX_NUM_VIDEO_DELAY_FRAMES);
 	for (i = 0; i < num_delay_frames; i++) {
-		if (mode == IA_CSS_PIPE_ID_CAPTURE)
-			err = ia_css_frame_allocate_from_info(&mycs_capture->delay_frames[i],
-					&ref_info);
-		else if (mode == IA_CSS_PIPE_ID_VIDEO)
-			err = ia_css_frame_allocate_from_info(&mycs_video->delay_frames[i],
-					&ref_info);
-
+		err = ia_css_frame_allocate_from_info(&delay_frames[i],	&ref_info);
 		if (err != IA_CSS_SUCCESS)
 			return err;
-
 #ifdef HRT_CSIM
-		if (mode == IA_CSS_PIPE_ID_CAPTURE)
-			ia_css_frame_zero(mycs_capture->delay_frames[i]);
-		else if (mode == IA_CSS_PIPE_ID_VIDEO)
-			ia_css_frame_zero(mycs_video->delay_frames[i]);
+		ia_css_frame_zero(delay_frames[i]);
 #endif
 	}
 
@@ -6380,6 +6461,7 @@ unload_capture_binaries(struct ia_css_pipe *pipe)
 	ia_css_binary_unload(&pipe->pipe_settings.capture.anr_gdc_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.post_isp_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.capture_pp_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.capture_ldc_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.vf_pp_binary);
 
 	for (i = 0; i < pipe->pipe_settings.capture.num_yuv_scaler; i++)
@@ -6583,6 +6665,7 @@ static enum ia_css_err ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pi
 	in_info.res = pipe->config.input_effective_res;
 	in_info.padded_width = in_info.res.width;
 	descr->num_output_stage = 0;
+	/* Find out how much scaling we need for each output */
 	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
 		if (pipe->output_info[i].res.width != 0) {
 			out_info[i] = &pipe->output_info[i];
@@ -6596,29 +6679,21 @@ static enum ia_css_err ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pi
 			ver_scale_factor[i] = CEIL_DIV(in_info.res.height, out_info[i]->res.height);
 			/* use the same horizontal and vertical scaling factor for simplicity */
 			assert(hor_scale_factor[i] == ver_scale_factor[i]);
+			scale_factor = 1;
+			do {
+				num_stages++;
+				scale_factor *= max_scale_factor_per_stage;
+			} while (scale_factor < hor_scale_factor[i]);
+
+			in_info.res = out_info[i]->res;
 		}
-		if (hor_scale_factor[i] > scale_factor)
-			scale_factor = hor_scale_factor[i];
 	}
 
-	i = 1;
-	while (i < scale_factor) {
-		num_stages++;
-		i *= max_scale_factor_per_stage;
-	}
 	if (need_yuv_scaler_stage(pipe) && (num_stages == 0))
 		num_stages = 1;
 
 	descr->num_stage = num_stages;
 
-	/* if two outputs requires the same number of scaling stages, we
-	 * extent it by one because we only have fixed number of output pins. */
-	if ((out_info[0] != NULL) && (out_info[1] != NULL) &&
-		((out_info[0]->res.width == out_info[1]->res.width) ||
-		(out_info[0]->res.width == in_info.res.width))&&
-		(descr->num_output_stage > 1)) {
-		descr->num_stage += 1;
-	}
 	descr->in_info = sh_css_malloc(descr->num_stage * sizeof(struct ia_css_frame_info));
 	if (descr->in_info == NULL) {
 		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
@@ -7412,7 +7487,8 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 			     *anr_gdc_binary,
 			     *post_isp_binary,
 			     *yuv_scaler_binary,
-			     *capture_pp_binary;
+			     *capture_pp_binary,
+			     *capture_ldc_binary;
 	bool need_pp = false;
 	bool raw;
 
@@ -7431,6 +7507,7 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	unsigned int i, num_yuv_scaler, num_primary_stage;
 	bool need_yuv_pp = false;
 	bool *is_output_stage = NULL;
+	bool need_ldc = false;
 
 	IA_CSS_ENTER_PRIVATE("");
 	assert(pipe != NULL);
@@ -7510,11 +7587,13 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	yuv_scaler_binary = pipe->pipe_settings.capture.yuv_scaler_binary;
 	num_yuv_scaler	  = pipe->pipe_settings.capture.num_yuv_scaler;
 	is_output_stage   = pipe->pipe_settings.capture.is_output_stage;
+	capture_ldc_binary = &pipe->pipe_settings.capture.capture_ldc_binary;
 
 	need_pp = (need_capture_pp(pipe) || pipe->output_stage) &&
 		  mode != IA_CSS_CAPTURE_MODE_RAW &&
 		  mode != IA_CSS_CAPTURE_MODE_BAYER;
 	need_yuv_pp = (yuv_scaler_binary != NULL && yuv_scaler_binary->info != NULL);
+	need_ldc = (capture_ldc_binary != NULL && capture_ldc_binary->info != NULL);
 
 	if (pipe->pipe_settings.capture.copy_binary.info) {
 		if (raw) {
@@ -7660,9 +7739,20 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 		}
 	}
 
-	if (need_pp) {
-		in_frame = current_stage->args.out_frame[0];
-		err = add_capture_pp_stage(pipe, me, in_frame, need_yuv_pp ? NULL : out_frame,
+	if (need_pp && current_stage) {
+		struct ia_css_frame *local_in_frame = NULL;
+		local_in_frame = current_stage->args.out_frame[0];
+
+		if(need_ldc) {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, capture_ldc_binary,
+				out_frames, local_in_frame, NULL);
+			err = ia_css_pipeline_create_and_add_stage(me,
+				&stage_desc,
+				&current_stage);
+			local_in_frame = current_stage->args.out_frame[0];
+		}
+		err = add_capture_pp_stage(pipe, me, local_in_frame, need_yuv_pp ? NULL : out_frame,
 					   capture_pp_binary,
 					   &current_stage);
 		if (err != IA_CSS_SUCCESS) {
@@ -8337,6 +8427,7 @@ void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config)
 	memset(stream_config, 0, sizeof(*stream_config));
 	stream_config->online = true;
 	stream_config->left_padding = -1;
+	stream_config->pixels_per_clock = 1;
 	/* temporary default value for backwards compatibility.
 	 * This field used to be hardcoded within CSS but this has now
 	 * been moved to the stream_config struct. */
@@ -8433,8 +8524,14 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 	else
 		internal_pipe->dvs_frame_delay = 1;
 
+	/* skycam has delayed frames in capture and video */
+#if defined(IS_ISP_2500_SYSTEM)
+	if (internal_pipe->config.mode != IA_CSS_PIPE_MODE_CAPTURE && internal_pipe->config.mode != IA_CSS_PIPE_MODE_VIDEO)
+		internal_pipe->dvs_frame_delay = 0;
+#else
 	if (internal_pipe->config.mode != IA_CSS_PIPE_MODE_VIDEO)
 		internal_pipe->dvs_frame_delay = 0;
+#endif
 
 	/* we still keep enable_raw_binning for backward compatibility, for any new
 	   fractional bayer downscaling, we should use bayer_ds_out_res. if both are
@@ -8563,6 +8660,20 @@ ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
 	return IA_CSS_SUCCESS;
 }
 
+bool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info)
+{
+	unsigned int i;
+
+	if (pipe_info != NULL) {
+		for (i = 0; i < IA_CSS_DVS_STAT_NUM_OF_LEVELS; i++) {
+			if (pipe_info->grid_info.dvs_grid.dvs_stat_grid_info.grd_cfg[i].grd_start.enable)
+				return true;
+		}
+	}
+
+	return false;
+}
+
 #if defined(USE_INPUT_SYSTEM_VERSION_2)
 /* Configuration of INPUT_SYSTEM_VERSION_2401 is done on SP */
 static enum ia_css_err
@@ -8832,11 +8943,6 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		curr_stream->config.mode =  IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
 	}
 #endif
-	/* TO BE REMOVED when all drivers move to CSS API 2.1 */
-	if (curr_stream->config.pixels_per_clock == 0)
-		curr_stream->config.pixels_per_clock =
-			curr_stream->config.two_pixels_per_clock ? 2 : 1;
-
 	/* in case driver doesn't configure init number of raw buffers, configure it here */
 	if (curr_stream->config.target_num_cont_raw_buf == 0)
 		curr_stream->config.target_num_cont_raw_buf = NUM_CONTINUOUS_FRAMES;
@@ -9612,7 +9718,7 @@ ia_css_pipe_get_sdis_binary(const struct ia_css_pipe *pipe)
 #endif
 		binary = NULL;
 
-        return binary;
+	return binary;
 }
 
 #if defined(IS_ISP_2500_SYSTEM)
@@ -9668,7 +9774,8 @@ ia_css_pipe_get_dvs_filter(const struct ia_css_pipe *pipe, struct ia_css_resolut
 		IA_CSS_ERROR("Invalid args: pipe %x res %x", pipe, res);
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 	} else {
-		res->width = res->height = SH_CSS_MIN_DVS_ENVELOPE; /* MIN DVS ENV is the filter size used by GDC */
+		/* MIN DVS ENV is the filter size used by GDC */
+		res->width = res->height = SH_CSS_MIN_DVS_ENVELOPE;
 	}
 	return err;
 }
@@ -9684,9 +9791,8 @@ ia_css_pipe_get_gdc_in_buffer_info(const struct ia_css_pipe *pipe,
 		IA_CSS_ERROR("Invalid args: pipe %x res %x offset %x", pipe, res, offset);
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 	} else {
-		ia_css_pipe_get_bds_resolution(pipe, res);
-		offset->x = 0;
-		offset->y = 0;
+		*res = pipe->config.gdc_in_buffer_res;
+		*offset = pipe->config.gdc_in_buffer_offset;
 	}
 	return err;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c
index 27659e8..e3f0303 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_firmware.c
@@ -47,10 +47,10 @@ struct fw_param {
 /* Warning: same order as SH_CSS_BINARY_ID_* */
 static struct firmware_header *firmware_header;
 
-/* The string STR(irci_master_20150131_0457) is a place holder
+/* The string STR(irci_master_20150303_1500) is a place holder
  * which will be replaced with the actual RELEASE_VERSION
  * during package generation. Please do not modify  */
-static const char *release_version = STR(irci_master_20150131_0457);
+static const char *release_version = STR(irci_master_20150303_1500);
 
 #define MAX_FW_REL_VER_NAME	300
 static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_hrt.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_hrt.c
index 4e6aeb8..0bfebce 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_hrt.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_hrt.c
@@ -30,16 +30,8 @@
 #define __INLINE_FIFO_MONITOR__
 #include "fifo_monitor.h"
 
-#if !defined(HAS_NO_INPUT_SYSTEM)
-#include "input_system.h"	/* MIPI_PREDICTOR_NONE,... */
-#endif
-
 /* System independent */
 #include "sh_css_internal.h"
-#if !defined(HAS_NO_INPUT_SYSTEM)
-#include "ia_css_isys.h"
-#endif
-
 
 bool sh_css_hrt_system_is_idle(void)
 {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h
index ccebd57..905eee8 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_internal.h
@@ -230,7 +230,6 @@ enum sh_css_sp_event_type {
 	SH_CSS_SP_EVENT_ACC_STAGE_COMPLETE,
 	SH_CSS_SP_EVENT_TIMER,
 	SH_CSS_SP_EVENT_PORT_EOF,
-	SH_CSS_SP_EVENT_FW_ERROR,
 	SH_CSS_SP_EVENT_FW_WARNING,
 	SH_CSS_SP_EVENT_FW_ASSERT,
 	SH_CSS_SP_EVENT_NR_OF_TYPES		/* must be last */
@@ -537,11 +536,15 @@ ia_css_metadata_free_multiple(unsigned int num_bufs, struct ia_css_metadata **bu
 
 /* Macro for handling pipe_qos_config */
 #define QOS_INVALID                  (~0U)
+#define QOS_ALL_STAGES_DISABLED      (0U)
 #define QOS_STAGE_MASK(num)          (0x00000001 << num)
 #define SH_CSS_IS_QOS_PIPE(pipe)               ((pipe)->pipe_qos_config != QOS_INVALID)
 #define SH_CSS_QOS_STAGE_ENABLE(pipe, num)     ((pipe)->pipe_qos_config |= QOS_STAGE_MASK(num))
 #define SH_CSS_QOS_STAGE_DISABLE(pipe, num)    ((pipe)->pipe_qos_config &= ~QOS_STAGE_MASK(num))
 #define SH_CSS_QOS_STAGE_IS_ENABLED(pipe, num) ((pipe)->pipe_qos_config & QOS_STAGE_MASK(num))
+#define SH_CSS_QOS_MODE_PIPE_ADD(mode, pipe)    ((mode) |= (0x1 << (pipe)->pipe_id))
+#define SH_CSS_QOS_MODE_PIPE_REMOVE(mode, pipe) ((mode) &= ~(0x1 << (pipe)->pipe_id))
+#define SH_CSS_IS_QOS_ONLY_MODE(mode)           ((mode) == (0x1 << IA_CSS_PIPE_ID_ACC))
 
 /* Information for a pipeline */
 struct sh_css_sp_pipeline {
@@ -561,6 +564,7 @@ struct sh_css_sp_pipeline {
 	uint32_t	num_stages;		/* the pipe config */
 	uint32_t	running;	/* needed for pipe termination */
 	hrt_vaddress	sp_stage_addr[SH_CSS_MAX_STAGES];
+	hrt_vaddress	scaler_pp_lut; /* Early bound LUT */
 #ifndef __SP
 	uint32_t	dummy; /* stage ptr is only used on sp but lives in
 				  this struct; needs cleanup */
@@ -1022,9 +1026,6 @@ sh_css_params_init(void);
 void
 sh_css_params_uninit(void);
 
-void
-sh_css_params_reconfigure_gdc_lut(void);
-
 void *
 sh_css_malloc(size_t size);
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.c
index 598baea..acc3e3b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.c
@@ -19,6 +19,7 @@
 #include "sh_css_defs.h"
 #include "sh_css_internal.h"
 #include "ia_css_debug.h"
+#include "ia_css_pipe_binarydesc.h"
 
 #include "sh_css_hrt.h"
 
@@ -70,7 +71,8 @@ static void
 crop_and_interpolate(unsigned int cropped_width,
 		     unsigned int cropped_height,
 		     unsigned int left_padding,
-		     unsigned int right_padding,
+		     int right_padding,
+		     int top_padding,
 		     const struct ia_css_shading_table *in_table,
 		     struct ia_css_shading_table *out_table,
 		     enum ia_css_sc_color color)
@@ -104,29 +106,31 @@ crop_and_interpolate(unsigned int cropped_width,
 	out_cell_size = CEIL_DIV(padded_width, out_table->width - 1);
 	in_cell_size  = CEIL_DIV(sensor_width, table_width - 1);
 
-	out_start_col = (sensor_width - cropped_width)/2 - left_padding;
-	out_start_row = (sensor_height - cropped_height)/2;
+	out_start_col = ((int)sensor_width - (int)cropped_width)/2 - left_padding;
+	out_start_row = ((int)sensor_height - (int)cropped_height)/2 - top_padding;
 	table_cell_w = (int)((table_width-1) * in_cell_size);
 	table_cell_h = (table_height-1) * in_cell_size;
 
 	for (i = 0; i < out_table->height; i++) {
-		unsigned int ty, src_y0, src_y1, sy0, sy1, dy0, dy1, divy;
+		int ty, src_y0, src_y1;
+		unsigned int sy0, sy1, dy0, dy1, divy;
 
 		/* calculate target point and make sure it falls within
 		   the table */
 		ty = out_start_row + i * out_cell_size;
-		ty = min(ty, sensor_height-1);
-		ty = min(ty, table_cell_h);
 
 		/* calculate closest source points in shading table and
 		   make sure they fall within the table */
-		src_y0 = ty / in_cell_size;
+		src_y0 = ty / (int)in_cell_size;
 		if (in_cell_size < out_cell_size)
 			src_y1 = (ty + out_cell_size) / in_cell_size;
 		else
 			src_y1 = src_y0 + 1;
-		src_y0 = min(src_y0, table_height-1);
-		src_y1 = min(src_y1, table_height-1);
+		src_y0 = clamp(src_y0, 0, (int)table_height-1);
+		src_y1 = clamp(src_y1, 0, (int)table_height-1);
+		ty = min(clamp(ty, 0, (int)sensor_height-1),
+				 (int)table_cell_h);
+
 		/* calculate closest source points for distance computation */
 		sy0 = min(src_y0 * in_cell_size, sensor_height-1);
 		sy1 = min(src_y1 * in_cell_size, sensor_height-1);
@@ -221,15 +225,21 @@ void
 prepare_shading_table(const struct ia_css_shading_table *in_table,
 		      unsigned int sensor_binning,
 		      struct ia_css_shading_table **target_table,
-		      const struct ia_css_binary *binary)
+		      const struct ia_css_binary *binary,
+		      unsigned int bds_factor)
 {
 	unsigned int input_width,
 		     input_height,
 		     table_width,
 		     table_height,
 		     left_padding,
-		     right_padding,
+		     top_padding,
+		     padded_width,
+		     left_cropping,
 		     i;
+	unsigned int bds_numerator, bds_denominator;
+	int right_padding;
+
 	struct ia_css_shading_table *result;
 
 	assert(target_table != NULL);
@@ -240,14 +250,26 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 		return;
 	}
 
+	padded_width = binary->in_frame_info.padded_width;
 	/* We use the ISP input resolution for the shading table because
 	   shading correction is performed in the bayer domain (before bayer
 	   down scaling). */
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	padded_width = CEIL_MUL(binary->effective_in_frame_res.width + 2*ISP_VEC_NELEMS,
+					2*ISP_VEC_NELEMS);
+#endif
 	input_height  = binary->in_frame_info.res.height;
 	input_width   = binary->in_frame_info.res.width;
 	left_padding  = binary->left_padding;
-	right_padding = binary->in_frame_info.padded_width -
-			(input_width + left_padding);
+	left_cropping = (binary->info->sp.pipeline.left_cropping == 0) ?
+			binary->dvs_envelope.width : 2*ISP_VEC_NELEMS;
+
+	sh_css_bds_factor_get_numerator_denominator
+		(bds_factor, &bds_numerator, &bds_denominator);
+
+	left_padding  = (left_padding + binary->info->sp.pipeline.left_cropping) * bds_numerator / bds_denominator - binary->info->sp.pipeline.left_cropping;
+	right_padding = (binary->internal_frame_info.res.width - binary->effective_in_frame_res.width * bds_denominator / bds_numerator - left_cropping) * bds_numerator / bds_denominator;
+	top_padding = binary->info->sp.pipeline.top_cropping * bds_numerator / bds_denominator - binary->info->sp.pipeline.top_cropping;
 
 	/* We take into account the binning done by the sensor. We do this
 	   by cropping the non-binned part of the shading table and then
@@ -259,6 +281,7 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	   shading table. */
 	left_padding  <<= sensor_binning;
 	right_padding <<= sensor_binning;
+	top_padding   <<= sensor_binning;
 
 	/* during simulation, the used resolution can exceed the sensor
 	   resolution, so we clip it. */
@@ -281,7 +304,7 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	   requested resolution and decimation factor. */
 	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
 		crop_and_interpolate(input_width, input_height,
-				     left_padding, right_padding,
+				     left_padding, right_padding, top_padding,
 				     in_table,
 				     result, i);
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.h
index 6620681..acc049d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_param_shading.h
@@ -27,7 +27,8 @@ void
 prepare_shading_table(const struct ia_css_shading_table *in_table,
 		      unsigned int sensor_binning,
 		      struct ia_css_shading_table **target_table,
-		      const struct ia_css_binary *binary);
+		      const struct ia_css_binary *binary,
+		      unsigned int bds_factor);
 
 #endif /* __SH_CSS_PARAMS_SHADING_H */
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c
index 5f8e9fa..065518c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.c
@@ -30,6 +30,7 @@
 
 #include "platform_support.h"
 #include "assert_support.h"
+#include "misc_support.h"	/* NOT_USED */
 #include "math_support.h"	/* max(), min()  EVEN_FLOOR()*/
 
 #include "ia_css_stream.h"
@@ -152,6 +153,11 @@ static hrt_vaddress xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
 static hrt_vaddress xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
 						[SH_CSS_MAX_STAGES];
 
+#if !defined(IS_ISP_2500_SYSTEM)
+static hrt_vaddress default_gdc_lut;
+static int interleaved_lut_temp[4][HRT_GDC_N];
+#endif
+
 /* END DO NOT MOVE INTO VIMALS_WORLD */
 
 /* Digital Zoom lookup table. See documentation for more details about the
@@ -1384,14 +1390,14 @@ store_fpntbl(struct ia_css_isp_parameters *params, hrt_vaddress ptr)
 static void
 convert_raw_to_fpn(struct ia_css_isp_parameters *params)
 {
-	short maxval = 0;
+	int maxval = 0;
 	unsigned int i;
 
 	assert(params != NULL);
 
 	/* Find the maximum value in the table */
 	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++) {
-		short val = params->fpn_config.data[i];
+		int val = params->fpn_config.data[i];
 		/* Make sure FPN value can be represented in 13-bit unsigned
 		 * number (ISP precision - 1), but note that actual input range
 		 * depends on precision of input frame data.
@@ -1412,7 +1418,7 @@ convert_raw_to_fpn(struct ia_css_isp_parameters *params)
 	params->fpn_config.shift = 0;
 	while (maxval > 63) {
 /* MW: BUG, is "63" a system or application property */
-		maxval /= 2;
+		maxval >>= 1;
 		params->fpn_config.shift++;
 	}
 	/* Adjust the values in the table for the shift value */
@@ -2383,21 +2389,23 @@ sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
 
 #if !defined(IS_ISP_2500_SYSTEM)
 static void
-sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
-			   const struct ia_css_dvs_6axis_config  *dvs_config)
+sh_css_set_pipe_dvs_6axis_config(const struct ia_css_pipe *pipe,
+							struct ia_css_isp_parameters *params,
+							const struct ia_css_dvs_6axis_config  *dvs_config)
 {
 	if (dvs_config == NULL)
 		return;
 	assert(params != NULL);
+	assert(pipe != NULL);
 	assert(dvs_config->height_y == dvs_config->height_uv);
 	assert((dvs_config->width_y - 1) == 2 * (dvs_config->width_uv - 1));
 
 	IA_CSS_ENTER_PRIVATE("dvs_config=%p", dvs_config);
 
-	copy_dvs_6axis_table(params->dvs_6axis_config, dvs_config);
+	copy_dvs_6axis_table(params->pipe_dvs_6axis_config[pipe->mode], dvs_config);
 
 #if !defined(HAS_NO_DVS_6AXIS_CONFIG_UPDATE)
-	params->dvs_6axis_config_changed = true;
+	params->pipe_dvs_6axis_config_changed[pipe->mode] = true;
 #endif
 
 	IA_CSS_LEAVE_PRIVATE("void");
@@ -2406,27 +2414,29 @@ sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
 
 #if !defined(IS_ISP_2500_SYSTEM)
 static void
-sh_css_get_dvs_6axis_config(const struct ia_css_isp_parameters *params,
+sh_css_get_pipe_dvs_6axis_config(const struct ia_css_pipe *pipe,
+				const struct ia_css_isp_parameters *params,
 				struct ia_css_dvs_6axis_config *dvs_config)
 {
 	if (dvs_config == NULL)
 		return;
 	assert(params != NULL);
+	assert(pipe != NULL);
 	assert(dvs_config->height_y == dvs_config->height_uv);
 	assert((dvs_config->width_y - 1) == 2 * dvs_config->width_uv - 1);
 
 	IA_CSS_ENTER_PRIVATE("dvs_config=%p", dvs_config);
 
-	if ((dvs_config->width_y == params->dvs_6axis_config->width_y) &&
-	    (dvs_config->height_y == params->dvs_6axis_config->height_y) &&
-	    (dvs_config->width_uv == params->dvs_6axis_config->width_uv) &&
-	    (dvs_config->height_uv == params->dvs_6axis_config->height_uv) &&
+	if ((dvs_config->width_y == params->pipe_dvs_6axis_config[pipe->mode]->width_y) &&
+	    (dvs_config->height_y == params->pipe_dvs_6axis_config[pipe->mode]->height_y) &&
+	    (dvs_config->width_uv == params->pipe_dvs_6axis_config[pipe->mode]->width_uv) &&
+	    (dvs_config->height_uv == params->pipe_dvs_6axis_config[pipe->mode]->height_uv) &&
 	     dvs_config->xcoords_y &&
 	     dvs_config->ycoords_y &&
 	     dvs_config->xcoords_uv &&
 	     dvs_config->ycoords_uv)
 	{
-		copy_dvs_6axis_table(dvs_config, params->dvs_6axis_config);
+		copy_dvs_6axis_table(dvs_config, params->pipe_dvs_6axis_config[pipe->mode]);
 	}
 
 	IA_CSS_LEAVE_PRIVATE("void");
@@ -2604,12 +2614,6 @@ ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config=%p\n", config);
 
-	/* When pipe config and stream configs are seperated the below assignement
-	 * pipe_in = NULL can be removed
-	 */
-	if(pipe->stream->config.continuous)
-		pipe_in = NULL;
-
 #if defined(SH_CSS_ENABLE_PER_FRAME_PARAMS)
 	if (config->output_frame)
 		err = sh_css_set_per_frame_isp_config_on_pipe(pipe->stream, config, pipe);
@@ -2714,8 +2718,8 @@ sh_css_init_isp_params_from_config(struct ia_css_pipe *pipe,
 	sh_css_set_nr_config(params, config->nr_config);
 	sh_css_set_ee_config(params, config->ee_config);
 	sh_css_set_baa_config(params, config->baa_config);
-	if (params->dvs_6axis_config)
-		sh_css_set_dvs_6axis_config(params, config->dvs_6axis_config);
+	if (params->pipe_dvs_6axis_config[pipe->mode])
+		sh_css_set_pipe_dvs_6axis_config(pipe, params, config->dvs_6axis_config);
 	sh_css_set_dz_config(params, config->dz_config);
 	sh_css_set_motion_vector(params, config->motion_vector);
 	sh_css_set_shading_table(pipe->stream, params, config->shading_table);
@@ -2771,7 +2775,7 @@ ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
 #else
 	sh_css_get_ee_config(params, config->ee_config);
 	sh_css_get_baa_config(params, config->baa_config);
-	sh_css_get_dvs_6axis_config(params, config->dvs_6axis_config);
+	sh_css_get_pipe_dvs_6axis_config(pipe, params, config->dvs_6axis_config);
 	sh_css_get_macc_table(params, config->macc_table);
 	sh_css_get_gamma_table(params, config->gamma_table);
 	sh_css_get_ctc_table(params, config->ctc_table);
@@ -3067,7 +3071,6 @@ enum ia_css_err
 ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
-	unsigned isp_pipe_version = SH_CSS_ISP_PIPE_VERSION_1;
 	unsigned i;
 	struct sh_css_ddr_address_map *ddr_ptrs;
 	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
@@ -3084,17 +3087,6 @@ ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 	g_param_buffer_dequeue_count = 0;
 	g_param_buffer_enqueue_count = 0;
 
-	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
-	/* this code assumes that all the pipes have the same pipeversion. */
-	for (i = 1; i < (unsigned)stream->num_pipes; i++) {
-	    assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(stream->pipes[i]));
-	}
-
-	/* done once */
-#if !defined(IS_ISP_2500_SYSTEM)
-	sh_css_params_reconfigure_gdc_lut();
-#endif
-
 	stream->per_frame_isp_params_configs = NULL;
 	err = sh_css_create_isp_params(stream,
 				       &stream->isp_params_configs);
@@ -3233,6 +3225,7 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		bool use_default_config)
 {
 #if !defined(IS_ISP_2500_SYSTEM)
+	int i = 0;
 	unsigned isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
 #endif
 	struct ia_css_isp_parameters *stream_params = stream->isp_params_configs;
@@ -3292,7 +3285,6 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		ia_css_set_formats_config(params, &default_formats_config);
 		ia_css_set_param_exceptions(params);
 
-		/* gdc_lut_store is moved to ia_css_stream_isp_parameters_init() */
 		params->fpn_config.data = NULL;
 		params->config_changed[IA_CSS_FPN_ID] = true;
 		params->fpn_config.enabled = 0;
@@ -3306,9 +3298,6 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		params->sc_table = NULL;
 		params->sc_table_changed = true;
 
-		params->dvs_6axis_config = NULL;
-		params->dvs_6axis_config_changed = true;
-
 		ia_css_sdis2_clear_coefficients(&params->dvs2_coefs);
 		params->dvs2_coef_table_changed = true;
 
@@ -3367,8 +3356,6 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 
 		ia_css_set_param_exceptions(params);
 
-		/* gdc_lut_store is moved to ia_css_stream_isp_parameters_init() */
-
 		params->fpn_config.data = stream_params->fpn_config.data;
 		params->config_changed[IA_CSS_FPN_ID] = stream_params->config_changed[IA_CSS_FPN_ID];
 		params->fpn_config.enabled = stream_params->fpn_config.enabled;
@@ -3384,9 +3371,13 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 			params->sc_table_changed = true;
 		}
 
-		if (stream_params->dvs_6axis_config)
-			params->dvs_6axis_config = generate_dvs_6axis_table_from_config(stream_params->dvs_6axis_config);
-
+		/* Only IA_CSS_PIPE_ID_VIDEO & IA_CSS_PIPE_ID_CAPTURE will support dvs_6axis_config*/
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+			if (stream_params->pipe_dvs_6axis_config[i]) {
+				params->pipe_dvs_6axis_config[i] =
+						generate_dvs_6axis_table_from_config(stream_params->pipe_dvs_6axis_config[i]);
+				}
+		}
 		ia_css_set_sdis_config(params, &stream_params->dvs_coefs);
 		params->dis_coef_table_changed = stream_params->dis_coef_table_changed;
 
@@ -3454,16 +3445,120 @@ sh_css_params_init(void)
 }
 
 #if !defined(IS_ISP_2500_SYSTEM)
-void sh_css_params_reconfigure_gdc_lut(void)
+static void host_lut_store(const void *lut)
 {
 	unsigned i;
 
+	for (i = 0; i < N_GDC_ID; i++)
+		gdc_lut_store((gdc_ID_t)i, (const int (*)[HRT_GDC_N]) lut);
+}
+#endif
+
+enum ia_css_err ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe,
+	const void *lut)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool store = true;
+	IA_CSS_ENTER("pipe=%p lut=%p", pipe, lut);
+
+	if (lut == NULL || pipe == NULL) {
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+		IA_CSS_LEAVE("err=%d", err);
+		return err;
+	}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	/* If the pipe belongs to a stream and the stream has started, it is not
+	 * safe to store lut to gdc HW. If pipe->stream is NULL, then no stream is
+	 * created with this pipe, so it is safe to do this operation. */
+	if (pipe->stream && pipe->stream->started) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"unable to set scaler lut since stream has started\n");
+		store = false;
+		err = IA_CSS_ERR_NOT_SUPPORTED;
+	}
+
+	/* Free any existing tables. */
+	if (pipe->scaler_pp_lut != mmgr_NULL) {
+		mmgr_free(pipe->scaler_pp_lut);
+		pipe->scaler_pp_lut = mmgr_NULL;
+	}
+
+	if (store) {
+		pipe->scaler_pp_lut = mmgr_malloc(sizeof(zoom_table));
+		if (pipe->scaler_pp_lut == mmgr_NULL) {
+			IA_CSS_LEAVE("lut(%p) err=%d", pipe->scaler_pp_lut, err);
+			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+
+		gdc_lut_convert_to_isp_format((const int(*)[HRT_GDC_N])lut, interleaved_lut_temp);
+		mmgr_store(pipe->scaler_pp_lut, (int *)interleaved_lut_temp,
+			sizeof(zoom_table));
+	}
+#endif
+
+	IA_CSS_LEAVE("lut(%p) err=%d store(%d)", pipe->scaler_pp_lut, err, store);
+	return err;
+}
+
+/* if pipe is NULL, returns default lut addr. */
+hrt_vaddress sh_css_pipe_get_pp_gdc_lut(const struct ia_css_pipe *pipe)
+{
+#if !defined(IS_ISP_2500_SYSTEM)
+	assert(pipe != NULL);
+
+	if (pipe->scaler_pp_lut != mmgr_NULL)
+		return pipe->scaler_pp_lut;
+	else
+		return sh_css_params_get_default_gdc_lut();
+#else
+	NOT_USED(pipe);
+	return mmgr_NULL;
+#endif
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+enum ia_css_err sh_css_params_map_and_store_default_gdc_lut(void)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
 	IA_CSS_ENTER_PRIVATE("void");
 
-	for (i = 0; i < N_GDC_ID; i++)
-		gdc_lut_store((gdc_ID_t)i, zoom_table);
+	/* Is table already mapped? Nothing to do if it is mapped. */
+	if (default_gdc_lut != mmgr_NULL)
+		return err;
+
+	host_lut_store((void *)zoom_table);
+
+	default_gdc_lut = mmgr_malloc(sizeof(zoom_table));
+	if (default_gdc_lut == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	gdc_lut_convert_to_isp_format((const int(*)[HRT_GDC_N])zoom_table,
+		interleaved_lut_temp);
+	mmgr_store(default_gdc_lut, (int *)interleaved_lut_temp,
+		sizeof(zoom_table));
+
+	IA_CSS_LEAVE_PRIVATE("lut(%p) err=%d", default_gdc_lut, err);
+	return err;
+}
+
+void sh_css_params_free_default_gdc_lut(void)
+{
+	IA_CSS_ENTER_PRIVATE("void");
+
+	if (default_gdc_lut != mmgr_NULL) {
+		mmgr_free(default_gdc_lut);
+		default_gdc_lut = mmgr_NULL;
+	}
 
 	IA_CSS_LEAVE_PRIVATE("void");
+
+}
+
+hrt_vaddress sh_css_params_get_default_gdc_lut(void)
+{
+	return default_gdc_lut;
 }
 #endif
 
@@ -3505,7 +3600,7 @@ sh_css_param_clear_param_sets(void)
 	do {                  \
 		ia_css_refcount_decrement(id, x);     \
 		(x) = mmgr_NULL;  \
-	} while (0)
+	} while(0)
 
 static void free_map(struct sh_css_ddr_address_map *map)
 {
@@ -3546,6 +3641,11 @@ ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
 		free_map(&params->pipe_ddr_ptrs[i]);
 		if (per_frame_params)
 			free_map(&per_frame_params->pipe_ddr_ptrs[i]);
+		/* Free up theDVS table memory blocks before recomputing new table */
+		if (params->pipe_dvs_6axis_config[i])
+			free_dvs_6axis_table(&(params->pipe_dvs_6axis_config[i]));
+		if (per_frame_params && per_frame_params->pipe_dvs_6axis_config[i])
+			free_dvs_6axis_table(&(per_frame_params->pipe_dvs_6axis_config[i]));
 	}
 	free_map(&params->ddr_ptrs);
 	if (per_frame_params)
@@ -3561,12 +3661,6 @@ ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
 	stripe_table_release();
 #endif
 
-	/* Free up theDVS table memory blocks before recomputing new table */
-	if (params->dvs_6axis_config)
-		free_dvs_6axis_table(&(params->dvs_6axis_config));
-	if (per_frame_params && per_frame_params->dvs_6axis_config)
-		free_dvs_6axis_table(&(per_frame_params->dvs_6axis_config));
-
 	/* Free up sc_config (temporal shading table) if it is allocated. */
 	if (params->sc_config) {
 		ia_css_shading_table_free(params->sc_config);
@@ -3861,12 +3955,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 
 	IA_CSS_ENTER_PRIVATE("pipe=%p, isp_parameters_id=%d", pipe_in, params->isp_parameters_id);
 	raw_bit_depth = ia_css_stream_input_format_bits_per_pixel(curr_pipe->stream);
-	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(curr_pipe);
-	/* this code assuemes that all the pipes have the same pipeversion. */
-	for (i = 1; i < curr_pipe->stream->num_pipes; i++) {
-		assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(curr_pipe->stream->pipes[i]));
-	}
-
 
 	/* now make the map available to the sp */
 	if (!commit) {
@@ -3889,6 +3977,7 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		pipe = curr_pipe->stream->pipes[i];
 		pipeline = ia_css_pipe_get_pipeline(pipe);
 		pipe_num = ia_css_pipe_get_pipe_num(pipe);
+		isp_pipe_version = ia_css_pipe_get_isp_pipe_version(pipe);
 		ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
 #if defined(IS_ISP_2500_SYSTEM)
 		if (ia_css_pipeline_is_mapped(pipe_num) == false) {
@@ -3938,7 +4027,7 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 			if (err != IA_CSS_SUCCESS)
 			    return err;
 		}
-#else
+#endif
 		/* check if to actually update the parameters for this pipe */
 		/* When API change is implemented making good distinction between
 		* stream config and pipe config this skipping code can be moved out of the #ifdef */
@@ -3946,7 +4035,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 			IA_CSS_LOG("skipping pipe %x", pipe);
 			continue;
 		}
-#endif
 
 		/* BZ 125915, should be moved till after "update other buff" */
 		/* update the other buffers to the pipe specific copies */
@@ -4003,13 +4091,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		}
 #endif
 
-		/* check if to actually update the parameters for this pipe */
-		/* When API change is implemented making good distinction between
-		* stream config and pipe config this skipping code can be removed */
-		if (pipe_in && (pipe != pipe_in)) {
-			IA_CSS_LOG("skipping pipe %x", pipe);
-			continue;
-		}
 		/* last make referenced copy */
 		err = ref_sh_css_ddr_address_map(
 				cur_map,
@@ -4073,6 +4154,7 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		}
 		/* clean-up old copy */
 		ia_css_dequeue_param_buffers(/*pipe_num*/);
+		params->pipe_dvs_6axis_config_changed[pipeline->pipe_id] = false;
 	} /* end for each 'active' pipeline */
 	/* clear the changed flags after all params
 	for all pipelines have been updated */
@@ -4083,7 +4165,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 	params->morph_table_changed = false;
 	params->dz_config_changed = false;
 	params->motion_config_changed = false;
-	params->dvs_6axis_config_changed = false;
 /* ------ deprecated(bz675) : from ------ */
 	params->shading_settings_changed = false;
 /* ------ deprecated(bz675) : to ------ */
@@ -4113,7 +4194,6 @@ sh_css_params_write_to_ddr_internal(
 #if !defined(IS_ISP_2500_SYSTEM)
 	/* struct is > 128 bytes so it should not be on stack (see checkpatch) */
 	static struct ia_css_macc_table converted_macc_table;
-	(void)pipe;
 #endif
 
 	IA_CSS_ENTER_PRIVATE("void");
@@ -4236,7 +4316,7 @@ sh_css_params_write_to_ddr_internal(
 					(const struct ia_css_shading_table *)params->sc_table,
 					params->sensor_binning,
 					&params->sc_config,
-					binary);
+					binary, pipe->required_bds_factor);
 				if (params->sc_config == NULL) {
 					IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
 					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
@@ -4271,16 +4351,16 @@ sh_css_params_write_to_ddr_internal(
 
 			if (binary->info->sp.pipeline.isp_pipe_version == SH_CSS_ISP_PIPE_VERSION_1) {
 				converted_macc_table.data[idx] =
-				  sDIGIT_FITTING(params->macc_table.data[j],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx+1] =
-				  sDIGIT_FITTING(params->macc_table.data[j+1],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j+1],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx+2] =
-				  sDIGIT_FITTING(params->macc_table.data[j+2],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j+2],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx+3] =
-				  sDIGIT_FITTING(params->macc_table.data[j+3],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j+3],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 			} else if (binary->info->sp.pipeline.isp_pipe_version == SH_CSS_ISP_PIPE_VERSION_2_2) {
 				converted_macc_table.data[idx] =
@@ -4316,31 +4396,48 @@ sh_css_params_write_to_ddr_internal(
 				&ddr_map->dvs_6axis_params_y,
 				&ddr_map_size->dvs_6axis_params_y,
 				(size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3),
-				params->dvs_6axis_config_changed,
+				params->pipe_dvs_6axis_config_changed[pipe_id],
 				&err);
 		if (err != IA_CSS_SUCCESS) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
-		if (params->dvs_6axis_config_changed || buff_realloced) {
-			if (params->dvs_6axis_config == NULL) /* Generate default DVS unity table on start up*/
-			{
-				struct ia_css_resolution dvs_offset;
-				dvs_offset.width  = (PIX_SHIFT_FILTER_RUN_IN_X + binary->dvs_envelope.width) / 2;
-				dvs_offset.height = (PIX_SHIFT_FILTER_RUN_IN_Y + binary->dvs_envelope.height) / 2;
 
-				params->dvs_6axis_config = generate_dvs_6axis_table(&binary->out_frame_info[0].res,
-										    &dvs_offset);
-				if (params->dvs_6axis_config == NULL) {
+		if (params->pipe_dvs_6axis_config_changed[pipe_id] || buff_realloced) {
+			const struct ia_css_frame_info *dvs_in_frame_info;
+
+			if ( stage->args.delay_frames[0] ) {
+				/*When delay frames are present(as in case of video),
+				they are used for dvs. Configure DVS using those params*/
+				dvs_in_frame_info = &stage->args.delay_frames[0]->info;
+			} else {
+				/*Otherwise, use input frame to configure DVS*/
+				dvs_in_frame_info = &stage->args.in_frame->info;
+			}
+
+			/* Generate default DVS unity table on start up*/
+			if (params->pipe_dvs_6axis_config[pipe_id] == NULL) {
+
+				struct ia_css_resolution dvs_offset;
+				dvs_offset.width  =
+						(PIX_SHIFT_FILTER_RUN_IN_X + binary->dvs_envelope.width) / 2;
+				dvs_offset.height =
+						(PIX_SHIFT_FILTER_RUN_IN_Y + binary->dvs_envelope.height) / 2;
+
+				params->pipe_dvs_6axis_config[pipe_id] =
+						generate_dvs_6axis_table(&binary->out_frame_info[0].res, &dvs_offset);
+				if (params->pipe_dvs_6axis_config[pipe_id] == NULL) {
 					IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
 					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
 				}
-				params->dvs_6axis_config_changed = true;
+				params->pipe_dvs_6axis_config_changed[pipe_id] = true;
 			}
 
-			store_dvs_6axis_config(params,
-						binary,
-						ddr_map->dvs_6axis_params_y);
+			store_dvs_6axis_config(params->pipe_dvs_6axis_config[pipe_id],
+				binary,
+				dvs_in_frame_info,
+				ddr_map->dvs_6axis_params_y);
+			params->isp_params_changed = true;
 		}
 	}
 
@@ -4520,6 +4617,20 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream *stre
 /* ------ deprecated(bz675) : from ------ */
 		const struct ia_css_binary *binary
 			= ia_css_stream_get_shading_correction_binary(stream);
+		struct ia_css_pipe *pipe;
+
+		/**********************************************************************/
+		/* following code is copied from function ia_css_stream_get_shading_correction_binary()
+		 * to match with the binary */
+		pipe = stream->pipes[0];
+
+		if (stream->num_pipes == 2) {
+			assert(stream->pipes[1] != NULL);
+			if (stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_VIDEO ||
+			    stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_PREVIEW)
+				pipe = stream->pipes[1];
+		}
+		/**********************************************************************/
 		if (binary) {
 			if (params->sc_config) {
 				ia_css_shading_table_free(params->sc_config);
@@ -4529,7 +4640,7 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream *stre
 				(const struct ia_css_shading_table *)params->sc_table,
 				params->sensor_binning,
 				&params->sc_config,
-				binary);
+				binary, pipe->required_bds_factor);
 
 			table = params->sc_config;
 			/* The sc_config will be freed in the
@@ -4698,9 +4809,11 @@ sh_css_invalidate_params(struct ia_css_stream *stream)
 	params->motion_config_changed = true;
 
 	/*Free up theDVS table memory blocks before recomputing new table  */
-	if (params->dvs_6axis_config)
-		free_dvs_6axis_table(&(params->dvs_6axis_config));
-	params->dvs_6axis_config_changed = true;
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (params->pipe_dvs_6axis_config[i])
+			free_dvs_6axis_table(&(params->pipe_dvs_6axis_config[i]));
+			params->pipe_dvs_6axis_config_changed[i] = true;
+	}
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
@@ -5224,7 +5337,8 @@ ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
 	assert(stream != NULL);
 	params = stream->isp_params_configs;
 
-	if (!params || (params && !params->dvs_6axis_config)) {
+	/* Backward compatibility by default consider pipe as Video*/
+	if (!params || (params && !params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO])) {
 		goto err;
 	}
 
@@ -5232,10 +5346,10 @@ ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
 	if (!dvs_config)
 		goto err;
 
-	dvs_config->width_y = width_y = params->dvs_6axis_config->width_y;
-	dvs_config->height_y = height_y = params->dvs_6axis_config->height_y;
-	dvs_config->width_uv = width_uv = params->dvs_6axis_config->width_uv;
-	dvs_config->height_uv = height_uv = params->dvs_6axis_config->height_uv;
+	dvs_config->width_y = width_y = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_y;
+	dvs_config->height_y = height_y = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_y;
+	dvs_config->width_uv = width_uv = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_uv;
+	dvs_config->height_uv = height_uv = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_uv;
 	IA_CSS_LOG("table Y: W %d H %d", width_y, height_y);
 	IA_CSS_LOG("table UV: W %d H %d", width_uv, height_uv);
 	dvs_config->xcoords_y = (uint32_t *)sh_css_malloc(width_y * height_y * sizeof(uint32_t));
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.h
index 30f362e..8ffcbdf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_params.h
@@ -84,9 +84,8 @@ struct ia_css_isp_parameters {
 	struct ia_css_anr_config    anr_config;
 	struct ia_css_ce_config     ce_config;
 	struct ia_css_formats_config     formats_config;
-
+/* ---- deprecated: replaced with pipe_dvs_6axis_config---- */
 	struct ia_css_dvs_6axis_config  *dvs_6axis_config;
-
 	struct ia_css_ecd_config    ecd_config;
 	struct ia_css_ynr_config    ynr_config;
 	struct ia_css_yee_config    yee_config;
@@ -110,6 +109,7 @@ struct ia_css_isp_parameters {
 	struct ia_css_2500_lin_kernel_config  lin_2500_config;
 	struct ia_css_2500_tnr_kernel_config  tnr_2500_config;
 #endif
+	struct ia_css_dvs_6axis_config  *pipe_dvs_6axis_config[IA_CSS_PIPE_ID_NUM];
 /* ------ deprecated(bz675) : from ------ */
 	struct ia_css_shading_settings shading_settings;
 /* ------ deprecated(bz675) : to ------ */
@@ -126,10 +126,12 @@ struct ia_css_isp_parameters {
 	bool morph_table_changed;
 	bool sc_table_changed;
 	bool anr_thres_changed;
+/* ---- deprecated: replaced with pipe_dvs_6axis_config_changed ---- */
 	bool dvs_6axis_config_changed;
 /* ------ deprecated(bz675) : from ------ */
 	bool shading_settings_changed;
 /* ------ deprecated(bz675) : to ------ */
+	bool pipe_dvs_6axis_config_changed[IA_CSS_PIPE_ID_NUM];
 
 	bool config_changed[IA_CSS_NUM_PARAMETER_IDS];
 
@@ -162,4 +164,16 @@ ia_css_params_alloc_convert_sctbl(
 struct ia_css_isp_config *
 sh_css_pipe_isp_config_get(struct ia_css_pipe *pipe);
 
+enum ia_css_err
+sh_css_params_map_and_store_default_gdc_lut(void);
+
+void
+sh_css_params_free_default_gdc_lut(void);
+
+hrt_vaddress
+sh_css_params_get_default_gdc_lut(void);
+
+hrt_vaddress
+sh_css_pipe_get_pp_gdc_lut(const struct ia_css_pipe *pipe);
+
 #endif /* _SH_CSS_PARAMS_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_sp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_sp.c
index bbb2a30..8f42d3d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_sp.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/sh_css_sp.c
@@ -971,7 +971,7 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 
 	/* Make sure binary name is smaller than allowed string size */
 	assert(strlen(binary_name) < SH_CSS_MAX_BINARY_NAME-1);
-	strncpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME);
+	strncpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME-1);
 	sh_css_isp_stage.binary_name[SH_CSS_MAX_BINARY_NAME - 1] = 0;
 	sh_css_isp_stage.mem_initializers = *isp_mem_if;
 
@@ -1191,6 +1191,7 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 	/* Get first stage */
 	struct ia_css_pipeline_stage *stage        = NULL;
 	struct ia_css_binary	     *first_binary = NULL;
+	struct ia_css_pipe *pipe = NULL;
 	unsigned num;
 
 	enum ia_css_pipe_id pipe_id = id;
@@ -1274,6 +1275,13 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 
 	sh_css_sp_group.pipe[thread_id].inout_port_config = me->inout_port_config;
 
+	pipe = find_pipe_by_num(pipe_num);
+	assert(pipe != NULL);
+	if (pipe == NULL) {
+		return;
+	}
+	sh_css_sp_group.pipe[thread_id].scaler_pp_lut = sh_css_pipe_get_pp_gdc_lut(pipe);
+
 #if defined(SH_CSS_ENABLE_METADATA)
 	if (md_info != NULL && md_info->size > 0) {
 		sh_css_sp_group.pipe[thread_id].metadata.width  = md_info->resolution.width;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c
index 4fc7354..164455f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_legacy_v21/spmem_dump.c
@@ -22,120 +22,120 @@
 
 #define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
 
-/* function input_system_acquisition_stop: ADA */
+/* function input_system_acquisition_stop: ADE */
 
-/* function longjmp: 64C6 */
+/* function longjmp: 6868 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SRST_MASK
 #define HIVE_MEM_HIVE_IF_SRST_MASK scalar_processor_2400_dmem
-#define HIVE_ADDR_HIVE_IF_SRST_MASK 0x1CC
+#define HIVE_ADDR_HIVE_IF_SRST_MASK 0x1C8
 #define HIVE_SIZE_HIVE_IF_SRST_MASK 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_HIVE_IF_SRST_MASK scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x1CC
+#define HIVE_ADDR_sp_HIVE_IF_SRST_MASK 0x1C8
 #define HIVE_SIZE_sp_HIVE_IF_SRST_MASK 16
 
-/* function tmpmem_init_dmem: 6262 */
+/* function tmpmem_init_dmem: 65B3 */
 
-/* function ia_css_isys_sp_token_map_receive_ack: 5BAE */
+/* function ia_css_isys_sp_token_map_receive_ack: 5EF7 */
 
-/* function ia_css_dmaproxy_sp_set_addr_B: 3031 */
+/* function ia_css_dmaproxy_sp_set_addr_B: 32AD */
 
 /* function debug_buffer_set_ddr_addr: DD */
 
-/* function receiver_port_reg_load: ABE */
+/* function receiver_port_reg_load: AC2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_mipi
 #define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_mipi 0x62C4
+#define HIVE_ADDR_vbuf_mipi 0x630C
 #define HIVE_SIZE_vbuf_mipi 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_mipi 0x62C4
+#define HIVE_ADDR_sp_vbuf_mipi 0x630C
 #define HIVE_SIZE_sp_vbuf_mipi 12
 
-/* function ia_css_event_sp_decode: 3206 */
+/* function ia_css_event_sp_decode: 349E */
 
-/* function ia_css_queue_get_size: 44CB */
+/* function ia_css_queue_get_size: 4817 */
 
-/* function ia_css_queue_load: 4B0C */
+/* function ia_css_queue_load: 4E58 */
 
-/* function setjmp: 64CF */
+/* function setjmp: 6871 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_isys_event_queue
 #define HIVE_MEM_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x4640
+#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x4684
 #define HIVE_SIZE_sem_for_sp2host_isys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x4640
+#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x4684
 #define HIVE_SIZE_sp_sem_for_sp2host_isys_event_queue 20
 
-/* function ia_css_dmaproxy_sp_wait_for_ack: 69FD */
+/* function ia_css_dmaproxy_sp_wait_for_ack: 6E21 */
 
-/* function ia_css_sp_rawcopy_func: 4D31 */
+/* function ia_css_sp_rawcopy_func: 507D */
 
-/* function ia_css_tagger_buf_sp_pop_marked: 2772 */
+/* function ia_css_tagger_buf_sp_pop_marked: 2942 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stage
 #define HIVE_MEM_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stage 0x5BA8
+#define HIVE_ADDR_isp_stage 0x5BF0
 #define HIVE_SIZE_isp_stage 832
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stage 0x5BA8
+#define HIVE_ADDR_sp_isp_stage 0x5BF0
 #define HIVE_SIZE_sp_isp_stage 832
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_raw
 #define HIVE_MEM_vbuf_raw scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_raw 0x2F4
+#define HIVE_ADDR_vbuf_raw 0x2F0
 #define HIVE_SIZE_vbuf_raw 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_raw scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_raw 0x2F4
+#define HIVE_ADDR_sp_vbuf_raw 0x2F0
 #define HIVE_SIZE_sp_vbuf_raw 4
 
-/* function ia_css_sp_bin_copy_func: 4C58 */
+/* function ia_css_sp_bin_copy_func: 4FA4 */
 
-/* function ia_css_queue_item_store: 485A */
+/* function ia_css_queue_item_store: 4BA6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4A5C
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4AA0
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4A5C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x4AA0
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x4A70
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x4AB4
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x4A70
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x4AB4
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 
 /* function sp_start_isp: 45D */
@@ -143,110 +143,110 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_binary_group
 #define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_binary_group 0x5F98
+#define HIVE_ADDR_sp_binary_group 0x5FE0
 #define HIVE_SIZE_sp_binary_group 32
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_binary_group 0x5F98
+#define HIVE_ADDR_sp_sp_binary_group 0x5FE0
 #define HIVE_SIZE_sp_sp_binary_group 32
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sw_state
 #define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sw_state 0x6254
+#define HIVE_ADDR_sp_sw_state 0x629C
 #define HIVE_SIZE_sp_sw_state 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sw_state 0x6254
+#define HIVE_ADDR_sp_sp_sw_state 0x629C
 #define HIVE_SIZE_sp_sp_sw_state 4
 
-/* function ia_css_thread_sp_main: D57 */
+/* function ia_css_thread_sp_main: D5B */
 
-/* function ia_css_ispctrl_sp_init_internal_buffers: 340C */
+/* function ia_css_ispctrl_sp_init_internal_buffers: 36A4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_psys_event_queue_handle
 #define HIVE_MEM_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x4B10
+#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x4B54
 #define HIVE_SIZE_sp2host_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x4B10
+#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x4B54
 #define HIVE_SIZE_sp_sp2host_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_psys_event_queue
 #define HIVE_MEM_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4654
+#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x4698
 #define HIVE_SIZE_sem_for_sp2host_psys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4654
+#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x4698
 #define HIVE_SIZE_sp_sem_for_sp2host_psys_event_queue 20
 
-/* function ia_css_tagger_sp_propagate_frame: 2289 */
+/* function ia_css_tagger_sp_propagate_frame: 23E2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_stop_copy_preview
 #define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_stop_copy_preview 0x6238
+#define HIVE_ADDR_sp_stop_copy_preview 0x6280
 #define HIVE_SIZE_sp_stop_copy_preview 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_stop_copy_preview 0x6238
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x6280
 #define HIVE_SIZE_sp_sp_stop_copy_preview 4
 
-/* function input_system_reg_load: B13 */
+/* function input_system_reg_load: B17 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_handles
 #define HIVE_MEM_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_handles 0x62D0
+#define HIVE_ADDR_vbuf_handles 0x6318
 #define HIVE_SIZE_vbuf_handles 960
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_handles 0x62D0
+#define HIVE_ADDR_sp_vbuf_handles 0x6318
 #define HIVE_SIZE_sp_vbuf_handles 960
 
-/* function ia_css_queue_store: 49C0 */
+/* function ia_css_queue_store: 4D0C */
 
-/* function ia_css_sp_flash_register: 298C */
+/* function ia_css_sp_flash_register: 2BB0 */
 
-/* function ia_css_sp_rawcopy_dummy_function: 533C */
+/* function ia_css_sp_rawcopy_dummy_function: 5685 */
 
-/* function ia_css_isys_sp_backend_create: 5821 */
+/* function ia_css_isys_sp_backend_create: 5B6A */
 
-/* function ia_css_pipeline_sp_init: 179A */
+/* function ia_css_pipeline_sp_init: 1833 */
 
-/* function ia_css_tagger_sp_configure: 2186 */
+/* function ia_css_tagger_sp_configure: 22D2 */
 
-/* function ia_css_ispctrl_sp_end_binary: 324F */
+/* function ia_css_ispctrl_sp_end_binary: 34E7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4B1C
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4B60
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4B1C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x4B60
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 
-/* function receiver_port_reg_store: AC5 */
+/* function receiver_port_reg_store: AC9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_is_pending_mask
@@ -263,114 +263,114 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_frame
 #define HIVE_MEM_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_frame 0x4668
+#define HIVE_ADDR_sp_all_cb_elems_frame 0x46AC
 #define HIVE_SIZE_sp_all_cb_elems_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x4668
+#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x46AC
 #define HIVE_SIZE_sp_sp_all_cb_elems_frame 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_isys_event_queue_handle
 #define HIVE_MEM_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4B30
+#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x4B74
 #define HIVE_SIZE_sp2host_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4B30
+#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x4B74
 #define HIVE_SIZE_sp_sp2host_isys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_com
 #define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_com 0x40E4
+#define HIVE_ADDR_host_sp_com 0x4114
 #define HIVE_SIZE_host_sp_com 220
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_com 0x40E4
+#define HIVE_ADDR_sp_host_sp_com 0x4114
 #define HIVE_SIZE_sp_host_sp_com 220
 
-/* function ia_css_queue_get_free_space: 461F */
+/* function ia_css_queue_get_free_space: 496B */
 
 /* function exec_image_pipe: 6C4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_init_dmem_data
 #define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_init_dmem_data 0x6258
+#define HIVE_ADDR_sp_init_dmem_data 0x62A0
 #define HIVE_SIZE_sp_init_dmem_data 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_init_dmem_data 0x6258
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x62A0
 #define HIVE_SIZE_sp_sp_init_dmem_data 24
 
-/* function ia_css_sp_metadata_start: 55FE */
+/* function ia_css_sp_metadata_start: 5947 */
 
-/* function ia_css_bufq_sp_init_buffer_queues: 29FB */
+/* function ia_css_bufq_sp_init_buffer_queues: 2C1F */
 
-/* function ia_css_pipeline_sp_stop: 177D */
+/* function ia_css_pipeline_sp_stop: 1816 */
 
-/* function ia_css_tagger_sp_connect_pipes: 25FB */
+/* function ia_css_tagger_sp_connect_pipes: 27AB */
 
 /* function sp_isys_copy_wait: 70D */
 
 /* function is_isp_debug_buffer_full: 337 */
 
-/* function ia_css_dmaproxy_sp_configure_channel_from_info: 2FB4 */
+/* function ia_css_dmaproxy_sp_configure_channel_from_info: 3230 */
 
-/* function encode_and_post_timer_event: A2C */
+/* function encode_and_post_timer_event: A30 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_per_frame_data
 #define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_per_frame_data 0x41C0
+#define HIVE_ADDR_sp_per_frame_data 0x41F0
 #define HIVE_SIZE_sp_per_frame_data 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_per_frame_data 0x41C0
+#define HIVE_ADDR_sp_sp_per_frame_data 0x41F0
 #define HIVE_SIZE_sp_sp_per_frame_data 4
 
-/* function ia_css_rmgr_sp_vbuf_dequeue: 5FBE */
+/* function ia_css_rmgr_sp_vbuf_dequeue: 6307 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_psys_event_queue_handle
 #define HIVE_MEM_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4B3C
+#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x4B80
 #define HIVE_SIZE_host2sp_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4B3C
+#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x4B80
 #define HIVE_SIZE_sp_host2sp_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_xmem_bin_addr
 #define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_xmem_bin_addr 0x41C4
+#define HIVE_ADDR_xmem_bin_addr 0x41F4
 #define HIVE_SIZE_xmem_bin_addr 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_xmem_bin_addr 0x41C4
+#define HIVE_ADDR_sp_xmem_bin_addr 0x41F4
 #define HIVE_SIZE_sp_xmem_bin_addr 4
 
-/* function tmr_clock_init: 13E9 */
+/* function tmr_clock_init: 13F4 */
 
-/* function ia_css_pipeline_sp_run: 13F8 */
+/* function ia_css_pipeline_sp_run: 1415 */
 
-/* function memcpy: 656F */
+/* function memcpy: 6911 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_GP_DEVICE_BASE
@@ -387,58 +387,58 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_ready_queue
 #define HIVE_MEM_ia_css_thread_sp_ready_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_ready_queue 0x1E4
+#define HIVE_ADDR_ia_css_thread_sp_ready_queue 0x1E0
 #define HIVE_SIZE_ia_css_thread_sp_ready_queue 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_ready_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x1E4
+#define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x1E0
 #define HIVE_SIZE_sp_ia_css_thread_sp_ready_queue 12
 
-/* function input_system_reg_store: B1A */
+/* function input_system_reg_store: B1E */
 
-/* function ia_css_isys_sp_frontend_start: 5A37 */
+/* function ia_css_isys_sp_frontend_start: 5D80 */
 
-/* function ia_css_uds_sp_scale_params: 6278 */
+/* function ia_css_uds_sp_scale_params: 661A */
 
-/* function ia_css_circbuf_increase_size: E3C */
+/* function ia_css_circbuf_increase_size: E40 */
 
-/* function __divu: 64ED */
+/* function __divu: 688F */
 
-/* function ia_css_thread_sp_get_state: C7F */
+/* function ia_css_thread_sp_get_state: C83 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_stop
 #define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_stop 0x4678
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x46BC
 #define HIVE_SIZE_sem_for_cont_capt_stop 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x4678
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x46BC
 #define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
 
-/* function thread_fiber_sp_main: E35 */
+/* function thread_fiber_sp_main: E39 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_pipe_thread
 #define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pipe_thread 0x47BC
+#define HIVE_ADDR_sp_isp_pipe_thread 0x4800
 #define HIVE_SIZE_sp_isp_pipe_thread 340
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x47BC
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x4800
 #define HIVE_SIZE_sp_sp_isp_pipe_thread 340
 
-/* function ia_css_parambuf_sp_handle_parameter_sets: 127F */
+/* function ia_css_parambuf_sp_handle_parameter_sets: 128A */
 
-/* function ia_css_spctrl_sp_set_state: 562D */
+/* function ia_css_spctrl_sp_set_state: 5976 */
 
-/* function ia_css_thread_sem_sp_signal: 6734 */
+/* function ia_css_thread_sem_sp_signal: 6B11 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_IRQ_BASE
@@ -464,13 +464,13 @@
 #define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
 #define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
 
-/* function ia_css_isys_sp_isr: 6BAE */
+/* function ia_css_isys_sp_isr: 6FF6 */
 
-/* function ia_css_isys_sp_generate_exp_id: 5DCF */
+/* function ia_css_isys_sp_generate_exp_id: 6118 */
 
-/* function ia_css_rmgr_sp_init: 5EB9 */
+/* function ia_css_rmgr_sp_init: 6202 */
 
-/* function ia_css_thread_sem_sp_init: 6805 */
+/* function ia_css_thread_sem_sp_init: 6BE2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_is_isp_requested
@@ -487,95 +487,97 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_frame
 #define HIVE_MEM_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frame 0x468C
+#define HIVE_ADDR_sem_for_reading_cb_frame 0x46D0
 #define HIVE_SIZE_sem_for_reading_cb_frame 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x468C
+#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x46D0
 #define HIVE_SIZE_sp_sem_for_reading_cb_frame 40
 
-/* function ia_css_dmaproxy_sp_execute: 2F1C */
+/* function ia_css_dmaproxy_sp_execute: 3198 */
 
-/* function ia_css_queue_is_empty: 4506 */
+/* function ia_css_queue_is_empty: 4852 */
 
-/* function ia_css_pipeline_sp_has_stopped: 1773 */
+/* function ia_css_pipeline_sp_has_stopped: 180C */
 
-/* function ia_css_circbuf_extract: F3C */
+/* function ia_css_circbuf_extract: F44 */
 
-/* function ia_css_tagger_buf_sp_is_locked_from_start: 28B9 */
+/* function ia_css_tagger_buf_sp_is_locked_from_start: 2A91 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_sp_thread
 #define HIVE_MEM_current_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_current_sp_thread 0x1E0
+#define HIVE_ADDR_current_sp_thread 0x1DC
 #define HIVE_SIZE_current_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_sp_thread 0x1E0
+#define HIVE_ADDR_sp_current_sp_thread 0x1DC
 #define HIVE_SIZE_sp_current_sp_thread 4
 
-/* function ia_css_spctrl_sp_get_spid: 5634 */
+/* function ia_css_spctrl_sp_get_spid: 597D */
 
-/* function ia_css_dmaproxy_sp_read_byte_addr: 6A2B */
+/* function ia_css_bufq_sp_reset_buffers: 2CA6 */
 
-/* function ia_css_rmgr_sp_uninit: 5EB2 */
+/* function ia_css_dmaproxy_sp_read_byte_addr: 6E4F */
+
+/* function ia_css_rmgr_sp_uninit: 61FB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack
 #define HIVE_MEM_sp_threads_stack scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_stack 0x168
+#define HIVE_ADDR_sp_threads_stack 0x164
 #define HIVE_SIZE_sp_threads_stack 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_stack scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_stack 0x168
+#define HIVE_ADDR_sp_sp_threads_stack 0x164
 #define HIVE_SIZE_sp_sp_threads_stack 28
 
-/* function ia_css_circbuf_peek: F1E */
+/* function ia_css_circbuf_peek: F26 */
 
-/* function ia_css_parambuf_sp_wait_for_in_param: 1047 */
+/* function ia_css_parambuf_sp_wait_for_in_param: 1053 */
 
-/* function ia_css_isys_sp_token_map_get_exp_id: 5C97 */
+/* function ia_css_isys_sp_token_map_get_exp_id: 5FE0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_param
 #define HIVE_MEM_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_param 0x46B4
+#define HIVE_ADDR_sp_all_cb_elems_param 0x46F8
 #define HIVE_SIZE_sp_all_cb_elems_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x46B4
+#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x46F8
 #define HIVE_SIZE_sp_sp_all_cb_elems_param 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_pipeline_sp_curr_binary_id
 #define HIVE_MEM_pipeline_sp_curr_binary_id scalar_processor_2400_dmem
-#define HIVE_ADDR_pipeline_sp_curr_binary_id 0x1F0
+#define HIVE_ADDR_pipeline_sp_curr_binary_id 0x1EC
 #define HIVE_SIZE_pipeline_sp_curr_binary_id 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_pipeline_sp_curr_binary_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_pipeline_sp_curr_binary_id 0x1F0
+#define HIVE_ADDR_sp_pipeline_sp_curr_binary_id 0x1EC
 #define HIVE_SIZE_sp_pipeline_sp_curr_binary_id 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame_desc
 #define HIVE_MEM_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame_desc 0x46C4
+#define HIVE_ADDR_sp_all_cbs_frame_desc 0x4708
 #define HIVE_SIZE_sp_all_cbs_frame_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x46C4
+#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x4708
 #define HIVE_SIZE_sp_sp_all_cbs_frame_desc 8
 
 /* function sp_isys_copy_func_v2: 706 */
@@ -583,103 +585,103 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_param
 #define HIVE_MEM_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_param 0x46CC
+#define HIVE_ADDR_sem_for_reading_cb_param 0x4710
 #define HIVE_SIZE_sem_for_reading_cb_param 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x46CC
+#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x4710
 #define HIVE_SIZE_sp_sem_for_reading_cb_param 40
 
-/* function ia_css_queue_get_used_space: 45D3 */
+/* function ia_css_queue_get_used_space: 491F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_start
 #define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_start 0x46F4
+#define HIVE_ADDR_sem_for_cont_capt_start 0x4738
 #define HIVE_SIZE_sem_for_cont_capt_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x46F4
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x4738
 #define HIVE_SIZE_sp_sem_for_cont_capt_start 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tmp_heap
 #define HIVE_MEM_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_tmp_heap 0x5FB8
+#define HIVE_ADDR_tmp_heap 0x6000
 #define HIVE_SIZE_tmp_heap 640
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tmp_heap 0x5FB8
+#define HIVE_ADDR_sp_tmp_heap 0x6000
 #define HIVE_SIZE_sp_tmp_heap 640
 
-/* function ia_css_rmgr_sp_get_num_vbuf: 61BA */
+/* function ia_css_rmgr_sp_get_num_vbuf: 650B */
 
-/* function ia_css_ispctrl_sp_output_compute_dma_info: 3B7C */
+/* function ia_css_ispctrl_sp_output_compute_dma_info: 3EC8 */
 
-/* function ia_css_tagger_sp_lock_exp_id: 1FAE */
+/* function ia_css_tagger_sp_lock_exp_id: 20BD */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4B48
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4B8C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4B48
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x4B8C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 
-/* function ia_css_queue_is_full: 466A */
+/* function ia_css_queue_is_full: 49B6 */
 
 /* function debug_buffer_init_isp: E4 */
 
-/* function ia_css_isys_sp_frontend_uninit: 59F1 */
+/* function ia_css_isys_sp_frontend_uninit: 5D3A */
 
-/* function ia_css_tagger_sp_exp_id_is_locked: 1EFC */
+/* function ia_css_tagger_sp_exp_id_is_locked: 2003 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem
 #define HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x6690
+#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x66D8
 #define HIVE_SIZE_ia_css_rmgr_sp_mipi_frame_sem 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x6690
+#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x66D8
 #define HIVE_SIZE_sp_ia_css_rmgr_sp_mipi_frame_sem 60
 
-/* function ia_css_rmgr_sp_refcount_dump: 5F99 */
+/* function ia_css_rmgr_sp_refcount_dump: 62E2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4B84
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4BC8
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4B84
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x4BC8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_pipe_threads
 #define HIVE_MEM_sp_pipe_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_pipe_threads 0x154
+#define HIVE_ADDR_sp_pipe_threads 0x150
 #define HIVE_SIZE_sp_pipe_threads 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_pipe_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_pipe_threads 0x154
+#define HIVE_ADDR_sp_sp_pipe_threads 0x150
 #define HIVE_SIZE_sp_sp_pipe_threads 20
 
 /* function sp_event_proxy_func: 71B */
@@ -687,56 +689,58 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_isys_event_queue_handle
 #define HIVE_MEM_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4B98
+#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x4BDC
 #define HIVE_SIZE_host2sp_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4B98
+#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x4BDC
 #define HIVE_SIZE_sp_host2sp_isys_event_queue_handle 12
 
-/* function ia_css_thread_sp_yield: 66AD */
+/* function ia_css_thread_sp_yield: 6A8A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param_desc
 #define HIVE_MEM_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param_desc 0x4708
+#define HIVE_ADDR_sp_all_cbs_param_desc 0x474C
 #define HIVE_SIZE_sp_all_cbs_param_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x4708
+#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x474C
 #define HIVE_SIZE_sp_sp_all_cbs_param_desc 8
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb
 #define HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5B9C
+#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x5BE0
 #define HIVE_SIZE_ia_css_dmaproxy_sp_invalidate_tlb 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5B9C
+#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x5BE0
 #define HIVE_SIZE_sp_ia_css_dmaproxy_sp_invalidate_tlb 4
 
-/* function ia_css_thread_sp_fork: D0C */
+/* function ia_css_thread_sp_fork: D10 */
 
-/* function ia_css_tagger_sp_destroy: 2605 */
+/* function ia_css_tagger_sp_destroy: 27B5 */
 
-/* function ia_css_dmaproxy_sp_vmem_read: 2EBC */
+/* function ia_css_dmaproxy_sp_vmem_read: 3138 */
 
-/* function ia_css_ifmtr_sp_init: 5E20 */
+/* function ia_css_ifmtr_sp_init: 6169 */
 
 /* function initialize_sp_group: 6D4 */
 
-/* function ia_css_thread_sp_init: D38 */
+/* function ia_css_thread_sp_init: D3C */
+
+/* function ia_css_isys_sp_reset_exp_id: 6110 */
 
-/* function ia_css_isys_sp_reset_exp_id: 5DC7 */
+/* function qos_scheduler_update_fps: 660A */
 
-/* function ia_css_ispctrl_sp_set_stream_base_addr: 4244 */
+/* function ia_css_ispctrl_sp_set_stream_base_addr: 4590 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_DMEM_BASE
@@ -762,44 +766,44 @@
 #define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
 #define HIVE_SIZE_sp_SP_DMEM_BASE 4
 
-/* function ia_css_dmaproxy_sp_read: 2F32 */
+/* function ia_css_dmaproxy_sp_read: 31AE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_copy_line_count
 #define HIVE_MEM_raw_copy_line_count scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_copy_line_count 0x2C8
+#define HIVE_ADDR_raw_copy_line_count 0x2C4
 #define HIVE_SIZE_raw_copy_line_count 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_copy_line_count scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_copy_line_count 0x2C8
+#define HIVE_ADDR_sp_raw_copy_line_count 0x2C4
 #define HIVE_SIZE_sp_raw_copy_line_count 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_tag_cmd_queue_handle
 #define HIVE_MEM_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4BA4
+#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x4BE8
 #define HIVE_SIZE_host2sp_tag_cmd_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4BA4
+#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x4BE8
 #define HIVE_SIZE_sp_host2sp_tag_cmd_queue_handle 12
 
-/* function ia_css_queue_peek: 4549 */
+/* function ia_css_queue_peek: 4895 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_frame_cnt
 #define HIVE_MEM_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x4A50
+#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x4A94
 #define HIVE_SIZE_ia_css_flash_sp_frame_cnt 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x4A50
+#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x4A94
 #define HIVE_SIZE_sp_ia_css_flash_sp_frame_cnt 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -817,67 +821,67 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_thread
 #define HIVE_MEM_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_thread 0x5EE8
+#define HIVE_ADDR_isp_thread 0x5F30
 #define HIVE_SIZE_isp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_thread 0x5EE8
+#define HIVE_ADDR_sp_isp_thread 0x5F30
 #define HIVE_SIZE_sp_isp_thread 4
 
-/* function encode_and_post_sp_event_non_blocking: A74 */
+/* function encode_and_post_sp_event_non_blocking: A78 */
 
-/* function ia_css_isys_sp_frontend_destroy: 5AC9 */
+/* function ia_css_isys_sp_frontend_destroy: 5E12 */
 
 /* function is_ddr_debug_buffer_full: 2CC */
 
-/* function ia_css_isys_sp_frontend_stop: 5A09 */
+/* function ia_css_isys_sp_frontend_stop: 5D52 */
 
-/* function ia_css_isys_sp_token_map_init: 5D65 */
+/* function ia_css_isys_sp_token_map_init: 60AE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_fiber
 #define HIVE_MEM_sp_threads_fiber scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_fiber 0x1A0
+#define HIVE_ADDR_sp_threads_fiber 0x19C
 #define HIVE_SIZE_sp_threads_fiber 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_fiber scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_fiber 0x1A0
+#define HIVE_ADDR_sp_sp_threads_fiber 0x19C
 #define HIVE_SIZE_sp_sp_threads_fiber 28
 
-/* function encode_and_post_sp_event: 9FD */
+/* function encode_and_post_sp_event: A01 */
 
 /* function debug_enqueue_ddr: EE */
 
-/* function ia_css_rmgr_sp_refcount_init_vbuf: 5F54 */
+/* function ia_css_rmgr_sp_refcount_init_vbuf: 629D */
 
-/* function dmaproxy_sp_read_write: 6AB6 */
+/* function dmaproxy_sp_read_write: 6EFE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer
 #define HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5BA0
+#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5BE4
 #define HIVE_SIZE_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5BA0
+#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x5BE4
 #define HIVE_SIZE_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_buffer_queue_handle
 #define HIVE_MEM_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4BB0
+#define HIVE_ADDR_host2sp_buffer_queue_handle 0x4BF4
 #define HIVE_SIZE_host2sp_buffer_queue_handle 480
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4BB0
+#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x4BF4
 #define HIVE_SIZE_sp_host2sp_buffer_queue_handle 480
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -892,54 +896,54 @@
 #define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x3178
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_service 4
 
-/* function ia_css_dmaproxy_sp_process: 682D */
+/* function ia_css_dmaproxy_sp_process: 6C0A */
 
-/* function ia_css_tagger_buf_sp_mark_from_end: 2966 */
+/* function ia_css_tagger_buf_sp_mark_from_end: 2B75 */
 
-/* function ia_css_isys_sp_backend_rcv_acquire_ack: 56D6 */
+/* function ia_css_isys_sp_backend_rcv_acquire_ack: 5A1F */
 
-/* function ia_css_isys_sp_backend_pre_acquire_request: 56EC */
+/* function ia_css_isys_sp_backend_pre_acquire_request: 5A35 */
 
-/* function ia_css_ispctrl_sp_init_cs: 333C */
+/* function ia_css_ispctrl_sp_init_cs: 35D4 */
 
-/* function ia_css_spctrl_sp_init: 5642 */
+/* function ia_css_spctrl_sp_init: 598B */
 
 /* function sp_event_proxy_init: 730 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_previous_clock_tick
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_previous_clock_tick scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4D90
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4DD4
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_previous_clock_tick 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4D90
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x4DD4
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_output
 #define HIVE_MEM_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_output 0x41C8
+#define HIVE_ADDR_sp_output 0x41F8
 #define HIVE_SIZE_sp_output 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_output 0x41C8
+#define HIVE_ADDR_sp_sp_output 0x41F8
 #define HIVE_SIZE_sp_sp_output 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4DA4
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4DE8
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4DA4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x4DE8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -966,52 +970,52 @@
 #define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
 #define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
 
-/* function sp_dma_proxy_reset_channels: 3170 */
+/* function sp_dma_proxy_reset_channels: 3408 */
 
-/* function ia_css_isys_sp_backend_acquire: 57F7 */
+/* function ia_css_isys_sp_backend_acquire: 5B40 */
 
-/* function ia_css_tagger_sp_update_size: 26E7 */
+/* function ia_css_tagger_sp_update_size: 28A9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_host_sp_queue
 #define HIVE_MEM_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x50C4
+#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x5108
 #define HIVE_SIZE_ia_css_bufq_host_sp_queue 2008
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x50C4
+#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x5108
 #define HIVE_SIZE_sp_ia_css_bufq_host_sp_queue 2008
 
-/* function thread_fiber_sp_create: DA4 */
+/* function thread_fiber_sp_create: DA8 */
 
-/* function ia_css_dmaproxy_sp_set_increments: 301E */
+/* function ia_css_dmaproxy_sp_set_increments: 329A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_frame
 #define HIVE_MEM_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_frame 0x4710
+#define HIVE_ADDR_sem_for_writing_cb_frame 0x4754
 #define HIVE_SIZE_sem_for_writing_cb_frame 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x4710
+#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x4754
 #define HIVE_SIZE_sp_sem_for_writing_cb_frame 20
 
-/* function receiver_reg_store: AD3 */
+/* function receiver_reg_store: AD7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_param
 #define HIVE_MEM_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_param 0x4724
+#define HIVE_ADDR_sem_for_writing_cb_param 0x4768
 #define HIVE_SIZE_sem_for_writing_cb_param 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4724
+#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x4768
 #define HIVE_SIZE_sp_sem_for_writing_cb_param 20
 
 /* function sp_start_isp_entry: 453 */
@@ -1022,49 +1026,51 @@
 #endif
 #define HIVE_ADDR_sp_sp_start_isp_entry 0x453
 
-/* function ia_css_tagger_buf_sp_unmark_all: 28FF */
+/* function ia_css_tagger_buf_sp_unmark_all: 2AF9 */
 
-/* function ia_css_tagger_buf_sp_unmark_from_start: 2940 */
+/* function ia_css_tagger_buf_sp_unmark_from_start: 2B3A */
 
-/* function ia_css_dmaproxy_sp_channel_acquire: 319C */
+/* function ia_css_dmaproxy_sp_channel_acquire: 3434 */
 
-/* function ia_css_rmgr_sp_add_num_vbuf: 6196 */
+/* function ia_css_rmgr_sp_add_num_vbuf: 64E7 */
 
-/* function ia_css_isys_sp_token_map_create: 5DAE */
+/* function ia_css_isys_sp_token_map_create: 60F7 */
 
-/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 2E88 */
+/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 3104 */
 
-/* function ia_css_bufq_sp_is_dynamic_buffer: 2D71 */
+/* function ia_css_tagger_sp_acquire_buf_elem: 1FDB */
+
+/* function ia_css_bufq_sp_is_dynamic_buffer: 2FED */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_group
 #define HIVE_MEM_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_group 0x41D8
-#define HIVE_SIZE_sp_group 1124
+#define HIVE_ADDR_sp_group 0x4208
+#define HIVE_SIZE_sp_group 1144
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_group 0x41D8
-#define HIVE_SIZE_sp_sp_group 1124
+#define HIVE_ADDR_sp_sp_group 0x4208
+#define HIVE_SIZE_sp_sp_group 1144
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_event_proxy_thread
 #define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_event_proxy_thread 0x4910
+#define HIVE_ADDR_sp_event_proxy_thread 0x4954
 #define HIVE_SIZE_sp_event_proxy_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_event_proxy_thread 0x4910
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x4954
 #define HIVE_SIZE_sp_sp_event_proxy_thread 68
 
-/* function ia_css_thread_sp_kill: CD2 */
+/* function ia_css_thread_sp_kill: CD6 */
 
-/* function ia_css_tagger_sp_create: 26AA */
+/* function ia_css_tagger_sp_create: 2863 */
 
-/* function tmpmem_acquire_dmem: 6243 */
+/* function tmpmem_acquire_dmem: 6594 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_MMU_BASE
@@ -1078,39 +1084,41 @@
 #define HIVE_ADDR_sp_MMU_BASE 0x24
 #define HIVE_SIZE_sp_MMU_BASE 8
 
-/* function ia_css_dmaproxy_sp_channel_release: 3188 */
+/* function ia_css_dmaproxy_sp_channel_release: 3420 */
 
-/* function ia_css_dmaproxy_sp_is_idle: 3168 */
+/* function ia_css_dmaproxy_sp_is_idle: 3400 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_qos_start
 #define HIVE_MEM_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_qos_start 0x4738
+#define HIVE_ADDR_sem_for_qos_start 0x477C
 #define HIVE_SIZE_sem_for_qos_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_qos_start 0x4738
+#define HIVE_ADDR_sp_sem_for_qos_start 0x477C
 #define HIVE_SIZE_sp_sem_for_qos_start 20
 
-/* function isp_hmem_load: B51 */
+/* function isp_hmem_load: B55 */
+
+/* function ia_css_tagger_sp_release_buf_elem: 1FB7 */
 
-/* function ia_css_eventq_sp_send: 31DE */
+/* function ia_css_eventq_sp_send: 3476 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_error_cnt
 #define HIVE_MEM_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x627C
+#define HIVE_ADDR_ia_css_isys_sp_error_cnt 0x62C4
 #define HIVE_SIZE_ia_css_isys_sp_error_cnt 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_error_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x627C
+#define HIVE_ADDR_sp_ia_css_isys_sp_error_cnt 0x62C4
 #define HIVE_SIZE_sp_ia_css_isys_sp_error_cnt 16
 
-/* function ia_css_tagger_buf_sp_unlock_from_start: 2875 */
+/* function ia_css_tagger_buf_sp_unlock_from_start: 2A29 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_debug_buffer_ddr_address
@@ -1126,29 +1134,29 @@
 
 /* function sp_isys_copy_request: 714 */
 
-/* function ia_css_rmgr_sp_refcount_retain_vbuf: 602E */
+/* function ia_css_rmgr_sp_refcount_retain_vbuf: 6377 */
 
-/* function ia_css_thread_sp_set_priority: CCA */
+/* function ia_css_thread_sp_set_priority: CCE */
 
-/* function sizeof_hmem: BF8 */
+/* function sizeof_hmem: BFC */
 
-/* function tmpmem_release_dmem: 6232 */
+/* function tmpmem_release_dmem: 6583 */
 
 /* function cnd_input_system_cfg: 392 */
 
-/* function __ia_css_sp_rawcopy_func_critical: 6B37 */
+/* function __ia_css_sp_rawcopy_func_critical: 6F7F */
 
-/* function ia_css_dmaproxy_sp_set_width_exception: 3009 */
+/* function ia_css_dmaproxy_sp_set_width_exception: 3285 */
 
 /* function sp_event_assert: 8B1 */
 
-/* function ia_css_flash_sp_init_internal_params: 29F0 */
+/* function ia_css_flash_sp_init_internal_params: 2C14 */
 
-/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 2705 */
+/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 28DA */
 
-/* function __modu: 6533 */
+/* function __modu: 68D5 */
 
-/* function ia_css_dmaproxy_sp_init_isp_vector: 2E8E */
+/* function ia_css_dmaproxy_sp_init_isp_vector: 310A */
 
 /* function isp_vamem_store: 0 */
 
@@ -1164,55 +1172,59 @@
 #define HIVE_ADDR_sp_GDC_BASE 0x44
 #define HIVE_SIZE_sp_GDC_BASE 8
 
-/* function ia_css_queue_local_init: 4834 */
+/* function ia_css_queue_local_init: 4B80 */
 
-/* function sp_event_proxy_callout_func: 65C5 */
+/* function sp_event_proxy_callout_func: 69A2 */
+
+/* function qos_scheduler_schedule_stage: 65DB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_num_ready_threads
 #define HIVE_MEM_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x499C
+#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x49E0
 #define HIVE_SIZE_ia_css_thread_sp_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x499C
+#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x49E0
 #define HIVE_SIZE_sp_ia_css_thread_sp_num_ready_threads 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack_size
 #define HIVE_MEM_sp_threads_stack_size scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_stack_size 0x184
+#define HIVE_ADDR_sp_threads_stack_size 0x180
 #define HIVE_SIZE_sp_threads_stack_size 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_stack_size scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_stack_size 0x184
+#define HIVE_ADDR_sp_sp_threads_stack_size 0x180
 #define HIVE_SIZE_sp_sp_threads_stack_size 28
 
-/* function ia_css_ispctrl_sp_isp_done_row_striping: 3B62 */
+/* function ia_css_ispctrl_sp_isp_done_row_striping: 3EAE */
 
-/* function __ia_css_isys_sp_isr_text: 5AF3 */
+/* function __ia_css_isys_sp_isr_text: 5E3C */
 
-/* function ia_css_queue_dequeue: 46B2 */
+/* function ia_css_queue_dequeue: 49FE */
 
-/* function ia_css_dmaproxy_sp_configure_channel: 6A42 */
+/* function ia_css_dmaproxy_sp_configure_channel: 6E66 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_thread_fiber_sp
 #define HIVE_MEM_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_current_thread_fiber_sp 0x49A4
+#define HIVE_ADDR_current_thread_fiber_sp 0x49E8
 #define HIVE_SIZE_current_thread_fiber_sp 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_thread_fiber_sp 0x49A4
+#define HIVE_ADDR_sp_current_thread_fiber_sp 0x49E8
 #define HIVE_SIZE_sp_current_thread_fiber_sp 4
 
-/* function ia_css_circbuf_pop: FCC */
+/* function ia_css_circbuf_pop: FD8 */
+
+/* function memset: 6954 */
 
 /* function irq_raise_set_token: B6 */
 
@@ -1228,99 +1240,99 @@
 #define HIVE_ADDR_sp_GPIO_BASE 0x3C
 #define HIVE_SIZE_sp_GPIO_BASE 4
 
-/* function ia_css_pipeline_acc_stage_enable: 1751 */
+/* function ia_css_pipeline_acc_stage_enable: 17D7 */
 
-/* function ia_css_tagger_sp_unlock_exp_id: 1F21 */
+/* function ia_css_tagger_sp_unlock_exp_id: 2028 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_ph
 #define HIVE_MEM_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_ph 0x628C
+#define HIVE_ADDR_isp_ph 0x62D4
 #define HIVE_SIZE_isp_ph 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_ph 0x628C
+#define HIVE_ADDR_sp_isp_ph 0x62D4
 #define HIVE_SIZE_sp_isp_ph 28
 
-/* function ia_css_isys_sp_token_map_flush: 5CF3 */
+/* function ia_css_isys_sp_token_map_flush: 603C */
 
-/* function ia_css_ispctrl_sp_init_ds: 349B */
+/* function ia_css_ispctrl_sp_init_ds: 3733 */
 
-/* function get_xmem_base_addr_raw: 3835 */
+/* function get_xmem_base_addr_raw: 3ADE */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param
 #define HIVE_MEM_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param 0x474C
+#define HIVE_ADDR_sp_all_cbs_param 0x4790
 #define HIVE_SIZE_sp_all_cbs_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param 0x474C
+#define HIVE_ADDR_sp_sp_all_cbs_param 0x4790
 #define HIVE_SIZE_sp_sp_all_cbs_param 16
 
-/* function ia_css_circbuf_create: 101A */
+/* function ia_css_circbuf_create: 1026 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp_group
 #define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp_group 0x475C
+#define HIVE_ADDR_sem_for_sp_group 0x47A0
 #define HIVE_SIZE_sem_for_sp_group 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp_group 0x475C
+#define HIVE_ADDR_sp_sem_for_sp_group 0x47A0
 #define HIVE_SIZE_sp_sem_for_sp_group 20
 
-/* function ia_css_framebuf_sp_wait_for_in_frame: 61C1 */
+/* function ia_css_framebuf_sp_wait_for_in_frame: 6512 */
 
-/* function ia_css_sp_rawcopy_tag_frame: 5259 */
+/* function ia_css_sp_rawcopy_tag_frame: 55A2 */
 
-/* function isp_hmem_clear: B21 */
+/* function isp_hmem_clear: B25 */
 
-/* function ia_css_framebuf_sp_release_in_frame: 6204 */
+/* function ia_css_framebuf_sp_release_in_frame: 6555 */
 
-/* function ia_css_isys_sp_backend_snd_acquire_request: 5749 */
+/* function ia_css_isys_sp_backend_snd_acquire_request: 5A92 */
 
-/* function ia_css_isys_sp_token_map_is_full: 5B7A */
+/* function ia_css_isys_sp_token_map_is_full: 5EC3 */
 
-/* function input_system_acquisition_run: AF5 */
+/* function input_system_acquisition_run: AF9 */
 
-/* function ia_css_ispctrl_sp_start_binary: 331A */
+/* function ia_css_ispctrl_sp_start_binary: 35B2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x589C
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x58E0
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x589C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x58E0
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 
-/* function ia_css_eventq_sp_recv: 31B0 */
+/* function ia_css_eventq_sp_recv: 3448 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_pool
 #define HIVE_MEM_isp_pool scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_pool 0x2E8
+#define HIVE_ADDR_isp_pool 0x2E4
 #define HIVE_SIZE_isp_pool 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_pool scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pool 0x2E8
+#define HIVE_ADDR_sp_isp_pool 0x2E4
 #define HIVE_SIZE_sp_isp_pool 4
 
-/* function ia_css_rmgr_sp_rel_gen: 5EFB */
+/* function ia_css_rmgr_sp_rel_gen: 6244 */
 
-/* function css_get_frame_processing_time_end: 1EEC */
+/* function css_get_frame_processing_time_end: 1FA7 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_any_pending_mask
@@ -1334,57 +1346,59 @@
 #define HIVE_ADDR_sp_event_any_pending_mask 0x300
 #define HIVE_SIZE_sp_event_any_pending_mask 8
 
-/* function ia_css_isys_sp_backend_push: 5700 */
+/* function ia_css_isys_sp_backend_push: 5A49 */
 
 /* function sh_css_decode_tag_descr: 352 */
 
 /* function debug_enqueue_isp: 27B */
 
-/* function ia_css_spctrl_sp_uninit: 563B */
+/* function qos_scheduler_update_stage_budget: 65C9 */
+
+/* function ia_css_spctrl_sp_uninit: 5984 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SWITCH_CODE
 #define HIVE_MEM_HIVE_IF_SWITCH_CODE scalar_processor_2400_dmem
-#define HIVE_ADDR_HIVE_IF_SWITCH_CODE 0x1DC
+#define HIVE_ADDR_HIVE_IF_SWITCH_CODE 0x1D8
 #define HIVE_SIZE_HIVE_IF_SWITCH_CODE 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_HIVE_IF_SWITCH_CODE scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_HIVE_IF_SWITCH_CODE 0x1DC
+#define HIVE_ADDR_sp_HIVE_IF_SWITCH_CODE 0x1D8
 #define HIVE_SIZE_sp_HIVE_IF_SWITCH_CODE 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x58B0
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x58F4
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_dis_bufs 140
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x58B0
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x58F4
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_dis_bufs 140
 
-/* function ia_css_tagger_buf_sp_lock_from_start: 2897 */
+/* function ia_css_tagger_buf_sp_lock_from_start: 2A5D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_isp_idle
 #define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_isp_idle 0x4770
+#define HIVE_ADDR_sem_for_isp_idle 0x47B4
 #define HIVE_SIZE_sem_for_isp_idle 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_isp_idle 0x4770
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x47B4
 #define HIVE_SIZE_sp_sem_for_isp_idle 20
 
-/* function ia_css_dmaproxy_sp_write_byte_addr: 2EEB */
+/* function ia_css_dmaproxy_sp_write_byte_addr: 3167 */
 
-/* function ia_css_dmaproxy_sp_init: 2E62 */
+/* function ia_css_dmaproxy_sp_init: 30DE */
 
-/* function ia_css_bufq_sp_release_dynamic_buf_clock_tick: 2A82 */
+/* function ia_css_bufq_sp_release_dynamic_buf_clock_tick: 2CE6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_VAMEM_BASE
@@ -1401,46 +1415,46 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rawcopy_sp_tagger
 #define HIVE_MEM_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x623C
+#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x6284
 #define HIVE_SIZE_ia_css_rawcopy_sp_tagger 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x623C
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x6284
 #define HIVE_SIZE_sp_ia_css_rawcopy_sp_tagger 24
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x593C
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x5980
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_exp_ids 70
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x593C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x5980
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_exp_ids 70
 
-/* function ia_css_queue_item_load: 4926 */
+/* function ia_css_queue_item_load: 4C72 */
 
-/* function ia_css_spctrl_sp_get_state: 5626 */
+/* function ia_css_spctrl_sp_get_state: 596F */
 
-/* function ia_css_isys_sp_token_map_uninit: 5D10 */
+/* function ia_css_isys_sp_token_map_uninit: 6059 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_callout_sp_thread
 #define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_callout_sp_thread 0x4998
+#define HIVE_ADDR_callout_sp_thread 0x49DC
 #define HIVE_SIZE_callout_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_callout_sp_thread 0x4998
+#define HIVE_ADDR_sp_callout_sp_thread 0x49DC
 #define HIVE_SIZE_sp_callout_sp_thread 4
 
-/* function thread_fiber_sp_init: E2B */
+/* function thread_fiber_sp_init: E2F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_SP_PMEM_BASE
@@ -1454,101 +1468,101 @@
 #define HIVE_ADDR_sp_SP_PMEM_BASE 0x0
 #define HIVE_SIZE_sp_SP_PMEM_BASE 4
 
-/* function ia_css_isys_sp_token_map_snd_acquire_req: 5C80 */
+/* function ia_css_isys_sp_token_map_snd_acquire_req: 5FC9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_input_stream_format
 #define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_input_stream_format 0x40C8
+#define HIVE_ADDR_sp_isp_input_stream_format 0x40F8
 #define HIVE_SIZE_sp_isp_input_stream_format 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x40C8
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x40F8
 #define HIVE_SIZE_sp_sp_isp_input_stream_format 20
 
-/* function __mod: 651F */
+/* function __mod: 68C1 */
 
-/* function ia_css_dmaproxy_sp_init_dmem_channel: 2F4C */
+/* function ia_css_dmaproxy_sp_init_dmem_channel: 31C8 */
 
-/* function ia_css_thread_sp_join: CFB */
+/* function ia_css_thread_sp_join: CFF */
 
-/* function ia_css_dmaproxy_sp_add_command: 6B21 */
+/* function ia_css_dmaproxy_sp_add_command: 6F69 */
 
-/* function ia_css_sp_metadata_thread_func: 54DA */
+/* function ia_css_sp_metadata_thread_func: 5823 */
 
-/* function __sp_event_proxy_func_critical: 65B2 */
+/* function __sp_event_proxy_func_critical: 698F */
 
-/* function ia_css_sp_metadata_wait: 55ED */
+/* function ia_css_sp_metadata_wait: 5936 */
 
-/* function ia_css_circbuf_peek_from_start: F00 */
+/* function ia_css_circbuf_peek_from_start: F08 */
 
-/* function ia_css_event_sp_encode: 323B */
+/* function ia_css_event_sp_encode: 34D3 */
 
-/* function ia_css_thread_sp_run: D6E */
+/* function ia_css_thread_sp_run: D72 */
 
 /* function sp_isys_copy_func: 6F6 */
 
-/* function ia_css_isys_sp_backend_flush: 5769 */
+/* function ia_css_isys_sp_backend_flush: 5AB2 */
 
-/* function ia_css_isys_sp_backend_frame_exists: 5685 */
+/* function ia_css_isys_sp_backend_frame_exists: 59CE */
 
-/* function ia_css_sp_isp_param_init_isp_memories: 43AF */
+/* function ia_css_sp_isp_param_init_isp_memories: 46FB */
 
 /* function register_isr: 8A9 */
 
 /* function irq_raise: C8 */
 
-/* function ia_css_dmaproxy_sp_mmu_invalidate: 2E29 */
+/* function ia_css_dmaproxy_sp_mmu_invalidate: 30A5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_HIVE_IF_SRST_ADDRESS
 #define HIVE_MEM_HIVE_IF_SRST_ADDRESS scalar_processor_2400_dmem
-#define HIVE_ADDR_HIVE_IF_SRST_ADDRESS 0x1BC
+#define HIVE_ADDR_HIVE_IF_SRST_ADDRESS 0x1B8
 #define HIVE_SIZE_HIVE_IF_SRST_ADDRESS 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_HIVE_IF_SRST_ADDRESS scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x1BC
+#define HIVE_ADDR_sp_HIVE_IF_SRST_ADDRESS 0x1B8
 #define HIVE_SIZE_sp_HIVE_IF_SRST_ADDRESS 16
 
-/* function pipeline_sp_initialize_stage: 1872 */
+/* function pipeline_sp_initialize_stage: 190B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_isys_sp_frontend_states
 #define HIVE_MEM_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x6270
+#define HIVE_ADDR_ia_css_isys_sp_frontend_states 0x62B8
 #define HIVE_SIZE_ia_css_isys_sp_frontend_states 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_isys_sp_frontend_states scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x6270
+#define HIVE_ADDR_sp_ia_css_isys_sp_frontend_states 0x62B8
 #define HIVE_SIZE_sp_ia_css_isys_sp_frontend_states 12
 
-/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6A14 */
+/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6E38 */
 
-/* function ia_css_ispctrl_sp_done_ds: 3482 */
+/* function ia_css_ispctrl_sp_done_ds: 371A */
 
-/* function ia_css_sp_isp_param_get_mem_inits: 438A */
+/* function ia_css_sp_isp_param_get_mem_inits: 46D6 */
 
-/* function ia_css_parambuf_sp_init_buffer_queues: 13C5 */
+/* function ia_css_parambuf_sp_init_buffer_queues: 13D0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_pfp_spref
 #define HIVE_MEM_vbuf_pfp_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_pfp_spref 0x2F0
+#define HIVE_ADDR_vbuf_pfp_spref 0x2EC
 #define HIVE_SIZE_vbuf_pfp_spref 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_pfp_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_pfp_spref 0x2F0
+#define HIVE_ADDR_sp_vbuf_pfp_spref 0x2EC
 #define HIVE_SIZE_sp_vbuf_pfp_spref 4
 
-/* function input_system_cfg: AB7 */
+/* function input_system_cfg: ABB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_HMEM_BASE
@@ -1565,206 +1579,208 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_frames
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x5984
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x59C8
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_frames 280
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x5984
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x59C8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_frames 280
 
-/* function ia_css_isys_sp_backend_release: 57DE */
+/* function qos_scheduler_init_stage_budget: 6602 */
+
+/* function ia_css_isys_sp_backend_release: 5B27 */
 
-/* function ia_css_isys_sp_backend_destroy: 5808 */
+/* function ia_css_isys_sp_backend_destroy: 5B51 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_buffer_queue_handle
 #define HIVE_MEM_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_buffer_queue_handle 0x5A9C
+#define HIVE_ADDR_sp2host_buffer_queue_handle 0x5AE0
 #define HIVE_SIZE_sp2host_buffer_queue_handle 96
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x5A9C
+#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x5AE0
 #define HIVE_SIZE_sp_sp2host_buffer_queue_handle 96
 
-/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 5C44 */
+/* function ia_css_isys_sp_token_map_check_mipi_frame_size: 5F8D */
 
-/* function ia_css_ispctrl_sp_init_isp_vars: 40A9 */
+/* function ia_css_ispctrl_sp_init_isp_vars: 43F5 */
 
-/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 585A */
+/* function ia_css_isys_sp_frontend_has_empty_mipi_buffer_cb: 5BA3 */
 
-/* function sp_warning: 8DB */
+/* function sp_warning: 8DC */
 
-/* function ia_css_rmgr_sp_vbuf_enqueue: 5FEE */
+/* function ia_css_rmgr_sp_vbuf_enqueue: 6337 */
 
-/* function ia_css_tagger_sp_tag_exp_id: 2018 */
+/* function ia_css_tagger_sp_tag_exp_id: 2132 */
 
-/* function ia_css_dmaproxy_sp_write: 2F02 */
+/* function ia_css_dmaproxy_sp_write: 317E */
 
-/* function ia_css_parambuf_sp_release_in_param: 1245 */
+/* function ia_css_parambuf_sp_release_in_param: 1250 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_irq_sw_interrupt_token
 #define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_irq_sw_interrupt_token 0x40C4
+#define HIVE_ADDR_irq_sw_interrupt_token 0x40F4
 #define HIVE_SIZE_irq_sw_interrupt_token 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x40C4
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x40F4
 #define HIVE_SIZE_sp_irq_sw_interrupt_token 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_addresses
 #define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_addresses 0x5EEC
+#define HIVE_ADDR_sp_isp_addresses 0x5F34
 #define HIVE_SIZE_sp_isp_addresses 172
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_addresses 0x5EEC
+#define HIVE_ADDR_sp_sp_isp_addresses 0x5F34
 #define HIVE_SIZE_sp_sp_isp_addresses 172
 
-/* function ia_css_rmgr_sp_acq_gen: 5F13 */
+/* function ia_css_rmgr_sp_acq_gen: 625C */
 
-/* function receiver_reg_load: ACC */
+/* function receiver_reg_load: AD0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isps
 #define HIVE_MEM_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_isps 0x62A8
+#define HIVE_ADDR_isps 0x62F0
 #define HIVE_SIZE_isps 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isps 0x62A8
+#define HIVE_ADDR_sp_isps 0x62F0
 #define HIVE_SIZE_sp_isps 28
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_queues_initialized
 #define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_queues_initialized 0x40DC
+#define HIVE_ADDR_host_sp_queues_initialized 0x410C
 #define HIVE_SIZE_host_sp_queues_initialized 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_queues_initialized 0x40DC
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x410C
 #define HIVE_SIZE_sp_host_sp_queues_initialized 4
 
-/* function ia_css_queue_uninit: 47F2 */
+/* function ia_css_queue_uninit: 4B3E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_ispctrl_sp_isp_started
 #define HIVE_MEM_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5BA4
+#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x5BE8
 #define HIVE_SIZE_ia_css_ispctrl_sp_isp_started 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5BA4
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x5BE8
 #define HIVE_SIZE_sp_ia_css_ispctrl_sp_isp_started 4
 
-/* function ia_css_bufq_sp_release_dynamic_buf: 2AD6 */
+/* function ia_css_bufq_sp_release_dynamic_buf: 2D52 */
 
-/* function ia_css_dmaproxy_sp_set_height_exception: 2FFA */
+/* function ia_css_dmaproxy_sp_set_height_exception: 3276 */
 
-/* function ia_css_dmaproxy_sp_init_vmem_channel: 2F7F */
+/* function ia_css_dmaproxy_sp_init_vmem_channel: 31FB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_num_ready_threads
 #define HIVE_MEM_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_num_ready_threads 0x49A0
+#define HIVE_ADDR_num_ready_threads 0x49E4
 #define HIVE_SIZE_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_num_ready_threads 0x49A0
+#define HIVE_ADDR_sp_num_ready_threads 0x49E4
 #define HIVE_SIZE_sp_num_ready_threads 4
 
-/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 2ED4 */
+/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 3150 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_spref
 #define HIVE_MEM_vbuf_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_spref 0x2EC
+#define HIVE_ADDR_vbuf_spref 0x2E8
 #define HIVE_SIZE_vbuf_spref 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_spref 0x2EC
+#define HIVE_ADDR_sp_vbuf_spref 0x2E8
 #define HIVE_SIZE_sp_vbuf_spref 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_metadata_thread
 #define HIVE_MEM_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_metadata_thread 0x4954
+#define HIVE_ADDR_sp_metadata_thread 0x4998
 #define HIVE_SIZE_sp_metadata_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_metadata_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_metadata_thread 0x4954
+#define HIVE_ADDR_sp_sp_metadata_thread 0x4998
 #define HIVE_SIZE_sp_sp_metadata_thread 68
 
-/* function ia_css_queue_enqueue: 473C */
+/* function ia_css_queue_enqueue: 4A88 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_request
 #define HIVE_MEM_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_request 0x4A54
+#define HIVE_ADDR_ia_css_flash_sp_request 0x4A98
 #define HIVE_SIZE_ia_css_flash_sp_request 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x4A54
+#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x4A98
 #define HIVE_SIZE_sp_ia_css_flash_sp_request 4
 
-/* function ia_css_dmaproxy_sp_vmem_write: 2EA5 */
+/* function ia_css_dmaproxy_sp_vmem_write: 3121 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tagger_frames
 #define HIVE_MEM_tagger_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_tagger_frames 0x49A8
+#define HIVE_ADDR_tagger_frames 0x49EC
 #define HIVE_SIZE_tagger_frames 168
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tagger_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tagger_frames 0x49A8
+#define HIVE_ADDR_sp_tagger_frames 0x49EC
 #define HIVE_SIZE_sp_tagger_frames 168
 
-/* function ia_css_isys_sp_token_map_snd_capture_req: 5CA2 */
+/* function ia_css_isys_sp_token_map_snd_capture_req: 5FEB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_if
 #define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_if 0x4784
+#define HIVE_ADDR_sem_for_reading_if 0x47C8
 #define HIVE_SIZE_sem_for_reading_if 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_if 0x4784
+#define HIVE_ADDR_sp_sem_for_reading_if 0x47C8
 #define HIVE_SIZE_sp_sem_for_reading_if 20
 
-/* function sp_generate_interrupts: 95A */
+/* function sp_generate_interrupts: 95B */
 
-/* function ia_css_pipeline_sp_start: 1785 */
+/* function ia_css_pipeline_sp_start: 181E */
 
-/* function ia_css_sp_rawcopy_init: 4D19 */
+/* function ia_css_sp_rawcopy_init: 5065 */
 
-/* function tmr_clock_read: 13DF */
+/* function tmr_clock_read: 13EA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_BAMEM_BASE
@@ -1778,55 +1794,55 @@
 #define HIVE_ADDR_sp_ISP_BAMEM_BASE 0x2F8
 #define HIVE_SIZE_sp_ISP_BAMEM_BASE 4
 
-/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5909 */
+/* function ia_css_isys_sp_frontend_rcv_capture_ack: 5C52 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5AFC
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5B40
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5AFC
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x5B40
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 
-/* function css_get_frame_processing_time_start: 1EF4 */
+/* function css_get_frame_processing_time_start: 1FAF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame
 #define HIVE_MEM_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame 0x4798
+#define HIVE_ADDR_sp_all_cbs_frame 0x47DC
 #define HIVE_SIZE_sp_all_cbs_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame 0x4798
+#define HIVE_ADDR_sp_sp_all_cbs_frame 0x47DC
 #define HIVE_SIZE_sp_sp_all_cbs_frame 16
 
-/* function thread_sp_queue_print: D8B */
+/* function thread_sp_queue_print: D8F */
 
-/* function sp_notify_eof: 906 */
+/* function sp_notify_eof: 907 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_str2mem
 #define HIVE_MEM_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_str2mem 0x47A8
+#define HIVE_ADDR_sem_for_str2mem 0x47EC
 #define HIVE_SIZE_sem_for_str2mem 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_str2mem 0x47A8
+#define HIVE_ADDR_sp_sem_for_str2mem 0x47EC
 #define HIVE_SIZE_sp_sem_for_str2mem 20
 
-/* function ia_css_tagger_buf_sp_is_marked_from_start: 28DC */
+/* function ia_css_tagger_buf_sp_is_marked_from_start: 2AC5 */
 
-/* function ia_css_bufq_sp_acquire_dynamic_buf: 2C8B */
+/* function ia_css_bufq_sp_acquire_dynamic_buf: 2F07 */
 
-/* function ia_css_circbuf_destroy: 1011 */
+/* function ia_css_circbuf_destroy: 101D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_PMEM_BASE
@@ -1840,68 +1856,68 @@
 #define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
 #define HIVE_SIZE_sp_ISP_PMEM_BASE 4
 
-/* function ia_css_sp_isp_param_mem_load: 431D */
+/* function ia_css_sp_isp_param_mem_load: 4669 */
 
-/* function __div: 64D7 */
+/* function __div: 6879 */
 
-/* function ia_css_isys_sp_frontend_create: 5ADA */
+/* function ia_css_isys_sp_frontend_create: 5E23 */
 
-/* function ia_css_rmgr_sp_refcount_release_vbuf: 600D */
+/* function ia_css_rmgr_sp_refcount_release_vbuf: 6356 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_in_use
 #define HIVE_MEM_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_in_use 0x4A58
+#define HIVE_ADDR_ia_css_flash_sp_in_use 0x4A9C
 #define HIVE_SIZE_ia_css_flash_sp_in_use 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x4A58
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x4A9C
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_use 4
 
-/* function ia_css_thread_sem_sp_wait: 677F */
+/* function ia_css_thread_sem_sp_wait: 6B5C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sleep_mode
 #define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sleep_mode 0x40E0
+#define HIVE_ADDR_sp_sleep_mode 0x4110
 #define HIVE_SIZE_sp_sleep_mode 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sleep_mode 0x40E0
+#define HIVE_ADDR_sp_sp_sleep_mode 0x4110
 #define HIVE_SIZE_sp_sp_sleep_mode 4
 
-/* function ia_css_tagger_buf_sp_push: 27F5 */
+/* function ia_css_tagger_buf_sp_push: 29C0 */
 
 /* function mmu_invalidate_cache: D3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_max_cb_elems
 #define HIVE_MEM_sp_max_cb_elems scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_max_cb_elems 0x14C
+#define HIVE_ADDR_sp_max_cb_elems 0x148
 #define HIVE_SIZE_sp_max_cb_elems 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_max_cb_elems scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_max_cb_elems 0x14C
+#define HIVE_ADDR_sp_sp_max_cb_elems 0x148
 #define HIVE_SIZE_sp_sp_max_cb_elems 8
 
-/* function ia_css_queue_remote_init: 4814 */
+/* function ia_css_queue_remote_init: 4B60 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stop_req
 #define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stop_req 0x463C
+#define HIVE_ADDR_isp_stop_req 0x4680
 #define HIVE_SIZE_isp_stop_req 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stop_req 0x463C
+#define HIVE_ADDR_sp_isp_stop_req 0x4680
 #define HIVE_SIZE_sp_isp_stop_req 4
 
 #define HIVE_ICACHE_sp_critical_SEGMENT_START 0
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/interface/ia_css_circbuf.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/interface/ia_css_circbuf.h
index 32afa10..2a38e2b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/interface/ia_css_circbuf.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/interface/ia_css_circbuf.h
@@ -15,12 +15,12 @@
 #ifndef _IA_CSS_CIRCBUF_H
 #define _IA_CSS_CIRCBUF_H
 
-#include <assert_support.h>
+#include <sp.h>
 #include <type_support.h>
 #include <math_support.h>
 #include <storage_class.h>
+#include <assert_support.h>
 #include <platform_support.h>
-#include <sp.h>
 #include "ia_css_circbuf_comm.h"
 #include "ia_css_circbuf_desc.h"
 #ifdef __SP
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/src/circbuf.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/src/circbuf.c
index e94f526..2493dd2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/src/circbuf.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/base/circbuf/src/circbuf.c
@@ -19,7 +19,9 @@
 #ifdef __SP
 #include <hive_isp_css_sp_api_modified.h>
 #include <ia_css_sp_file_id.sp.h>
+#ifndef SP_FILE_ID
 #define SP_FILE_ID SP_FILE_ID_CIRCBUF /* overrule default in ia_css_sp_assert_level.sp.h */
+#endif
 #include <ia_css_sp_assert_level.sp.h>
 #endif
 
@@ -317,6 +319,9 @@ ia_css_circbuf_shift_chunk(ia_css_circbuf_t *cb,
 		ia_css_circbuf_elem_cpy(&cb->elems[chunk_src],
 					     &cb->elems[chunk_dest]);
 
+		/* clear the source position */
+		ia_css_circbuf_elem_init(&cb->elems[chunk_src]);
+
 		/* adjust the source/terminal positions */
 		chunk_src = ia_css_circbuf_get_pos_at_offset(cb, chunk_src, -1);
 		chunk_dest = ia_css_circbuf_get_pos_at_offset(cb, chunk_dest, -1);
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h
index 8ffc41d..b5b0e60 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/interface/ia_css_pipe_binarydesc.h
@@ -117,7 +117,7 @@ extern enum ia_css_err ia_css_pipe_get_video_binarydesc(
  *
  */
 void ia_css_pipe_get_yuvscaler_binarydesc(
-	struct ia_css_pipe * const pipe,
+	struct ia_css_pipe const * const pipe,
 	struct ia_css_binary_descr *yuv_scaler_descr,
 	struct ia_css_frame_info *in_info,
 	struct ia_css_frame_info *out_info,
@@ -267,4 +267,20 @@ extern void ia_css_pipe_get_post_anr_binarydesc(
 	struct ia_css_frame_info *out_info,
 	struct ia_css_frame_info *vf_info);
 
+/** @brief Get a binary descriptor for ldc stage.
+ *
+ * @param[in/out] pipe
+ * @param[out] capture_pp_descr
+ * @param[in/out] in_info
+ * @param[in/out] vf_info
+ * @return    None
+ *
+ */
+extern void ia_css_pipe_get_ldc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *ldc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info);
+
+
 #endif /* __IA_CSS_PIPE_BINARYDESC_H__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c
index 20af57c..79996e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/camera/pipe/src/pipe_binarydesc.c
@@ -56,6 +56,7 @@ static void pipe_binarydesc_get_offline(
 	descr->enable_dz = true;
 	descr->enable_xnr = false;
 	descr->enable_dpc = false;
+	descr->enable_capture_pp_bli = false;
 	descr->enable_fractional_ds = false;
 	descr->dvs_env.width = 0;
 	descr->dvs_env.height = 0;
@@ -460,7 +461,7 @@ enum ia_css_err ia_css_pipe_get_video_binarydesc(
 }
 
 void ia_css_pipe_get_yuvscaler_binarydesc(
-	struct ia_css_pipe * const pipe,
+	struct ia_css_pipe const * const pipe,
 	struct ia_css_binary_descr *yuv_scaler_descr,
 	struct ia_css_frame_info *in_info,
 	struct ia_css_frame_info *out_info,
@@ -468,6 +469,7 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	struct ia_css_frame_info *vf_info)
 {
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+	struct ia_css_frame_info *this_vf_info = NULL;
 
 	assert(pipe != NULL);
 	assert(in_info != NULL);
@@ -488,11 +490,15 @@ void ia_css_pipe_get_yuvscaler_binarydesc(
 	 * fails
 	 */
 
+	if (vf_info) {
+		this_vf_info = (vf_info->res.width == 0 &&
+			vf_info->res.height == 0) ? NULL : vf_info;
+	}
+
 	pipe_binarydesc_get_offline(pipe,
 			       IA_CSS_BINARY_MODE_CAPTURE_PP,
 			       yuv_scaler_descr,
-			       in_info, out_infos,
-			       (vf_info->res.width == 0 && vf_info->res.height == 0) ? NULL : vf_info);
+			       in_info, out_infos, this_vf_info);
 
 	yuv_scaler_descr->enable_fractional_ds = true;
 	IA_CSS_LEAVE_PRIVATE("");
@@ -533,6 +539,8 @@ void ia_css_pipe_get_capturepp_binarydesc(
 			       capture_pp_descr,
 			       in_info, out_infos, vf_info);
 
+	capture_pp_descr->enable_capture_pp_bli =
+		pipe->config.default_capture_config.enable_capture_pp_bli;
 	capture_pp_descr->enable_fractional_ds = true;
 	capture_pp_descr->enable_xnr =
 		pipe->config.default_capture_config.enable_xnr != 0;
@@ -558,7 +566,7 @@ void ia_css_pipe_get_primary_binarydesc(
 	struct ia_css_frame_info *vf_info,
 	unsigned int stage_idx)
 {
-	unsigned int pipe_version = pipe->config.isp_pipe_version;
+	enum ia_css_pipe_version pipe_version = pipe->config.isp_pipe_version;
 	int mode;
 	unsigned int i;
 	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
@@ -833,3 +841,33 @@ void ia_css_pipe_get_post_anr_binarydesc(
 	post_anr_descr->isp_pipe_version = pipe->config.isp_pipe_version;
 	IA_CSS_LEAVE_PRIVATE("");
 }
+
+void ia_css_pipe_get_ldc_binarydesc(
+	struct ia_css_pipe const * const pipe,
+	struct ia_css_binary_descr *ldc_descr,
+	struct ia_css_frame_info *in_info,
+	struct ia_css_frame_info *out_info)
+{
+	unsigned int i;
+	struct ia_css_frame_info *out_infos[IA_CSS_BINARY_MAX_OUTPUT_PORTS];
+
+	assert(pipe != NULL);
+	assert(in_info != NULL);
+	assert(out_info != NULL);
+	IA_CSS_ENTER_PRIVATE("");
+
+	*in_info = *out_info;
+	in_info->format = IA_CSS_FRAME_FORMAT_YUV420;
+	in_info->raw_bit_depth = 0;
+	ia_css_frame_info_set_width(in_info, in_info->res.width, 0);
+
+	out_infos[0] = out_info;
+	for (i = 1; i < IA_CSS_BINARY_MAX_OUTPUT_PORTS; i++)
+		out_infos[i] = NULL;
+
+	pipe_binarydesc_get_offline(pipe, IA_CSS_BINARY_MODE_CAPTURE_PP,
+			       ldc_descr, in_info, out_infos, NULL);
+	ldc_descr->enable_dvs_6axis =
+		    pipe->extra_config.enable_dvs_6axis;
+	IA_CSS_LEAVE_PRIVATE("");
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq.c
index ab1a3c1..14d1d3b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq.c
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #include <system_local.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_local.h
index d303ee4..0bffb56 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_local.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_local.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __ISYS_IRQ_LOCAL_H__
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_private.h
index 02666d2..c17ce13 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_private.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_irq_private.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __ISYS_IRQ_PRIVATE_H__
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_stream2mmio_private.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_stream2mmio_private.h
index 0cea7ec..1603a09 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_stream2mmio_private.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/host/isys_stream2mmio_private.h
@@ -16,11 +16,9 @@
 #define __ISYS_STREAM2MMIO_PRIVATE_H_INCLUDED__
 
 #include "isys_stream2mmio_public.h"
-
 #include "device_access.h"	/* ia_css_device_load_uint32 */
-
-#include "assert_support.h" /* assert */
-#include "print_support.h" /* print */
+#include "assert_support.h"	/* assert */
+#include "print_support.h"	/* print */
 
 #define STREAM2MMIO_COMMAND_REG_ID             0
 #define STREAM2MMIO_ACKNOWLEDGE_REG_ID         1
@@ -45,17 +43,14 @@ STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_get_state(
 		const stream2mmio_ID_t ID,
 		stream2mmio_state_t *state)
 {
-	uint32_t i;
+	stream2mmio_sid_ID_t i;
 
 	/*
 	 * Get the values of the register-set per
 	 * stream2mmio-controller sids.
 	 */
-	for (i = 0; i < N_STREAM2MMIO_SID_PROCS[ID]; i++) {
-		stream2mmio_get_sid_state(
-				ID,
-				i,
-				&(state->sid_state[i]));
+	for (i = STREAM2MMIO_SID0_ID; i < N_STREAM2MMIO_SID_PROCS[ID]; i++) {
+		stream2mmio_get_sid_state(ID, i, &(state->sid_state[i]));
 	}
 }
 
@@ -65,7 +60,7 @@ STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_get_state(
  */
 STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_get_sid_state(
 		const stream2mmio_ID_t ID,
-		const uint32_t sid_id,
+		const stream2mmio_sid_ID_t sid_id,
 		stream2mmio_sid_state_t	*state)
 {
 
@@ -116,16 +111,15 @@ STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_dump_state(
 		const stream2mmio_ID_t ID,
 		stream2mmio_state_t *state)
 {
-	uint32_t i;
+	stream2mmio_sid_ID_t i;
 
 	/*
 	 * Get the values of the register-set per
 	 * stream2mmio-controller sids.
 	 */
-	for (i = 0; i < N_STREAM2MMIO_SID_PROCS[ID]; i++) {
+	for (i = STREAM2MMIO_SID0_ID; i < N_STREAM2MMIO_SID_PROCS[ID]; i++) {
 		ia_css_print("StREAM2MMIO ID %d SID %d\n", ID, i);
-		stream2mmio_print_sid_state(
-				&(state->sid_state[i]));
+		stream2mmio_print_sid_state(&(state->sid_state[i]));
 	}
 }
 /** end of NCI */
@@ -140,17 +134,17 @@ STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_dump_state(
  * Refer to "stream2mmio_public.h" for details.
  */
 STORAGE_CLASS_STREAM2MMIO_C hrt_data stream2mmio_reg_load(
-	const stream2mmio_ID_t ID,
-	const uint32_t sid_id,
-	const uint32_t reg_idx)
+		const stream2mmio_ID_t ID,
+		const stream2mmio_sid_ID_t sid_id,
+		const uint32_t reg_idx)
 {
 	uint32_t reg_bank_offset;
+
 	assert(ID < N_STREAM2MMIO_ID);
 
-	reg_bank_offset =
-		STREAM2MMIO_REGS_PER_SID * sid_id;
+	reg_bank_offset = STREAM2MMIO_REGS_PER_SID * sid_id;
 	return ia_css_device_load_uint32(STREAM2MMIO_CTRL_BASE[ID] +
-						(reg_bank_offset + reg_idx)*sizeof(hrt_data));
+			(reg_bank_offset + reg_idx) * sizeof(hrt_data));
 }
 
 
@@ -159,14 +153,15 @@ STORAGE_CLASS_STREAM2MMIO_C hrt_data stream2mmio_reg_load(
  * Refer to "stream2mmio_public.h" for details.
  */
 STORAGE_CLASS_STREAM2MMIO_C void stream2mmio_reg_store(
-	const stream2mmio_ID_t ID,
-	const hrt_address reg,
-	const hrt_data value)
+		const stream2mmio_ID_t ID,
+		const hrt_address reg,
+		const hrt_data value)
 {
 	assert(ID < N_STREAM2MMIO_ID);
 	assert(STREAM2MMIO_CTRL_BASE[ID] != (hrt_address)-1);
 
-	ia_css_device_store_uint32(STREAM2MMIO_CTRL_BASE[ID] + reg*sizeof(hrt_data), value);
+	ia_css_device_store_uint32(STREAM2MMIO_CTRL_BASE[ID] +
+		reg * sizeof(hrt_data), value);
 }
 /** end of DLI */
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/isys_irq_global.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/isys_irq_global.h
index a056e98..41d051d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/isys_irq_global.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_2401_system/isys_irq_global.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __ISYS_IRQ_GLOBAL_H__
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_api_version.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_api_version.h
index 303fdf9..2685d1a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_api_version.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/css_api_version.h
@@ -35,7 +35,7 @@ The version string has four dot-separated numbers, read left to right:
 
 */
 
-#define CSS_API_VERSION_STRING	"2.1.11.2"
+#define CSS_API_VERSION_STRING	"2.1.14.18"
 
 /*
 Change log
@@ -229,32 +229,93 @@ v2.1.9.2, added IA_CSS_EVENT_TYPE_TIMER
 v2.1.10.0 (4 changes parallel), Add a flag "enable_dpc" to "struct ia_css_pipe_config"
 - Add a flag "enable_dpc" to "struct ia_css_pipe_config"
 
-v2.1.10.4 (4 changes parallel), fix IEFD's puclic API types
+v2.1.10.6 (6 changes parallel), change the pipe version type from integer to enum
+- add new enum to enumerate ISP pipe version
+- change the pipe version type in pipe_config from integer to enum
+
+v2.1.13.0 (8 changes parallel), Stop Support for Skycam B0
+- Remove a few pre-processor defines for Skycam B0/C0 as support
+
+v2.1.14.0 (23 changes parallel), change the pipe version type from integer to enum
+- remove the temporary workaround for backward compatability
+
+v2.1.14.0 (12 changes parallel), expose_gamma_enable_option
+- added enable param to gamma_corr_public_config
+- added documentation to rgbpp_public.h
+
+v2.1.14.0 (11 changes parallel), Remove deprecated FW_ERROR event.
+- Remove code for deprecated FW_ERROR event.
+
+v2.1.14.3 (5 changes parallel), fix IEFD's puclic API types
 - fix IEFD public API members types: rad_cu6_x1,rad_cu_unsharp_x1 & unsharp_amount
 
-v2.1.10.4 (4 changes parallel), Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH
+v2.1.14.3 (5 changes parallel), Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH
 - Add IA_CSS_FW_WARNING_FRAME_PARAM_MISMATCH enum to ia_css_fw_warning type
 
-v2.1.10.5 (5 changes parallel), change the pipe version type from integer to enum
-- add new enum to enumerate ISP pipe version
-- change the pipe version type in pipe_config from integer to enum
+v2.1.14.4 (5 changes parallel), new API getter functions for gdc in buffer information
+- ia_css_pipe_get_dvs_filter() added
+- ia_css_pipe_get_gdc_in_buffer_info() added
+
+v2.1.14.5 (8 changes parallel), Update CNR2 ineffective values
+- Fixed Incorrect ineffective values listed in ia_css_cnr_config
+- Correct Ineffective value is 8191
+
+v2.1.14.5 (8 changes parallel), af_roi_api
+- added a new function to set AF ROI ia_css_set_af_roi
+- added a new struct ia_css_s3a_roi_offset
+
+v2.1.14.5 (8 changes parallel), remove x_y_end_from_ae_and_awb
+- added a flag to prepare removal of x_end and y_end from ae grid public config
+- added a flag to prepare removal of x_end and y_end from awb grid public config
 
-v2.1.10.5 (2 changes parallel), Added public interface for setting the scaler LUT.
+v2.1.14.5 (4 changes parallel), Added public interface for setting the scaler LUT.
 - Added the public struct to output system and modified the global config struct.
 
-v2.1.10.6 (6 changes parallel), add_flag_to_disable_continous_viewfinder
+v2.1.14.6 (8 changes parallel), add_flag_to_disable_continous_viewfinder
 - add a new flag in stream_config to disable continuous viewfinder
 - in ZSL use case.
 
-v2.1.11.0 (2 changes parallel), Stop Support for Skycam B0
-- Remove a few pre-processor defines for Skycam B0/C0 as support
-
-v2.1.11.2 (3 changes parallel), Enlarge AF AWB_FR stats buffers
+v2.1.14.6 (8 changes parallel), Enlarge AF AWB_FR stats buffers
 - Enlarge AF and AWB_FR stats buffers to support max grid width per stripe as oppose to per frame
 
-v2.1.11.2 (2 changes parallel), new API getter functions for gdc in buffer information
-- ia_css_pipe_get_dvs_filter() added
-- ia_css_pipe_get_gdc_in_buffer_info() added
+v2.1.14.7 (5 changes parallel), pipe config option for vf output bci mode downscaling
+- vf downscaling using yuv_scale binary.
+
+v2.1.14.9 (6 changes parallel), Add scale mode GDC V2 LUT to CSS API
+- Allow client to set global LUT for gdc v2 (First step in this change. See wiki page for more details)
+
+v2.1.14.9 (7 changes parallel), Include added to type-support.h.
+- Include of hive/cell_support.h was added to type-support.h, in order to
+- have access to define HAVE_STDINT.
+
+v2.1.14.10 (6 changes parallel), Pipe configuration to enable BLI mode downscaling for
+- BLI mode downscaling for capture post-processing
+
+v2.1.14.13 (8 changes parallel), Fix copyright headers (no functional change)
+- No functional change; only fixes copyright headers
+
+v2.1.14.13 (5 changes parallel), Remove continuous mode special case handling in ia_css_pipe_set_isp_config
+- For continuous mode isp_config was being send to all pipes,
+- even though API ia_css_pipe_set_isp_config is for single pipe
+- Removed incorrect case
+
+v2.1.14.13 (5 changes parallel), DVS statistics grid produced by accelerator
+- Add DVS statistics produced by accelerator grid to pipe info
+- Add ia_css_pipe_has_dvs_stats function
+
+v2.1.14.14 (6 changes parallel), cont_remove_x_y_end_from_ae_and_awb
+- this patch doesn't introduce any new api change, it only fixes a recent
+- api merged change (#31938) , in order to have success CI i had to upload an api change request
+
+v2.1.14.15 (4 changes parallel), Add XNR3 blending strength to kernel interface
+- Added a blending strength field to the XNR3 kernel interface to add
+- support for blending.
+
+v2.1.14.17 (21 changes parallel), eliminate two_pixels_per_clock field
+- remove obsolete field two_pixels_per_clock
+
+v2.1.14.18 (2 changes parallel), Fix copyright headers (no functional change)
+- No functional change; only fixes copyright headers
 
 */
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/gdc.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/gdc.c
index 288de8c..7567351 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/gdc.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/gdc.c
@@ -66,6 +66,39 @@ void gdc_lut_store(
 return;
 }
 
+/*
+ * Input LUT format:
+ * c0[0-1023], c1[0-1023], c2[0-1023] c3[0-1023]
+ *
+ * Output LUT format (interleaved):
+ * c0[0], c1[0], c2[0], c3[0], c0[1], c1[1], c2[1], c3[1], ....
+ * c0[1023], c1[1023], c2[1023], c3[1023]
+ *
+ * The first format needs c0[0], c1[0] (which are 1024 words apart)
+ * to program gdc LUT registers. This makes it difficult to do piecemeal
+ * reads in SP side gdc_lut_store
+ *
+ * Interleaved format allows use of contiguous bytes to store into
+ * gdc LUT registers.
+ *
+ * See gdc_lut_store() definition in host/gdc.c vs sp/gdc_private.h
+ *
+ */
+void gdc_lut_convert_to_isp_format(const int in_lut[4][HRT_GDC_N],
+	int out_lut[4][HRT_GDC_N])
+{
+	unsigned int i;
+	int *out = (int *)out_lut;
+
+	for (i = 0; i < HRT_GDC_N; i++) {
+		out[0] = in_lut[0][i];
+		out[1] = in_lut[1][i];
+		out[2] = in_lut[2][i];
+		out[3] = in_lut[3][i];
+		out += 4;
+	}
+}
+
 int gdc_get_unity(
 	const gdc_ID_t		ID)
 {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/system_local.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/system_local.h
index 85f0424..baaef3d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/system_local.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2400_system/host/system_local.h
@@ -28,6 +28,8 @@
 #ifdef __FIST__
 #define HRT_ADDRESS_WIDTH	32		/* Surprise, this is a local property and even differs per platform */
 #else
+/* HRT assumes 32 by default (see Linux/include/hrt/hive_types.h), overrule it in case it is different */
+#undef HRT_ADDRESS_WIDTH
 #define HRT_ADDRESS_WIDTH	64		/* Surprise, this is a local property */
 #endif
 
@@ -85,6 +87,9 @@ static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
 static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
 	(hrt_address)0x0000000000300000ULL};
 
+static const hrt_address SP_PMEM_BASE[N_SP_ID] = {
+	(hrt_address)0x00000000000B0000ULL};
+
 /* MMU */
 #if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
 /*
@@ -204,6 +209,9 @@ static const hrt_address SP_CTRL_BASE[N_SP_ID] = {
 static const hrt_address SP_DMEM_BASE[N_SP_ID] = {
 	(hrt_address)0x00300000UL};
 
+static const hrt_address SP_PMEM_BASE[N_SP_ID] = {
+	(hrt_address)0x000B0000UL};
+
 /* MMU */
 #if defined (IS_ISP_2400_MAMOIADA_SYSTEM) || defined (IS_ISP_2401_MAMOIADA_SYSTEM)
 /*
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_states.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_states.h
index 570754c..d658a00 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_states.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_2401_system_csi2p_generated/ia_css_isp_states.h
@@ -22,6 +22,9 @@
 #include "isp/kernels/ref/ref_1.0/ia_css_ref.host.h"
 #include "isp/kernels/tnr/tnr_1.0/ia_css_tnr.host.h"
 #include "isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.h"
+#include "isp/kernels/iefd2_6/ia_css_iefd2_6.host.h"
+#include "isp/kernels/dpc2/ia_css_dpc2.host.h"
+#include "isp/kernels/eed1_8/ia_css_eed1_8.host.h"
 /* Generated code: do not edit or commmit. */
 
 #ifndef _IA_CSS_ISP_STATE_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/gdc_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/gdc_public.h
index 80ffda4..d27f87a 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/gdc_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/gdc_public.h
@@ -37,6 +37,16 @@ STORAGE_CLASS_EXTERN void gdc_lut_store(
 	const gdc_ID_t		ID,
 	const int			data[4][HRT_GDC_N]);
 
+/*! Convert the bicubic interpolation table of GDC[ID] to the ISP-specific format
+
+ \param	ID[in]				GDC identifier
+ \param in_lut[in]			The data matrix to be converted
+ \param out_lut[out]			The data matrix as the output of conversion
+ */
+STORAGE_CLASS_EXTERN void gdc_lut_convert_to_isp_format(
+	const int in_lut[4][HRT_GDC_N],
+	int out_lut[4][HRT_GDC_N]);
+
 /*! Return the integer representation of 1.0 of GDC[ID]
  
  \param	ID[in]				GDC identifier
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_irq_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_irq_public.h
index 258bc73..c3e6f76 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_irq_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_irq_public.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __ISYS_IRQ_PUBLIC_H__
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_stream2mmio_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_stream2mmio_public.h
index d8ef806..5624cfc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_stream2mmio_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/isys_stream2mmio_public.h
@@ -41,7 +41,7 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_state(
  */
 STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_sid_state(
 		const stream2mmio_ID_t ID,
-		const uint32_t sid_id,
+		const stream2mmio_sid_ID_t sid_id,
 		stream2mmio_sid_state_t *state);
 /** end of NCI */
 
@@ -61,9 +61,9 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_get_sid_state(
  * @return the value of the register.
  */
 STORAGE_CLASS_STREAM2MMIO_H hrt_data stream2mmio_reg_load(
-	const stream2mmio_ID_t ID,
-	const uint32_t sid_id,
-	const uint32_t reg_idx);
+		const stream2mmio_ID_t ID,
+		const stream2mmio_sid_ID_t sid_id,
+		const uint32_t reg_idx);
 
 /**
  * @brief Dump the SID processor state.
@@ -93,9 +93,9 @@ STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_dump_state(
  *
  */
 STORAGE_CLASS_STREAM2MMIO_H void stream2mmio_reg_store(
-	const stream2mmio_ID_t ID,
-	const hrt_address reg,
-	const hrt_data value);
+		const stream2mmio_ID_t ID,
+		const hrt_address reg,
+		const hrt_data value);
 /** end of DLI */
 
 #endif /* __ISYS_STREAM2MMIO_PUBLIC_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func.h
index 8e8fcac..605d309 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func.h
@@ -1,28 +1,17 @@
 /*
- * INTEL CONFIDENTIAL
- *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
- *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
-
 #ifndef _REF_VECTOR_FUNC_H_INCLUDED_
 #define _REF_VECTOR_FUNC_H_INCLUDED_
 
@@ -173,6 +162,25 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H  tvector1w OP_1w_XCU(
 	xcu_ref_init_vectors init_vectors);
 
 
+/** @brief LXCU
+ *
+ * @param[in] x 		input
+ * @param[in] init_vectors 	LUT data structure
+ *
+ * @return   logarithmic piecewise linear estimated output.
+ * This block gets an input x and a set of input configuration points stored in a look-up
+ * table of 32 elements. It computes the interval in which the input lies.
+ * Then output is computed by performing linear interpolation based on the interval
+ * properties (i.e. x_prev, slope, * and offset).
+ * This BBB assumes spacing x-coordinates of "init vectors" increase exponentially as
+ * shown below.
+ * interval size :   2^0    2^1      2^2    2^3
+ * x-coordinates: x0<--->x1<---->x2<---->x3<---->
+ **/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_LXCU(
+	tvector1w x,
+	xcu_ref_init_vectors init_vectors);
+
 /** @brief Coring
  *
  * @param[in] coring_vec   Amount of coring based on brightness level
@@ -288,7 +296,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x3m_6dB_nrm_ph3 (
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x3m_6dB_nrm_calc_coeff (
 	const s_1w_1x3_matrix		m, tscalar1w_3bit coeff);
 
-/** @brief 3 tab FIR with coefficients [1,1,1]
+/** @brief 3 tap FIR with coefficients [1,1,1]
  *
  * @param[in] m	1x3 matrix with pixels
  *
@@ -472,15 +480,15 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x9m_box (
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w fir1x11m_box (
 	s_1w_1x11_matrix m);
 
-/** @brief Symmetric 7 tab filter with normalization
+/** @brief Symmetric 7 tap filter with normalization
  *
  *  @param[in] in 1x7 matrix with pixels
  *  @param[in] coeff 1x4 matrix with coefficients
  *  @param[in] out_shift output pixel shift value for normalization
  *
- *  @return symmetric 7 tab filter output
+ *  @return symmetric 7 tap filter output
  *
- * This function performs symmetric 7 tab filter over input pixels.
+ * This function performs symmetric 7 tap filter over input pixels.
  * Filter sum is normalized by shifting out_shift bits.
  * Filter sum: p0*c3 + p1*c2 + p2*c1 + p3*c0 + p4*c1 + p5*c2 + p6*c3
  * is implemented as: (p0 + p6)*c3 + (p1 + p5)*c2 + (p2 + p4)*c1 + p3*c0 to
@@ -493,23 +501,48 @@ fir1x7m_sym_nrm(s_1w_1x7_matrix in,
 		s_1w_1x4_matrix coeff,
 		tvector1w out_shift);
 
-/** @brief approximation for Symmetric 4 tap filter(-1,9,9,-1) with normalization
+/** @brief Symmetric 7 tap filter with normalization at input side
  *
- *  @param[in] in 1x4 matrix with pixels
+ *  @param[in] in 1x7 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
  *
- *  @return 4 tap filter output
+ *  @return symmetric 7 tap filter output
  *
- * this function is used by xnr4 upscale2
+ * This function performs symmetric 7 tap filter over input pixels.
+ * Filter sum: p0*c3 + p1*c2 + p2*c1 + p3*c0 + p4*c1 + p5*c2 + p6*c3
+ *          = (p0 + p6)*c3 + (p1 + p5)*c2 + (p2 + p4)*c1 + p3*c0
+ * Input pixels and coefficients are in Qn format, where n =
+ * ISP_VEC_ELEMBITS - 1 (ie Q15 for Broxton)
+ * To avoid double precision arithmetic input pixel sum and final sum is
+ * implemented using avgrnd and coefficient multiplication using qrmul.
+ * Final result is in Qm format where m = ISP_VEC_ELEMBITS - 2 (ie Q14 for
+ * Broxton)
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x7m_sym_innrm_approx(s_1w_1x7_matrix in,
+			 s_1w_1x4_matrix coeff);
+
+/** @brief Symmetric 7 tap filter with normalization at output side
  *
- * This function performs 4 tap filter over input pixels.
- * Filter sum is normalized by shifting out_shift bits.
- * Filter sum: p0*c0 + p1*c1 + p2*c2 + p3*c3
- * The coeeficients are -1, 9, 9, -1 with shift of 4
- * The below implementation is the approximation that consumes less cycles.
+ *  @param[in] in 1x7 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
+ *
+ *  @return symmetric 7 tap filter output
  *
+ * This function performs symmetric 7 tap filter over input pixels.
+ * Filter sum: p0*c3 + p1*c2 + p2*c1 + p3*c0 + p4*c1 + p5*c2 + p6*c3
+ *          = (p0 + p6)*c3 + (p1 + p5)*c2 + (p2 + p4)*c1 + p3*c0
+ * Input pixels are in Qn and coefficients are in Qm format, where n =
+ * ISP_VEC_ELEMBITS - 2 and m = ISP_VEC_ELEMBITS - 1 (ie Q14 and Q15
+ * respectively for Broxton)
+ * To avoid double precision arithmetic input pixel sum and final sum is
+ * implemented using addsat and coefficient multiplication using qrmul.
+ * Final sum is left shifted by 2 and saturated to produce result is Qm format
+ * (ie Q15 for Broxton)
 */
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
-fir1x4m_sym_nrm_minus1_9_9_minus1_appr(s_1w_1x4_matrix in);
+fir1x7m_sym_outnrm_approx(s_1w_1x7_matrix in,
+			 s_1w_1x4_matrix coeff);
 
 /** @brief 4 tap filter with normalization
  *
@@ -528,15 +561,53 @@ fir1x4m_nrm(s_1w_1x4_matrix in,
 		s_1w_1x4_matrix coeff,
 		tvector1w out_shift);
 
-/** @brief Symmetric 3 tab filter with normalization
+/** @brief 4 tap filter with normalization for half pixel interpolation
+ *
+ *  @param[in] in 1x4 matrix with pixels
+ *
+ *  @return 4 tap filter output with filter tap [-1 9 9 -1]/16
+ *
+ * This function performs 4 tap filter over input pixels.
+ * Filter sum: -p0 + 9*p1 + 9*p2 - p3
+ * This filter implementation is completely free from multiplication and double
+ * precision arithmetic.
+ * Typical usage of this filter is to half pixel interpolation of Bezier
+ * surface
+ * */
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x4m_bicubic_bezier_half(s_1w_1x4_matrix in);
+
+/** @brief 4 tap filter with normalization for quarter pixel interpolation
+ *
+ *  @param[in] in 1x4 matrix with pixels
+ *  @param[in] coeff 1x4 matrix with coefficients
+ *
+ *  @return 4 tap filter output
+ *
+ * This function performs 4 tap filter over input pixels.
+ * Filter sum: p0*c0 + p1*c1 + p2*c2 + p3*c3
+ * To avoid double precision arithmetic we implemented multiplication using
+ * qrmul and addition using avgrnd. Coefficients( c0 to c3) formats are assumed
+ * to be: Qm, Qn, Qo, Qm, where m = n + 2 and o = n + 1.
+ * Typical usage of this filter is to quarter pixel interpolation of Bezier
+ * surface with filter coefficients:[-9 111 29 -3]/128. For which coefficient
+ * values should be: [-9216/2^17  28416/2^15  1484/2^16 -3072/2^17] for
+ * ISP_VEC_ELEMBITS = 16.
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+fir1x4m_bicubic_bezier_quarter(s_1w_1x4_matrix in,
+			s_1w_1x4_matrix coeff);
+
+
+/** @brief Symmetric 3 tap filter with normalization
  *
  *  @param[in] in 1x3 matrix with pixels
  *  @param[in] coeff 1x2 matrix with coefficients
  *  @param[in] out_shift output pixel shift value for normalization
  *
- *  @return symmetric 3 tab filter output
+ *  @return symmetric 3 tap filter output
  *
- * This function performs symmetric 3 tab filter input pixels.
+ * This function performs symmetric 3 tap filter input pixels.
  * Filter sum is normalized by shifting out_shift bits.
  * Filter sum: p0*c1 + p1*c0 + p2*c1
  * is implemented as: (p0 + p2)*c1 + p1*c0 to reduce multiplication.
@@ -548,30 +619,25 @@ fir1x3m_sym_nrm(s_1w_1x3_matrix in,
 		s_1w_1x2_matrix coeff,
 		tvector1w out_shift);
 
-/** @brief Absolute gradient between two sets of 1x5 yuv matrices
+/** @brief Symmetric 3 tap filter with normalization
  *
- *  @param[in] in0_y	1x5 matrix with y components of the first set of pixels
- *  @param[in] in0_u	1x5 matrix with u components of the first set of pixels
- *  @param[in] in0_v	1x5 matrix with v components of the first set of pixels
- *  @param[in] in1_y	1x5 matrix with y components of the second set of pixels
- *  @param[in] in1_u	1x5 matrix with u components of the second set of pixels
- *  @param[in] in1_v	1x5 matrix with v components of the second set of pixels
+ *  @param[in] in 1x3 matrix with pixels
+ *  @param[in] coeff 1x2 matrix with coefficients
  *
- *  @return absolute gradient
+ *  @return symmetric 3 tap filter output
  *
- * This function finds the absolute gradient between two sets of 1x5 YUV
- * vectors, that is basically |(Y1+U1+V1) - (Y2+U2+V2)|. Since addition
- * and subtraction operations could overflow, "avgrnd" is used instead of
- * "add" and "subhalfrnd" is used instead of "sub". Thus, all intermediate
- * results are rounded.
- */
+ * This function performs symmetric 3 tap filter over input pixels.
+ * Filter sum: p0*c1 + p1*c0 + p2*c1 = (p0 + p2)*c1 + p1*c0
+ * Input pixels are in Qn and coefficient c0 is in Qm and c1 is in Qn format,
+ * where n = ISP_VEC_ELEMBITS - 1 and m = ISP_VEC_ELEMBITS - 2 ( ie Q15 and Q14
+ * respectively for Broxton)
+ * To avoid double precision arithmetic input pixel sum is implemented using
+ * avgrnd, coefficient multiplication using qrmul and final sum using addsat
+ * Final sum is Qm format (ie Q14 for Broxton)
+*/
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
-gradabs1x5_yuv(s_1w_1x5_matrix in0_y,
-	    s_1w_1x5_matrix in0_u,
-	    s_1w_1x5_matrix in0_v,
-	    s_1w_1x5_matrix in1_y,
-	    s_1w_1x5_matrix in1_u,
-	    s_1w_1x5_matrix in1_v);
+fir1x3m_sym_nrm_approx(s_1w_1x3_matrix in,
+		       s_1w_1x2_matrix coeff);
 
 /** @brief Mean of 1x3 matrix
  *
@@ -631,6 +697,17 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w mean4x4m(
 STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w mean2x3m(
 	s_1w_2x3_matrix m);
 
+/** @brief Mean of 1x5 matrix
+ *
+ *  @param[in] m 1x5 matrix with pixels
+ *
+ *  @return mean of 1x5 matrix
+ *
+ * This function calculates the mean of 1x5 matrix with pixels
+ * with a factor of 8/5.
+*/
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w mean1x5m(s_1w_1x5_matrix m);
+
 /** @brief Mean of 1x6 matrix
  *
  *  @param[in] m 1x6 matrix with pixels
@@ -743,6 +820,19 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w sad5x5m(
 	s_1w_5x5_matrix a,
 	s_1w_5x5_matrix b);
 
+/** @brief Absolute gradient between two sets of 1x5 matrices
+ *
+ *  @param[in] m0 first set of 1x5 matrix with pixels
+ *  @param[in] m1 second set of 1x5 matrix with pixels
+ *
+ *  @return absolute gradient between two 1x5 matrices
+ *
+ * This function computes mean of two input 1x5 matrices and returns
+ * absolute difference between two mean values.
+ */
+STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w
+absgrad1x5m(s_1w_1x5_matrix m0, s_1w_1x5_matrix m1);
+
 /** @brief Bi-linear Interpolation optimized(approximate)
  *
  * @param[in] a input0
@@ -927,10 +1017,10 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H bma_output_14_2 OP_1w_asp_bma_14_2_32way(
  * @param[in] central_pix - central pixel plane
  * @param[in] src_plane - src pixel plane
  *
- * @return   Bilateral filter output pixel
+ * @return   Bilateral filter output
  *
  * This function implements, 7x7 single bilateral filter.
- * Output = sum(pixel * weight) / sum(weight)
+ * Output = {sum(pixel * weight), sum(weight)}
  * Where sum is summation over 7x7 block set.
  * weight = spatial weight * range weight
  * spatial weights are loaded from spatial_weight_lut depending on src pixel
@@ -942,7 +1032,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H bma_output_14_2 OP_1w_asp_bma_14_2_32way(
  * Piecewise linear approximation technique is used to compute range weight
  * It computes absolute difference between central pixel and 61 src pixels.
  */
-STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_single_bfa_7x7(
+STORAGE_CLASS_REF_VECTOR_FUNC_H bfa_7x7_output OP_1w_single_bfa_7x7(
 	bfa_weights weights,
 	tvector1w threshold,
 	tvector1w central_pix,
@@ -958,10 +1048,10 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_single_bfa_7x7(
  * @param[in] central_pix1 - 2nd central pixel plane
  * @param[in] src1_plane - 2nd pixel plane
  *
- * @return   Joint bilateral filter output pixel
+ * @return   Joint bilateral filter output
  *
  * This function implements, 7x7 joint bilateral filter.
- * Output = sum(pixel * weight) / sum(weight)
+ * Output = {sum(pixel * weight), sum(weight)}
  * Where sum is summation over 7x7 block set.
  * weight = spatial weight * range weight
  * spatial weights are loaded from spatial_weight_lut depending on src pixel
@@ -973,7 +1063,7 @@ STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_single_bfa_7x7(
  * Piecewise linear approximation technique is used to compute range weight
  * It computes absolute difference between central pixel and 61 src pixels.
  */
-STORAGE_CLASS_REF_VECTOR_FUNC_H tvector1w OP_1w_joint_bfa_7x7(
+STORAGE_CLASS_REF_VECTOR_FUNC_H bfa_7x7_output OP_1w_joint_bfa_7x7(
 	bfa_weights weights,
 	tvector1w threshold0,
 	tvector1w central_pix0,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func_types.h
index 69037ef..e4e19f9 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/host/ref_vector_func_types.h
@@ -1,28 +1,17 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
-
 #ifndef __REF_VECTOR_FUNC_TYPES_H_INCLUDED__
 #define __REF_VECTOR_FUNC_TYPES_H_INCLUDED__
 
@@ -43,6 +32,7 @@
 #define OUTPUT_SCALE_FACTOR 10
 #define SLOPE_A_RESOLUTION 10
 #define CONFIG_UNIT_LUT_SIZE_32 32 /*XCU works for ISP_NWAY = 32 */
+#define LXCU_LUT_SIZE      16
 
 #define ONE_IN_Q14 (1<<(NUM_BITS-2))
 #define Q29_TO_Q15_SHIFT_VAL (NUM_BITS-2)
@@ -92,28 +82,46 @@ typedef struct {
   tvector1w     v1 ;
 } s_1w_2x1_matrix;
 
+#define S_1W_2X1_MATRIX_DEFAULT ((s_1w_2x1_matrix)\
+	{ 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
 } s_1w_1x2_matrix;
 
+#define S_1W_1X2_MATRIX_DEFAULT ((s_1w_1x2_matrix)\
+	{ 0, 0 })
+
 typedef struct {
   tvector1w     v00  ;
   tvector1w     v01 ;
   tvector1w     v02 ;
 } s_1w_1x3_matrix;
 
+#define S_1W_1X3_MATRIX_DEFAULT ((s_1w_1x3_matrix)\
+	{ 0, 0, 0, })
+
 typedef struct {
   tvector1w v00; tvector1w v01; tvector1w v02;
   tvector1w v10; tvector1w v11; tvector1w v12;
 } s_1w_2x3_matrix;
 
+#define S_1W_2X3_MATRIX_DEFAULT ((s_1w_2x3_matrix)\
+	{ 0, 0, 0, \
+	  0, 0, 0 })
+
 typedef struct {
   tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ;
   tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ;
   tvector1w     v20  ; tvector1w     v21 ; tvector1w     v22  ;
 } s_1w_3x3_matrix;
 
+#define S_1W_3X3_MATRIX_DEFAULT ((s_1w_3x3_matrix)\
+	{ 0, 0, 0, \
+	  0, 0, 0, \
+	  0, 0, 0 })
+
 typedef struct {
   tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ;
   tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ;
@@ -121,6 +129,12 @@ typedef struct {
   tvector1w     v30  ; tvector1w     v31 ; tvector1w     v32  ;
 } s_1w_4x3_matrix;
 
+#define S_1W_4X3_MATRIX_DEFAULT ((s_1w_4x3_matrix)\
+	{ 0, 0, 0, \
+	  0, 0, 0, \
+	  0, 0, 0, \
+	  0, 0, 0 })
+
 typedef struct {
   tvector1w     v00 ;
   tvector1w     v01 ;
@@ -129,6 +143,9 @@ typedef struct {
   tvector1w     v04 ;
 } s_1w_1x5_matrix;
 
+#define S_1W_1X5_MATRIX_DEFAULT ((s_1w_1x5_matrix)\
+	{ 0, 0, 0, 0, 0 })
+
 typedef struct {
   tvector1w     v00  ; tvector1w     v01 ; tvector1w     v02  ; tvector1w     v03 ; tvector1w     v04  ;
   tvector1w     v10  ; tvector1w     v11 ; tvector1w     v12  ; tvector1w     v13 ; tvector1w     v14  ;
@@ -137,6 +154,13 @@ typedef struct {
   tvector1w     v40  ; tvector1w     v41 ; tvector1w     v42  ; tvector1w     v43 ; tvector1w     v44  ;
 } s_1w_5x5_matrix;
 
+#define S_1W_5X5_MATRIX_DEFAULT ((s_1w_5x5_matrix)\
+	{ 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0 })
+	
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -147,6 +171,9 @@ typedef struct {
 	tvector1w v06;
 } s_1w_1x7_matrix;
 
+#define S_1W_1X7_MATRIX_DEFAULT ((s_1w_1x7_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -159,6 +186,9 @@ typedef struct {
 	tvector1w v08;
 } s_1w_1x9_matrix;
 
+#define S_1W_1X9_MATRIX_DEFAULT ((s_1w_1x9_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -166,6 +196,9 @@ typedef struct {
 	tvector1w v03;
 } s_1w_1x4_matrix;
 
+#define S_1W_1X4_MATRIX ((s_1w_1x4_matrix)\
+	{ 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03;
 	tvector1w v10; tvector1w v11; tvector1w v12; tvector1w v13;
@@ -173,6 +206,12 @@ typedef struct {
 	tvector1w v30; tvector1w v31; tvector1w v32; tvector1w v33;
 } s_1w_4x4_matrix;
 
+#define S_1W_4X4_MATRIX_DEFAULT ((s_1w_4x4_matrix)\
+	{ 0, 0, 0, 0, \
+	  0, 0, 0, 0, \
+	  0, 0, 0, 0, \
+	  0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00;
 	tvector1w v01;
@@ -182,6 +221,9 @@ typedef struct {
 	tvector1w v05;
 } s_1w_1x6_matrix;
 
+#define S_1W_1X6_MATRIX_DEFAULT ((s_1w_1x6_matrix)\
+	{ 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03; tvector1w v04; tvector1w v05;
 	tvector1w v10; tvector1w v11; tvector1w v12; tvector1w v13; tvector1w v14; tvector1w v15;
@@ -191,6 +233,14 @@ typedef struct {
 	tvector1w v50; tvector1w v51; tvector1w v52; tvector1w v53; tvector1w v54; tvector1w v55;
 } s_1w_6x6_matrix;
 
+#define S_1W_6X6_MATRIX_DEFAULT ((s_1w_6x6_matrix)\
+	{ 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03; tvector1w v04;
 	tvector1w v05; tvector1w v06; tvector1w v07; tvector1w v08;
@@ -212,6 +262,17 @@ typedef struct {
 	tvector1w v85; tvector1w v86; tvector1w v87; tvector1w v88;
 } s_1w_9x9_matrix;
 
+#define S_1W_9X9_MATRIX_DEFAULT ((s_1w_9x9_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v00; tvector1w v01; tvector1w v02; tvector1w v03; tvector1w v04;
 	tvector1w v05; tvector1w v06;
@@ -229,6 +290,15 @@ typedef struct {
 	tvector1w v65; tvector1w v66;
 } s_1w_7x7_matrix;
 
+#define S_1W_7X7_MATRIX_DEFAULT ((s_1w_7x7_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0, \
+	  0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w v0_0;
 	tvector1w v0_1;
@@ -243,6 +313,9 @@ typedef struct {
 	tvector1w v0_10;
 } s_1w_1x11_matrix;
 
+#define S_1W_1X11_MATRIX_DEFAULT ((s_1w_1x11_matrix)\
+	{ 0, 0, 0, 0, 0, 0, 0, 0, 0 })
+
 typedef struct {
 	tvector1w x_cord[MAX_CONFIG_POINTS];
 	tvector1w slope[MAX_CONFIG_POINTS-1];
@@ -291,4 +364,9 @@ typedef struct {
 	tvector1w range_weight_lut[BFA_RW_LUT_SIZE];
 } bfa_weights;
 
+/* Return type for BFA BBBs */
+typedef struct {
+	tvector2w sop; /* weighted sum of pixels */
+	tvector1w sow; /* sum of weights */
+} bfa_7x7_output;
 #endif /* __REF_VECTOR_FUNC_TYPES_H_INCLUDED__ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/isys_irq.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/isys_irq.h
index c43c1d1..cf858bc 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/isys_irq.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/isys_irq.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_ISYS_IRQ_H__
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/math_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/math_support.h
index e96a6f7..5f85dc3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/math_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/math_support.h
@@ -62,6 +62,16 @@
 #define CEIL_SHIFT(a, b)     (((a) + (1 << (b)) - 1)>>(b))
 #define CEIL_SHIFT_MUL(a, b) (CEIL_SHIFT(a, b) << (b))
 
+
+/*To Find next power of 2 number from x */
+#define bit2(x)            ((x)      | ((x) >> 1))
+#define bit4(x)            (bit2(x)  | (bit2(x) >> 2))
+#define bit8(x)            (bit4(x)  | (bit4(x) >> 4))
+#define bit16(x)           (bit8(x)  | (bit8(x) >> 8))
+#define bit32(x)           (bit16(x) | (bit16(x) >> 16))
+#define NEXT_POWER_OF_2(x) (bit32(x-1) + 1)
+
+
 /* min and max should not be macros as they will evaluate their arguments twice.
    if you really need a macro (e.g. for CPP or for initializing an array)
    use MIN() and MAX(), otherwise use min() and max().
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h
index 6ba419a..1f991bb 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/type_support.h
@@ -50,6 +50,9 @@
 #endif
 
 #elif defined(__HIVECC)
+#ifndef PIPE_GENERATION
+#include <hive/cell_support.h> /* for HAVE_STDINT */
+#endif
 #define __INDIRECT_STDINT_INCLUDE
 #include <stdint/stdint.h>
 #include <stdbool.h>
@@ -67,7 +70,9 @@
 #define HOST_ADDRESS(x) (unsigned long)(x)
 
 #elif defined(__GNUC__)
+#ifndef __STDC_LIMIT_MACROS
 #define __STDC_LIMIT_MACROS 1
+#endif
 #include <stdint.h>
 #include <stdbool.h>
 #include <stddef.h>
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/vector_ops.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/vector_ops.h
index 898098e..261f873 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/vector_ops.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/hive_isp_css_include/vector_ops.h
@@ -21,7 +21,7 @@
 
 #ifndef __INLINE_VECTOR_OPS__
 #define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_EXTERN
-#define STORAGE_CLASS_VECTOR_OPS_C 
+#define STORAGE_CLASS_VECTOR_OPS_C
 #include "vector_ops_public.h"
 #else  /* __INLINE_VECTOR_OPS__ */
 #define STORAGE_CLASS_VECTOR_OPS_H STORAGE_CLASS_INLINE
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h
index 712964d..93d96d4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h
index d503758..1da741b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_acc_types.h
@@ -57,6 +57,7 @@ enum ia_css_fw_type {
 	ia_css_sp1_firmware,	/**< Firmware for the SP1 */
 #endif
 	ia_css_isp_firmware,	/**< Firmware for the ISP */
+	ia_css_bootloader_firmware, /**< Firmware for the BootLoader */
 	ia_css_acc_firmware		/**< Firmware for accelrations */
 };
 
@@ -314,6 +315,18 @@ struct ia_css_binary_xinfo {
 	CSS_ALIGN(struct ia_css_binary_xinfo *next, 8);
 };
 
+/** Structure describing the Bootloader (an ISP binary).
+ * It contains several address, either in ddr, isp_dmem or
+ * the entry function in icache.
+ */
+struct ia_css_bl_info {
+	uint32_t num_dma_cmds;	/**< Number of cmds sent by CSS */
+	uint32_t dma_cmd_list;	/**< Dma command list sent by CSS */
+	uint32_t sw_state;	/**< Polled from css */
+	/* Entry functions */
+	uint32_t bl_entry;	/**< The SP entry function */
+};
+
 /** Structure describing the SP binary.
  * It contains several address, either in ddr, sp_dmem or
  * the entry function in pmem.
@@ -371,6 +384,7 @@ union ia_css_fw_union {
 #if defined(IS_ISP_2500_SYSTEM)
 	struct ia_css_sp_info		sp1;  /**< SP1 info */
 #endif
+	struct ia_css_bl_info           bl;  /**< Bootloader info */
 	struct ia_css_acc_info		acc; /**< Accelerator info */
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h
index 0956d94..572e4e5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_err.h
@@ -41,23 +41,6 @@ enum ia_css_err {
 	IA_CSS_ERR_NOT_SUPPORTED
 };
 
-/** Unrecoverable FW errors. This enum contains a value for each
- * error that the SP FW could encounter.
- */
-enum ia_css_fw_err {
-	IA_CSS_FW_SUCCESS,
-	IA_CSS_FW_ERR_TAGGER_FULL,
-	IA_CSS_FW_ERR_NO_VBUF_HANDLE,
-	IA_CSS_FW_ERR_BUFFER_QUEUE_FULL,
-	IA_CSS_FW_ERR_INVALID_QUEUE,
-	IA_CSS_FW_ERR_INVALID_DMA_CHANNEL,
-	IA_CSS_FW_ERR_CIRCBUF_EMPTY,
-	IA_CSS_FW_ERR_CIRCBUF_FULL,
-	IA_CSS_FW_ERR_TOKEN_MAP_RECEIVE,
-	IA_CSS_FW_ERR_INVALID_PORT,
-	IA_CSS_FW_ERR_OUT_OF_SP_DMEM,
-};
-
 /** FW warnings. This enum contains a value for each warning that
  * the SP FW could indicate potential performance issue
  */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_event_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_event_public.h
index ae3bfbf..fb02799 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_event_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_event_public.h
@@ -63,18 +63,16 @@ enum ia_css_event_type {
              32-bit timer value from the SP */
 	IA_CSS_EVENT_TYPE_PORT_EOF			= 1 << 13,
 	/**< End Of Frame event, sent when in buffered sensor mode. */
-	IA_CSS_EVENT_TYPE_FW_ERROR			= 1 << 14,
-	/**< @deprecated{Unrecoverable error encounter by FW } */
-	IA_CSS_EVENT_TYPE_FW_WARNING			= 1 << 15,
+	IA_CSS_EVENT_TYPE_FW_WARNING			= 1 << 14,
 	/**< Performance warning encounter by FW */
-	IA_CSS_EVENT_TYPE_FW_ASSERT			= 1 << 16,
+	IA_CSS_EVENT_TYPE_FW_ASSERT			= 1 << 15,
 	/**< Assertion hit by FW */
 };
 
 #define IA_CSS_EVENT_TYPE_NONE 0
 
 /** IA_CSS_EVENT_TYPE_ALL is a mask for all pipe related events.
- * The other events (such as PORT_EOF and FW_ERROR) cannot be enabled/disabled
+ * The other events (such as PORT_EOF) cannot be enabled/disabled
  * and are hence excluded from this macro.
  */
 #define IA_CSS_EVENT_TYPE_ALL \
@@ -124,8 +122,6 @@ struct ia_css_event {
 	uint32_t               fw_handle;
 	/**< Firmware Handle for ACC_STAGE_COMPLETE event (not valid for other
 	     events). */
-	enum ia_css_fw_err     fw_error;
-	/**< @deprecated{This field is deprecated since ERROR events are no longer sent and will be removed. } */
 	enum ia_css_fw_warning fw_warning;
 	/**< Firmware warning code, only for WARNING events. */
 	uint8_t                fw_assert_module_id;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h
index d28e15d..9d33f38 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_host_data.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe.h
index 9c62f91..a05fd0d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe.h
@@ -56,6 +56,7 @@ struct ia_css_capture_settings {
 	struct ia_css_binary post_isp_binary;
 	struct ia_css_binary capture_pp_binary;
 	struct ia_css_binary vf_pp_binary;
+	struct ia_css_binary capture_ldc_binary;
 	struct ia_css_binary *yuv_scaler_binary;
 	struct ia_css_frame *delay_frames[MAX_NUM_VIDEO_DELAY_FRAMES];
 	bool *is_output_stage;
@@ -72,6 +73,7 @@ struct ia_css_capture_settings {
 	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* post_isp_binary */\
 	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* capture_pp_binary */\
 	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* vf_pp_binary */\
+	IA_CSS_BINARY_DEFAULT_SETTINGS,	/* capture_ldc_binary */\
 	NULL,				/* yuv_scaler_binary */ \
 	{ NULL },			/* delay_frames[ref_frames] */ \
 	NULL,				/* is_output_stage */ \
@@ -128,6 +130,8 @@ struct ia_css_yuvpp_settings {
 	0,					/* num_output */ \
 }
 
+struct osys_object;
+
 struct ia_css_pipe {
 	/* TODO: Remove stop_requested and use stop_requested in the pipeline */
 	bool                            stop_requested;
@@ -160,6 +164,8 @@ struct ia_css_pipe {
 		struct ia_css_capture_settings capture;
 		struct ia_css_yuvpp_settings yuvpp;
 	} pipe_settings;
+	hrt_vaddress scaler_pp_lut;
+	struct osys_object *osys_obj;
 
 	/* This number is unique per pipe each instance of css. This number is
 	 * reused as pipeline number also. There is a 1-1 mapping between pipe_num
@@ -195,6 +201,8 @@ struct ia_css_pipe {
 	{ NULL },				/* continuous_frames */ \
 	{ NULL },				/* cont_md_buffers */ \
 	{ IA_CSS_DEFAULT_PREVIEW_SETTINGS },	/* pipe_settings */ \
+	0,					/* scaler_pp_lut */ \
+	NULL,					/* osys object */ \
 	PIPE_ENTRY_EMPTY_TOKEN,			/* pipe_num */\
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe_public.h
index 0d66b24..254e83d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_pipe_public.h
@@ -50,33 +50,15 @@ enum ia_css_pipe_mode {
 /* Temporary define  */
 #define IA_CSS_PIPE_MODE_NUM (IA_CSS_PIPE_MODE_YUVPP + 1)
 
-
-/**
- * Enumeration of pipe versions.
- * the order should match with definition in sh_css_defs.h
- */
-/*enum ia_css_pipe_version {*/
-/*	IA_CSS_PIPE_VERSION_1 = 1,*/		/**< ISP1.0 pipe */
-/*	IA_CSS_PIPE_VERSION_2_2 = 2,*/		/**< ISP2.2 pipe */
-/*	IA_CSS_PIPE_VERSION_2_6_1 = 3*/		/**< ISP2.6.1 pipe */
-/*};*/
-
 /**
  * Enumeration of pipe versions.
  * the order should match with definition in sh_css_defs.h
  */
-#define IA_CSS_PIPE_VERSION_1 1
-/**
- * Enumeration of pipe versions.
- * the order should match with definition in sh_css_defs.h
- */
-#define IA_CSS_PIPE_VERSION_2_2 2
-/**
- * Enumeration of pipe versions.
- * the order should match with definition in sh_css_defs.h
- */
-#define IA_CSS_PIPE_VERSION_2_6_1 3
-
+enum ia_css_pipe_version {
+	IA_CSS_PIPE_VERSION_1 = 1,		/**< ISP1.0 pipe */
+	IA_CSS_PIPE_VERSION_2_2 = 2,		/**< ISP2.2 pipe */
+	IA_CSS_PIPE_VERSION_2_6_1 = 3		/**< ISP2.6.1 pipe */
+};
 
 /**
  * Pipe configuration structure.
@@ -84,7 +66,7 @@ enum ia_css_pipe_mode {
 struct ia_css_pipe_config {
 	enum ia_css_pipe_mode mode;
 	/**< mode, indicates which mode the pipe should use. */
-	unsigned int isp_pipe_version;
+	enum ia_css_pipe_version isp_pipe_version;
 	/**< pipe version, indicates which imaging pipeline the pipe should use. */
 	struct ia_css_resolution input_effective_res;
 	/**< input effective resolution */
@@ -122,6 +104,10 @@ struct ia_css_pipe_config {
 	bool enable_dpc;
 	/**< Disabling "Defect Pixel Correction" for a pipeline, if this is set
 	     to false. In some use cases this provides better performance. */
+	bool enable_vfpp_bci;
+	/**< Enabling BCI mode will cause yuv_scale binary to be picked up
+	     instead of vf_pp. This only applies to viewfinder post
+	     processing stages. */
 	struct ia_css_isp_config *p_isp_config;
 	/**< Pointer to ISP configuration */
 	struct ia_css_resolution gdc_in_buffer_res;
@@ -153,6 +139,7 @@ struct ia_css_pipe_config {
 	-1,					/* acc_num_execs */ \
 	false,					/* enable_dz */ \
 	false,					/* enable_dpc */ \
+	false,					/* enable_vfpp_bci */ \
 	NULL,					/* p_isp_config */\
 	{ 0, 0 },				/* gdc_in_buffer_res */ \
 	{ 0, 0 }				/* gdc_in_buffer_offset */ \
@@ -486,4 +473,32 @@ ia_css_pipe_get_qos_ext_state (struct ia_css_pipe *pipe,
 void
 ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
 			     struct ia_css_isp_config *config);
+
+/** @brief Set the scaler lut on this pipe. A copy of lut is made in the inuit
+ *         address space. So the LUT can be freed by caller.
+ * @param[in]  pipe        Pipe handle.
+ * @param[in]  lut         Look up tabel
+ *
+ * @return
+ * IA_CSS_SUCCESS 			: Success
+ * IA_CSS_ERR_INVALID_ARGUMENTS		: Invalid Parameters
+ *
+ * Note:
+ * 1) Note that both GDC's are programmed with the same table.
+ * 2) Current implementation ignores the pipe and overrides the
+ *    global lut. This will be fixed in the future
+ * 3) This function must be called before stream start
+ * 4) For 2500, the function is a no-op.
+ *
+ */
+enum ia_css_err
+ia_css_pipe_set_bci_scaler_lut( struct ia_css_pipe *pipe,
+				const void *lut);
+/** @brief Checking of DVS statistics ability
+ * @param[in]	pipe_info	The pipe info.
+ * @return		true - has DVS statistics ability
+ * 			false - otherwise
+ */
+bool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info);
+
 #endif /* __IA_CSS_PIPE_PUBLIC_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_stream_public.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_stream_public.h
index 7a5975e..357395c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_stream_public.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_stream_public.h
@@ -104,16 +104,8 @@ struct ia_css_stream_config {
 	unsigned int sensor_binning_factor; /**< Binning factor used by sensor
 						 to produce image data. This is
 						 used for shading correction. */
-	/** The next field is only for backward compatibility for CSS API 2.0
-	 *  TO BE REMOVED when all drivers move to CSS API 2.1
-	 *  Effectively below two lines are implemented internally:
-	 *  if ( pixels_per_clock == 0 )
-	 *	pixels_per_clock = two_pixels_per_clock ? 2 : 1;
-	 * @deprecated{Replaced by pixels_per_clock for CSS API 2.1}
-	 */
-	bool two_pixels_per_clock; /**< Enable/disable 2 pixels per clock */
 	unsigned int pixels_per_clock; /**< Number of pixels per clock, which can be
-					    1, 2 or 4. 0 is used as legacy support. */
+					    1, 2 or 4. */
 	bool online; /**< offline will activate RAW copy on SP, use this for
 			  continuous capture. */
 		/* ISYS2401 usage: ISP receives data directly from sensor, no copy. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h
index a7446a8..a940673 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
@@ -61,6 +61,9 @@
 #include "isp/kernels/ynr/ynr_2/ia_css_ynr2_types.h"
 #include "isp/kernels/output/output_1.0/ia_css_output_types.h"
 
+#define IA_CSS_DVS_STAT_GRID_INFO_SUPPORTED
+/**< Should be removed after Driver adaptation will be done */
+
 #define IA_CSS_VERSION_MAJOR    2
 #define IA_CSS_VERSION_MINOR    0
 #define IA_CSS_VERSION_REVISION 2
@@ -234,7 +237,8 @@ struct ia_css_grid_info {
 	/** @}*/
 
 	struct ia_css_3a_grid_info  s3a_grid; /**< 3A grid info */
-	struct ia_css_dvs_grid_info dvs_grid; /**< DVS grid info */
+	union ia_css_dvs_grid_u dvs_grid;
+		/**< All types of DVS statistics grid info union */
 
 	enum ia_css_vamem_type vamem_type;
 };
@@ -332,6 +336,7 @@ struct ia_css_capture_config {
 	enum ia_css_capture_mode mode; /**< Still capture mode */
 	uint32_t enable_xnr;	       /**< Enable/disable XNR */
 	uint32_t enable_raw_output;
+	bool enable_capture_pp_bli;    /**< Enable capture_pp_bli mode */
 };
 
 /** default settings for ia_css_capture_config structs */
@@ -339,7 +344,8 @@ struct ia_css_capture_config {
 { \
 	IA_CSS_CAPTURE_MODE_PRIMARY,	/* mode (capture) */ \
 	false,				/* enable_xnr */ \
-	false				/* enable_raw_output */ \
+	false,				/* enable_raw_output */ \
+	false				/* enable_capture_pp_bli */ \
 }
 
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h
index f074711..e848250 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/ia_css_version_data.h
@@ -22,7 +22,7 @@
 #define __IA_CSS_VERSION_DATA_H
 
 
-#define CSS_VERSION_STRING "REL:20150131_05.6_0543; API:2.1.11.2; GIT:irci_20150130_1500__5ef052#5ef052995cc2fc8b1d29fa5ed307c5f5bb2d73a7; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
+#define CSS_VERSION_STRING "REL:20150303_10.2_1620; API:2.1.14.18; GIT:irci_20150303_0640_#2f52b0e481d6fb566cc2a43e52e1246fd4c7f865; SDK:/nfs/iir/disks/iir_hivepackages_003/iir_hivepkgs_disk017/Css_Mizuchi/packages/Css_Mizuchi/int_css_mizuchi_20140829_1053; USER:viedifw; "
 
 
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
index df88292..3af107d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm.host.c
@@ -20,6 +20,19 @@
 #endif
 #include <assert_support.h>
 
+#define BNLM_DIV_LUT_SIZE	(12)
+static const int32_t div_lut_nearests[BNLM_DIV_LUT_SIZE] = {
+	0, 454, 948, 1484, 2070, 2710, 3412, 4184, 5035, 5978, 7025, 8191
+};
+
+static const int32_t div_lut_slopes[BNLM_DIV_LUT_SIZE] = {
+	-7760, -6960, -6216, -5536, -4912, -4344, -3832, -3360, -2936, -2552, -2208, -2208
+};
+
+static const int32_t div_lut_intercepts[BNLM_DIV_LUT_SIZE] = {
+	8184, 7752, 7336, 6928, 6536, 6152, 5776, 5416, 5064, 4728, 4408, 4408
+};
+
 /* Encodes a look-up table from BNLM public parameters to vmem parameters.
  * Input:
  *	lut	:	bnlm_lut struct containing encoded vmem parameters look-up table
@@ -30,19 +43,21 @@
 static inline void
 bnlm_lut_encode(struct bnlm_lut *lut, const int32_t *lut_thr, const int32_t *lut_val, const uint32_t lut_size)
 {
-	int blk, i;
-	const int block_size = 16;
-	const int total_blocks = (ISP_VEC_NELEMS / block_size);
+	uint32_t blk, i;
+	const uint32_t block_size = 16;
+	const uint32_t total_blocks = (ISP_VEC_NELEMS / block_size);
 
 	/* Create VMEM LUTs from the threshold and value arrays.
 	 *
+	 * Min size of the LUT is 2 entries.
+	 *
 	 * Max size of the LUT is 16 entries, so that the LUT can fit into a
 	 * single group of 16 elements inside a vector.
 	 * Then these elements are copied into other groups inside the same
 	 * vector. If the LUT size is less than 16, then remaining elements are
 	 * set to 0.
 	 * */
-	assert(lut_size <= block_size);
+	assert((lut_size >= 2) && (lut_size <= block_size));
 	/* array lut_thr has (lut_size-1) entries */
 	for (i = 0; i < lut_size-2; i++) {
 		/* Check if the lut_thr is monotonically increasing */
@@ -82,8 +97,8 @@ ia_css_bnlm_vmem_encode(
 			const struct ia_css_bnlm_config *from,
 			size_t size)
 {
-	(void)size;
 	int i;
+	(void)size;
 
 	/* Initialize LUTs in VMEM parameters */
 	bnlm_lut_encode(&to->mu_root_lut, from->mu_root_lut_thr, from->mu_root_lut_val, 16);
@@ -98,17 +113,22 @@ ia_css_bnlm_vmem_encode(
 
 	/* Initialize arrays in VMEM parameters */
 	memset(to->nl_th, 0, sizeof(to->nl_th));
-	memcpy(to->nl_th, from->nl_th, sizeof(from->nl_th));
+	to->nl_th[0][0] = from->nl_th[0];
+	to->nl_th[0][1] = from->nl_th[1];
+	to->nl_th[0][2] = from->nl_th[2];
 
 	memset(to->match_quality_max_idx, 0, sizeof(to->match_quality_max_idx));
-	memcpy(to->match_quality_max_idx, from->match_quality_max_idx, sizeof(from->match_quality_max_idx));
+	to->match_quality_max_idx[0][0] = from->match_quality_max_idx[0];
+	to->match_quality_max_idx[0][1] = from->match_quality_max_idx[1];
+	to->match_quality_max_idx[0][2] = from->match_quality_max_idx[2];
+	to->match_quality_max_idx[0][3] = from->match_quality_max_idx[3];
 
-	/* ToDo: Clean up below parameters using new implementation from ATE */
-	memset(&to->exp_lut, 0, sizeof(to->exp_lut));
-	memset(to->div_lut_thr, 0, sizeof(to->div_lut_thr));
-	memset(to->div_lut_nearests, 0, sizeof(to->div_lut_nearests));
-	memset(to->div_lut_slopes, 0, sizeof(to->div_lut_slopes));
+	bnlm_lut_encode(&to->div_lut, div_lut_nearests, div_lut_slopes, BNLM_DIV_LUT_SIZE);
 	memset(to->div_lut_intercepts, 0, sizeof(to->div_lut_intercepts));
+	for(i = 0; i < BNLM_DIV_LUT_SIZE; i++) {
+		to->div_lut_intercepts[0][i] = div_lut_intercepts[i];
+	}
+
 	memset(to->power_of_2, 0, sizeof(to->power_of_2));
 	for (i = 0; i < (ISP_VEC_ELEMBITS-1); i++) {
 		to->power_of_2[0][i] = 1 << i;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
index 85095ba..2f4be43 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_param.h
@@ -36,13 +36,10 @@ struct bnlm_vmem_params {
 	struct bnlm_lut nl_2_lut;
 	struct bnlm_lut nl_3_lut;
 
-	/* ToDo: Remove this after implementing coefficients based aprroximtaion */
-	struct bnlm_lut exp_lut;
-	/* ToDo: Remove div tables after using new ATE implementation */
-	VMEM_ARRAY(div_lut_thr, ISP_VEC_NELEMS);
-	VMEM_ARRAY(div_lut_nearests, ISP_VEC_NELEMS);
-	VMEM_ARRAY(div_lut_slopes, ISP_VEC_NELEMS);
+	/* LUTs used for division approximiation */
+	struct bnlm_lut div_lut;
 	VMEM_ARRAY(div_lut_intercepts, ISP_VEC_NELEMS);
+
 	/* 240x does not have an ISP instruction to left shift each element of a
 	 * vector by different shift value. Hence it will be simulated by multiplying
 	 * the elements by required 2^shift. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_state.h
new file mode 100644
index 0000000..79cce0e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_state.h
@@ -0,0 +1,31 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_BNLM_STATE_H
+#define __IA_CSS_BNLM_STATE_H
+
+
+#include "type_support.h"
+#include "vmem.h" /* for VMEM_ARRAY*/
+#include "bnlm.isp.h"
+
+struct bnlm_vmem_state {
+	/* State buffers required for BNLM */
+	VMEM_ARRAY(buf[BNLM_STATE_BUF_HEIGHT], BNLM_STATE_BUF_WIDTH*ISP_NWAY);
+};
+
+
+
+#endif /* __IA_CSS_BNLM_STATE_H */
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
index 6ab6a95..219fb83 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnlm/ia_css_bnlm_types.h
@@ -15,62 +15,92 @@
 #ifndef __IA_CSS_BNLM_TYPES_H
 #define __IA_CSS_BNLM_TYPES_H
 
+/** @file
+* CSS-API header file for Bayer Non-Linear Mean parameters.
+*/
+
 #include "type_support.h" /* int32_t */
 
-/**
+/** Bayer Non-Linear Mean configuration
+ *
  * \brief BNLM public parameters.
  * \details Struct with all parameters for the BNLM kernel that can be set
  * from the CSS API.
+ *
+ * ISP2.6.1: BNLM is used.
  */
 struct ia_css_bnlm_config {
-	bool rad_enable; /* Enable a radial dependency in a weight calculation */
-	int32_t rad_x_origin; /* Initial x coordinate for a radius calculation */
-	int32_t rad_y_origin; /* Initial x coordinate for a radius calculation */
+	bool		rad_enable;	/**< Enable a radial dependency in a weight calculation */
+	int32_t		rad_x_origin;	/**< Initial x coordinate for a radius calculation */
+	int32_t		rad_y_origin;	/**< Initial x coordinate for a radius calculation */
 	/* a threshold for average of weights if this < Th, do not denoise pixel */
-	int32_t avg_min_th;
+	int32_t		avg_min_th;
 	/* minimum weight for denoising if max < th, do not denoise pixel */
-	int32_t max_min_th;
+	int32_t		max_min_th;
 
-	/* Coefficient for approximation, in the form of (1 + x / N)^N,
+	/**@{*/
+	/** Coefficient for approximation, in the form of (1 + x / N)^N,
 	 * that fits the first-order exp() to default exp_lut in BNLM sheet
 	 * */
-	int32_t exp_coeff_a;
-	uint32_t exp_coeff_b;
-	int32_t exp_coeff_c;
-	uint32_t exp_exponent;
+	int32_t		exp_coeff_a;
+	uint32_t	exp_coeff_b;
+	int32_t		exp_coeff_c;
+	uint32_t	exp_exponent;
+	/**@}*/
+
+	int32_t nl_th[3];	/**< Detail thresholds */
 
-	int32_t nl_th[3]; /* detail thresholds */
-	/* Index for n-th maximum candidate weight for each detail group */
+	/** Index for n-th maximum candidate weight for each detail group */
 	int32_t match_quality_max_idx[4];
 
-	/* A lookup table for 1/sqrt(1+mu) approximation */
+	/**@{*/
+	/** A lookup table for 1/sqrt(1+mu) approximation */
 	int32_t mu_root_lut_thr[15];
 	int32_t mu_root_lut_val[16];
-	/* A lookup table for SAD normalization */
+	/**@}*/
+	/**@{*/
+	/** A lookup table for SAD normalization */
 	int32_t sad_norm_lut_thr[15];
 	int32_t sad_norm_lut_val[16];
-	/* A lookup table that models a weight's dependency on textures */
+	/**@}*/
+	/**@{*/
+	/** A lookup table that models a weight's dependency on textures */
 	int32_t sig_detail_lut_thr[15];
 	int32_t sig_detail_lut_val[16];
-	/* A lookup table that models a weight's dependency on a pixel's radial distance */
+	/**@}*/
+	/**@{*/
+	/** A lookup table that models a weight's dependency on a pixel's radial distance */
 	int32_t sig_rad_lut_thr[15];
 	int32_t sig_rad_lut_val[16];
-	/* A lookup table to control denoise power depending on a pixel's radial distance */
+	/**@}*/
+	/**@{*/
+	/** A lookup table to control denoise power depending on a pixel's radial distance */
 	int32_t rad_pow_lut_thr[15];
 	int32_t rad_pow_lut_val[16];
-	/* Non linear transfer functions to calculate the blending coefficient depending on detail group */
-	/* detail group 0 */
+	/**@}*/
+	/**@{*/
+	/** Non linear transfer functions to calculate the blending coefficient depending on detail group */
+	/** detail group 0 */
+	/**@{*/
 	int32_t nl_0_lut_thr[15];
 	int32_t nl_0_lut_val[16];
-	/* detail group 1 */
+	/**@}*/
+	/**@{*/
+	/** detail group 1 */
 	int32_t nl_1_lut_thr[15];
 	int32_t nl_1_lut_val[16];
-	/* detail group 2 */
+	/**@}*/
+	/**@{*/
+	/** detail group 2 */
 	int32_t nl_2_lut_thr[15];
 	int32_t nl_2_lut_val[16];
-	/* detail group 3 */
+	/**@}*/
+	/**@{*/
+	/** detail group 3 */
 	int32_t nl_3_lut_thr[15];
 	int32_t nl_3_lut_val[16];
+	/**@}*/
+	/**@}*/
 };
 
 #endif /* __IA_CSS_BNLM_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
index da4d0c4..a7de6ec 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.c
@@ -84,7 +84,7 @@ ia_css_bnr2_2_encode(
 
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_bnr2_2_debug_trace(
+ia_css_bnr2_2_debug_dtrace(
 	const struct ia_css_bnr2_2_config *bnr,
 	unsigned level)
 {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
index d7a7324..59349c1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2.host.h
@@ -28,7 +28,7 @@ ia_css_bnr2_2_encode(
 
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_bnr2_2_debug_trace(
+ia_css_bnr2_2_debug_dtrace(
 	const struct ia_css_bnr2_2_config *config,
 	unsigned level);
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
index 7e8b4b6..be80f70 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/bnr/bnr2_2/ia_css_bnr2_2_types.h
@@ -15,42 +15,57 @@
 #ifndef __IA_CSS_BNR2_2_TYPES_H
 #define __IA_CSS_BNR2_2_TYPES_H
 
+/** @file
+* CSS-API header file for Bayer Noise Reduction parameters.
+*/
+
 #include "type_support.h" /* int32_t */
 
-/**
+/** Bayer Noise Reduction 2.2 configuration
+ *
  * \brief BNR2_2 public parameters.
  * \details Struct with all parameters for the BNR2.2 kernel that can be set
  * from the CSS API.
+ *
+ * ISP2.6.1: BNR2.2 is used.
  */
 struct ia_css_bnr2_2_config {
-	/* Directional variance gain for R/G/B components in dark region */
+	/**@{*/
+	/** Directional variance gain for R/G/B components in dark region */
 	int32_t d_var_gain_r;
 	int32_t d_var_gain_g;
 	int32_t d_var_gain_b;
-	/* Slope of Directional variance gain between dark and bright region */
+	/**@}*/
+	/**@{*/
+	/** Slope of Directional variance gain between dark and bright region */
 	int32_t d_var_gain_slope_r;
 	int32_t d_var_gain_slope_g;
 	int32_t d_var_gain_slope_b;
-	/* Non-Directional variance gain for R/G/B components in dark region */
+	/**@}*/
+	/**@{*/
+	/** Non-Directional variance gain for R/G/B components in dark region */
 	int32_t n_var_gain_r;
 	int32_t n_var_gain_g;
 	int32_t n_var_gain_b;
-	/* Slope of Non-Directional variance gain between dark and bright region */
+	/**@}*/
+	/**@{*/
+	/** Slope of Non-Directional variance gain between dark and bright region */
 	int32_t n_var_gain_slope_r;
 	int32_t n_var_gain_slope_g;
 	int32_t n_var_gain_slope_b;
+	/**@}*/
 
-	int32_t dir_thres;		/* Threshold for directional filtering */
-	int32_t dir_thres_w;		/* Threshold width for directional filtering */
-	int32_t var_offset_coef;	/* Variance offset coefficient */
-	int32_t dir_gain;		/* Gain for directional coefficient */
-	int32_t detail_gain;		/* Gain for low contrast texture control */
-	int32_t detail_gain_divisor;	/* Gain divisor for low contrast texture control */
-	int32_t detail_level_offset;	/* Bias value for low contrast texture control */
-	int32_t d_var_th_min;		/* Minimum clipping value for directional variance*/
-	int32_t d_var_th_max;		/* Maximum clipping value for diretional variance*/
-	int32_t n_var_th_min;		/* Minimum clipping value for non-directional variance*/
-	int32_t n_var_th_max;		/* Maximum clipping value for non-directional variance*/
+	int32_t dir_thres;		/**< Threshold for directional filtering */
+	int32_t dir_thres_w;		/**< Threshold width for directional filtering */
+	int32_t var_offset_coef;	/**< Variance offset coefficient */
+	int32_t dir_gain;		/**< Gain for directional coefficient */
+	int32_t detail_gain;		/**< Gain for low contrast texture control */
+	int32_t detail_gain_divisor;	/**< Gain divisor for low contrast texture control */
+	int32_t detail_level_offset;	/**< Bias value for low contrast texture control */
+	int32_t d_var_th_min;		/**< Minimum clipping value for directional variance*/
+	int32_t d_var_th_max;		/**< Maximum clipping value for diretional variance*/
+	int32_t n_var_th_min;		/**< Minimum clipping value for non-directional variance*/
+	int32_t n_var_th_max;		/**< Maximum clipping value for non-directional variance*/
 };
 
 #endif /* __IA_CSS_BNR2_2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
index 059a777..6df6c2b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/cnr/cnr_2/ia_css_cnr2_types.h
@@ -38,17 +38,17 @@ struct ia_css_cnr_config {
 	uint16_t coring_v;	/**< Coring level of V.
 				u0.13, [0,8191], default/ineffective 0 */
 	uint16_t sense_gain_vy;	/**< Sensitivity of horizontal edge of Y.
-				u13.0, [0,8191], default 100, ineffective 0 */
+				u13.0, [0,8191], default 100, ineffective 8191 */
 	uint16_t sense_gain_vu;	/**< Sensitivity of horizontal edge of U.
-				u13.0, [0,8191], default 100, ineffective 0 */
+				u13.0, [0,8191], default 100, ineffective 8191 */
 	uint16_t sense_gain_vv;	/**< Sensitivity of horizontal edge of V.
-				u13.0, [0,8191], default 100, ineffective 0 */
+				u13.0, [0,8191], default 100, ineffective 8191 */
 	uint16_t sense_gain_hy;	/**< Sensitivity of vertical edge of Y.
-				u13.0, [0,8191], default 50, ineffective 0 */
+				u13.0, [0,8191], default 50, ineffective 8191 */
 	uint16_t sense_gain_hu;	/**< Sensitivity of vertical edge of U.
-				u13.0, [0,8191], default 50, ineffective 0 */
+				u13.0, [0,8191], default 50, ineffective 8191 */
 	uint16_t sense_gain_hv;	/**< Sensitivity of vertical edge of V.
-				u13.0, [0,8191], default 50, ineffective 0 */
+				u13.0, [0,8191], default 50, ineffective 8191 */
 };
 
 #endif /* __IA_CSS_CNR2_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
index 32f2433..45e1ea8 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/copy_output/copy_output_1.0/ia_css_copy_output.host.c
@@ -19,6 +19,10 @@
 #include "ia_css_isp_configs.h"
 #include "isp.h"
 
+static const struct ia_css_copy_output_configuration default_config = {
+	.enable = false,
+};
+
 void
 ia_css_copy_output_config(
 	struct sh_css_isp_copy_output_isp_config      *to,
@@ -34,8 +38,10 @@ ia_css_copy_output_configure(
 	const struct ia_css_binary     *binary,
 	bool enable)
 {
-	const struct ia_css_copy_output_configuration config =
-		{ enable };
+	struct ia_css_copy_output_configuration config = default_config;
+
+	config.enable = enable;
+
 	ia_css_configure_copy_output(binary, &config);
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
index 75daff5..9290522 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/crop/crop_1.0/ia_css_crop.host.c
@@ -21,6 +21,10 @@
 #include "isp.h"
 #include "ia_css_crop.host.h"
 
+static const struct ia_css_crop_configuration default_config = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
 void
 ia_css_crop_encode(
 	struct sh_css_isp_crop_isp_params *to,
@@ -52,7 +56,9 @@ ia_css_crop_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_crop_configuration config =
-		{ info };
+	struct ia_css_crop_configuration config = default_config;
+
+	config.info = info;
+
 	ia_css_configure_crop(binary, &config);
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
index 4f6384f..c8b4b33 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.c
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #include "ia_css_types.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
index c53399e..3733aee 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2.host.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_CTC2_HOST_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
index 4cc81c6..c66e823 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_CTC2_PARAM_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
index 0afe822..7b75f01 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ctc/ctc2/ia_css_ctc2_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_CTC2_TYPES_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
index 46e8bbc..126d0d3 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dp/dp_1.0/ia_css_dp_state.h
@@ -18,7 +18,11 @@
 #include "type_support.h"
 
 #include "vmem.h"
+#if NEED_BDS_OTHER_THAN_1_00
+#define MAX_VECTORS_PER_DP_LINE MAX_VECTORS_PER_BUF_INPUT_LINE
+#else
 #define MAX_VECTORS_PER_DP_LINE MAX_VECTORS_PER_BUF_LINE
+#endif
 
 /* DP (Defect Pixel Correction) */
 struct sh_css_isp_dp_vmem_state {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
index c98ccf0..bc14b85 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.c
@@ -42,3 +42,24 @@ ia_css_dpc2_encode(
 	to->wb_gain_gb = from->wb_gain_gb;
 }
 
+/* TODO: AM: This needs a proper implementation. */
+void
+ia_css_init_dpc2_state(
+	void *state,
+	size_t size)
+{
+	(void)state;
+	(void)size;
+}
+
+#ifndef IA_CSS_NO_DEBUG
+/* TODO: AM: This needs a proper implementation. */
+void
+ia_css_dpc2_debug_dtrace(
+	const struct ia_css_dpc2_config *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.h
index c9c5c16..641564b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2.host.h
@@ -25,4 +25,16 @@ ia_css_dpc2_encode(
 	const struct ia_css_dpc2_config *from,
 	size_t size);
 
+void
+ia_css_init_dpc2_state(
+	void *state,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
+ia_css_dpc2_debug_dtrace(
+	const struct ia_css_dpc2_config *config,
+	unsigned level);
+#endif
+
 #endif /* __IA_CSS_DPC2_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c
index ab02137..c102601 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.c
@@ -12,3 +12,15 @@
  * more details.
  */
 
+#include "ia_css_dpc2_types.h"
+
+const struct ia_css_dpc2_config default_dpc2_config = {
+	.metric1 = 1638,
+	.metric2 =  128,
+	.metric3 = 1638,
+	.wb_gain_gr = 512,
+	.wb_gain_r  = 512,
+	.wb_gain_b  = 512,
+	.wb_gain_gb = 512
+};
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h
index ab02137..a1527ce 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_default.host.h
@@ -12,3 +12,12 @@
  * more details.
  */
 
+#ifndef __IA_CSS_DPC2_DEFAULT_HOST_H
+#define __IA_CSS_DPC2_DEFAULT_HOST_H
+
+#include "ia_css_dpc2_types.h"
+
+extern const struct ia_css_dpc2_config default_dpc2_config;
+
+#endif /* __IA_CSS_DPC2_DEFAULT_HOST_H */
+
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
index 4034328..b2c9741 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dpc2/ia_css_dpc2_types.h
@@ -15,14 +15,35 @@
 #ifndef __IA_CSS_DPC2_TYPES_H
 #define __IA_CSS_DPC2_TYPES_H
 
+/** @file
+* CSS-API header file for Defect Pixel Correction 2 (DPC2) parameters.
+*/
+
 #include "type_support.h"
+
+/**@{*/
+/** Floating point constants for different metrics. */
 #define METRIC1_ONE_FP	(1<<12)
 #define METRIC2_ONE_FP	(1<<5)
 #define METRIC3_ONE_FP	(1<<12)
 #define WBGAIN_ONE_FP	(1<<9)
+/**@}*/
 
-
+/**@{*/
+/** Defect Pixel Correction 2 configuration.
+ *
+ * \brief DPC2 public parameters.
+ * \details Struct with all parameters for the Defect Pixel Correction 2
+ * kernel that can be set from the CSS API.
+ *
+ * ISP block: DPC1 (DPC after WB)
+ *            DPC2 (DPC before WB)
+ * ISP1: DPC1 is used.
+ * ISP2: DPC2 is used.
+ *
+ */
 struct ia_css_dpc2_config {
+	/**@{*/
 	int32_t metric1;
 	int32_t metric2;
 	int32_t metric3;
@@ -30,7 +51,9 @@ struct ia_css_dpc2_config {
 	int32_t wb_gain_r;
 	int32_t wb_gain_b;
 	int32_t wb_gain_gb;
+	/**@}*/
 };
+/**@}*/
 
 #endif /* __IA_CSS_DPC2_TYPES_H */
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
index dee174d..fe342f2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.c
@@ -27,6 +27,9 @@
 
 #include "ia_css_dvs.host.h"
 
+static const struct ia_css_dvs_configuration default_config = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
 
 void
 ia_css_dvs_config(
@@ -46,8 +49,10 @@ ia_css_dvs_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_dvs_configuration config =
-		{ info };
+	struct ia_css_dvs_configuration config = default_config;
+
+	config.info = info;
+
 	ia_css_configure_dvs(binary, &config);
 }
 
@@ -76,7 +81,7 @@ convert_coords_to_ispparams(
 	unsigned int num_blocks_x =  (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(o_width)  : DVS_NUM_BLOCKS_X(o_width)  ); // round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even
 
 
-	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL << uv_flag;
+	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL;
 	unsigned width, height;
 	unsigned int *xbuff = NULL;
 	unsigned int *ybuff = NULL;
@@ -220,8 +225,9 @@ convert_coords_to_ispparams(
 
 struct ia_css_host_data *
 convert_allocate_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
-	const struct ia_css_binary *binary)
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info)
 {
 	unsigned int i_stride;
 	unsigned int o_width;
@@ -229,45 +235,58 @@ convert_allocate_dvs_6axis_config(
 	struct ia_css_host_data *me;
 	struct gdc_warp_param_mem_s *isp_data_ptr;
 
-	assert(params != NULL);
 	assert(binary != NULL);
-	assert(params->dvs_6axis_config != NULL);
+	assert(dvs_6axis_config != NULL);
+	assert(dvs_in_frame_info != NULL);
 
 	me = ia_css_host_data_allocate((size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3));
 
 	if (!me)
 		return NULL;
 
+	/*DVS only supports input frame of YUV420 or NV12. Fail for all other cases*/
+	assert((dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_NV12)
+		|| (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420));
+
 	isp_data_ptr = (struct gdc_warp_param_mem_s *)me->address;
-	/* bgz115: replaced binary->in_frame_info.res.width for
-	   'padded_width=stride' */
-	i_stride  = binary->internal_frame_info.padded_width;
+
+	i_stride  = dvs_in_frame_info->padded_width;
+
 	o_width  = binary->out_frame_info[0].res.width;
 	o_height = binary->out_frame_info[0].res.height;
 
 	/* Y plane */
-	convert_coords_to_ispparams(me, params->dvs_6axis_config,
+	convert_coords_to_ispparams(me, dvs_6axis_config,
 				    i_stride, o_width, o_height, 0);
+
+	if (dvs_in_frame_info->format == IA_CSS_FRAME_FORMAT_YUV420) {
+		/*YUV420 has half the stride for U/V plane*/
+		i_stride /=2;
+	}
+
 	/* UV plane (packed inside the y plane) */
-	convert_coords_to_ispparams(me, params->dvs_6axis_config,
-				    i_stride/2, o_width/2, o_height/2, 1);
+	convert_coords_to_ispparams(me, dvs_6axis_config,
+				    i_stride, o_width/2, o_height/2, 1);
 
 	return me;
 }
 
 enum ia_css_err
 store_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
 	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info,
 	hrt_vaddress ddr_addr_y)
 {
 
 	struct ia_css_host_data *me;
-	assert(params != NULL);
+	assert(dvs_6axis_config != NULL);
 	assert(ddr_addr_y != mmgr_NULL);
+	assert(dvs_in_frame_info != NULL);
 
-	me = convert_allocate_dvs_6axis_config(params,
-				 binary);
+	me = convert_allocate_dvs_6axis_config(dvs_6axis_config,
+				 binary,
+				 dvs_in_frame_info);
 
 	if (!me) {
 		IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
@@ -279,7 +298,6 @@ store_dvs_6axis_config(
 				me);
 	ia_css_host_data_free(me);
 
-	params->isp_params_changed = true;
 	return IA_CSS_SUCCESS;
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
index dd1f507..2f513e2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/dvs/dvs_1.0/ia_css_dvs.host.h
@@ -46,13 +46,15 @@ convert_dvs_6axis_config(
 
 struct ia_css_host_data *
 convert_allocate_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
-	const struct ia_css_binary *binary);
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
+	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info);
 
 enum ia_css_err
 store_dvs_6axis_config(
-	struct ia_css_isp_parameters *params,
+	const struct ia_css_dvs_6axis_config *dvs_6axis_config,
 	const struct ia_css_binary *binary,
+	const struct ia_css_frame_info *dvs_in_frame_info,
 	hrt_vaddress ddr_addr_y);
 
 #endif /* __IA_CSS_DVS_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
index 66e5bb6..1e50392 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.c
@@ -19,6 +19,7 @@
 
 #include "type_support.h"
 #include "assert_support.h"
+#include "math_support.h" /* for min and max */
 
 #include "ia_css_eed1_8.host.h"
 
@@ -87,9 +88,10 @@ ia_css_eed1_8_vmem_encode(
 
 	/* Init */
 	for (i = 0; i < ISP_VEC_NELEMS; i++) {
-		to->e_cuedge_x[0][i] = 0;
-		to->e_cuedge_a[0][i] = 0;
-		to->e_cuedge_b[0][i] = 0;
+		to->e_dew_enh_x[0][i] = 0;
+		to->e_dew_enh_y[0][i] = 0;
+		to->e_dew_enh_a[0][i] = 0;
+		to->e_dew_enh_f[0][i] = 0;
 		to->chgrinv_x[0][i] = 0;
 		to->chgrinv_a[0][i] = 0;
 		to->chgrinv_b[0][i] = 0;
@@ -159,21 +161,25 @@ ia_css_eed1_8_vmem_encode(
 		base = shuffle_block * i;
 
 		for (j = 0; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
-			to->e_cuedge_x[0][base + j] = from->dew_enhance_seg_x[j];
-			to->e_cuedge_b[0][base + j] = from->dew_enhance_seg_y[j];
+			to->e_dew_enh_x[0][base + j] = min(max(from->dew_enhance_seg_x[j], 0), 8191);
+			to->e_dew_enh_y[0][base + j] = min(max(from->dew_enhance_seg_y[j], -8192), 8191);
 		}
 
-		/* TODO: the calculation of the slope is not included in the KFS.
-		 * Till implementation is available the result of the slope calculation is
-		 * mulitplied with 1024 (just to increase the precision of the slope, since
-		 * the slopes for the default set of x and y is between 0 and 3.
-		 */
-		for (j = 1; j < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; j++) {
-			to->e_cuedge_a[0][base + j - 1] = 1024 * (from->dew_enhance_seg_y[j] - from->dew_enhance_seg_y[j - 1]) / (from->dew_enhance_seg_x[j] - from->dew_enhance_seg_x[j - 1]);
+		for (j = 0; j < (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1); j++) {
+			to->e_dew_enh_a[0][base + j] = min(max(from->dew_enhance_seg_slope[j], -8192), 8191);
+			/* Convert dew_enhance_seg_exp to flag:
+			 * 0 -> 0
+			 * 1...13 -> 1
+			 */
+			to->e_dew_enh_f[0][base + j] = (min(max(from->dew_enhance_seg_exp[j], 0), 13) > 0);
 		}
 
-		/* Hard-coded to 0, see KFS for more details */
-		to->e_cuedge_a[0][base + IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1] = 0;
+		/* Hard-coded to 0, in order to be able to handle out of
+		 * range input in the same way as the other segments.
+		 * See KFS for more details.
+		 */
+		to->e_dew_enh_a[0][base + (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] = 0;
+		to->e_dew_enh_f[0][base + (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)] = 0;
 
 		for (j = 0; j < NUMBER_OF_CHGRINV_POINTS; j++) {
 			to->chgrinv_x[0][base + j] = chgrinv_x[j];
@@ -206,6 +212,7 @@ ia_css_eed1_8_encode(
 	size_t size)
 {
 	int i;
+	int min_exp = 0;
 
 	(void)size;
 
@@ -247,17 +254,28 @@ ia_css_eed1_8_encode(
 	to->margin_neg0 = from->neg_margin0;
 	to->margin_neg_diff = (from->neg_margin1 - from->neg_margin0);
 
-	for (i = 0; i < IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS; i++) {
-		to->dew_enhance_seg_x[i] = from->dew_enhance_seg_x[i];
-		to->dew_enhance_seg_y[i] = from->dew_enhance_seg_y[i];
+	/* Encode DEWEnhance exp (e_dew_enh_asr) */
+	for (i = 0; i < (IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1); i++) {
+		min_exp = max(min_exp, from->dew_enhance_seg_exp[i]);
 	}
+	to->e_dew_enh_asr = 13 - min(max(min_exp, 0), 13);
 
 	to->dedgew_max = from->dedgew_max;
 }
 
+
+void
+ia_css_init_eed1_8_state(
+	void *state,
+	size_t size)
+{
+	memset(state, 0, size);
+}
+
+
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_eed1_8_debug_trace(
+ia_css_eed1_8_debug_dtrace(
 	const struct ia_css_eed1_8_config *eed,
 	unsigned level)
 {
@@ -297,6 +315,8 @@ ia_css_eed1_8_debug_trace(
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "pos_margin1", eed->pos_margin1);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin0", eed->neg_margin0);
 	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "neg_margin1", eed->neg_margin1);
+
+	ia_css_debug_dtrace(level, "\t%-32s = %d\n", "dedgew_max", eed->dedgew_max);
 }
 #endif
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
index 46e8bbe..355ff13 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8.host.h
@@ -31,9 +31,14 @@ ia_css_eed1_8_encode(
 	const struct ia_css_eed1_8_config *from,
 	size_t size);
 
+void
+ia_css_init_eed1_8_state(
+	void *state,
+	size_t size);
+
 #ifndef IA_CSS_NO_DEBUG
 void
-ia_css_eed1_8_debug_trace(
+ia_css_eed1_8_debug_dtrace(
 	const struct ia_css_eed1_8_config *config,
 	unsigned level);
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c
index 4456541..3622719 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_default.host.c
@@ -70,5 +70,25 @@ const struct ia_css_eed1_8_config default_eed1_8_config = {
 		6094,
 		8191
 		},
+	.dew_enhance_seg_slope = {
+		4608,
+		3308,
+		2757,
+		2417,
+		2186,
+		8033,
+		7473,
+		7020
+		},
+	.dew_enhance_seg_exp = {
+		2,
+		2,
+		2,
+		2,
+		2,
+		0,
+		0,
+		0
+		},
 	.dedgew_max = 6144
 };
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
index 0260e6c..bc3a07f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_param.h
@@ -39,21 +39,19 @@
 /* Define size of the state..... TODO: check if this is the correct place */
 /* 4 planes : GR, R, B, GB */
 #define NUM_PLANES	4
-/* 6 lines state per color plane input_line_state */
-#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(5 * NUM_PLANES)
 
-/* ToDo: Move this to testsetup */
-#define MAX_FRAME_SIMDWIDTH	30
+/* 5 lines state per color plane input_line_state */
+#define EED1_8_STATE_INPUT_BUFFER_HEIGHT	(5 * NUM_PLANES)
 
 /* Each plane has width equal to half frame line */
 #define EED1_8_STATE_INPUT_BUFFER_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
-/* 2 lines state per color plane LD_H state */
-#define EED1_8_STATE_LD_H_HEIGHT	(2 * NUM_PLANES)
+/* 1 line state per color plane LD_H state */
+#define EED1_8_STATE_LD_H_HEIGHT	(1 * NUM_PLANES)
 #define EED1_8_STATE_LD_H_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
-/* 2 lines state per color plane LD_V state */
-#define EED1_8_STATE_LD_V_HEIGHT	(2 * NUM_PLANES)
+/* 1 line state per color plane LD_V state */
+#define EED1_8_STATE_LD_V_HEIGHT	(1 * NUM_PLANES)
 #define EED1_8_STATE_LD_V_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
 /* 1 line (single plane) state for D_Hr state */
@@ -72,7 +70,7 @@
 #define EED1_8_STATE_D_VB_HEIGHT	2
 #define EED1_8_STATE_D_VB_WIDTH		CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
-/* 3 lines state for R and B (= 2 planes) rb_zipped_state */
+/* 2 lines state for R and B (= 2 planes) rb_zipped_state */
 #define EED1_8_STATE_RB_ZIPPED_HEIGHT	(2 * 2)
 #define EED1_8_STATE_RB_ZIPPED_WIDTH	CEIL_DIV(MAX_FRAME_SIMDWIDTH, 2)
 
@@ -95,9 +93,10 @@
 #endif
 
 struct eed1_8_vmem_params {
-	VMEM_ARRAY(e_cuedge_x, ISP_VEC_NELEMS);
-	VMEM_ARRAY(e_cuedge_a, ISP_VEC_NELEMS);
-	VMEM_ARRAY(e_cuedge_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_y, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(e_dew_enh_f, ISP_VEC_NELEMS);
 	VMEM_ARRAY(chgrinv_x, ISP_VEC_NELEMS);
 	VMEM_ARRAY(chgrinv_a, ISP_VEC_NELEMS);
 	VMEM_ARRAY(chgrinv_b, ISP_VEC_NELEMS);
@@ -148,8 +147,7 @@ struct eed1_8_dmem_params {
 	int32_t margin_neg0;
 	int32_t margin_neg_diff;
 
-	int32_t dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];
-	int32_t dew_enhance_seg_y[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];
+	int32_t e_dew_enh_asr;
 	int32_t dedgew_max;
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h
index 89c3e31..07651f0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/eed1_8/ia_css_eed1_8_types.h
@@ -15,6 +15,11 @@
 #ifndef __IA_CSS_EED1_8_TYPES_H
 #define __IA_CSS_EED1_8_TYPES_H
 
+/** @file
+* CSS-API header file for Edge Enhanced Demosaic parameters.
+*/
+
+
 #include "type_support.h"
 
 /**
@@ -23,7 +28,7 @@
  * from the CSS API.
  */
 
-/* parameter list is based on ISP261 CSS API public parameter list_all.xlsx from 12-09-2014 */
+/* parameter list is based on ISP261 CSS API public parameter list_all.xlsx from 28-01-2015 */
 
 /* Number of segments + 1 segment used in edge reliability enhancement
  * Ineffective: N/A
@@ -31,45 +36,51 @@
  */
 #define IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS	9
 
+/** Edge Enhanced Demosaic configuration
+ *
+ * ISP2.6.1: EED1_8 is used.
+ */
 
 struct ia_css_eed1_8_config {
-	int32_t rbzp_strength;	/**Strength of zipper reduction. */
-
-	int32_t fcstrength;	/**Strength of false color reduction. */
-	int32_t fcthres_0;	/**Threshold to prevent chroma coring due to nois or green disparity in dark region. */
-	int32_t fcthres_1;	/**Threshold to prevent chroma coring due to nois or green disparity in bright region. */
-	int32_t fc_sat_coef;	/**How much color saturation to maintain in high color saturation region. */
-	int32_t fc_coring_prm;	/**Chroma coring coefficient for tint color suppression. */
-
-	int32_t aerel_thres0;	/**Threshold for Non-Directional Reliability at dark region. */
-	int32_t aerel_gain0;	/**Gain for Non-Directional Reliability at dark region. */
-	int32_t aerel_thres1;	/**Threshold for Non-Directional Reliability at bright region. */
-	int32_t aerel_gain1;	/**Gain for Non-Directional Reliability at bright region. */
-
-	int32_t derel_thres0;	/**Threshold for Directional Reliability at dark region. */
-	int32_t derel_gain0;	/**Gain for Directional Reliability at dark region. */
-	int32_t derel_thres1;	/**Threshold for Directional Reliability at bright region. */
-	int32_t derel_gain1;	/**Gain for Directional Reliability at bright region. */
-
-	int32_t coring_pos0;	/**Positive Edge Coring Threshold in dark region. */
-	int32_t coring_pos1;	/**Positive Edge Coring Threshold in bright region. */
-	int32_t coring_neg0;	/**Negative Edge Coring Threshold in dark region. */
-	int32_t coring_neg1;	/**Negative Edge Coring Threshold in bright region. */
-
-	int32_t gain_exp;	/**Common Exponent of Gain. */
-	int32_t gain_pos0;	/**Gain for Positive Edge in dark region. */
-	int32_t gain_pos1;	/**Gain for Positive Edge in bright region. */
-	int32_t gain_neg0;	/**Gain for Negative Edge in dark region. */
-	int32_t gain_neg1;	/**Gain for Negative Edge in bright region. */
-
-	int32_t pos_margin0;	/**Margin for Positive Edge in dark region. */
-	int32_t pos_margin1;	/**Margin for Positive Edge in bright region. */
-	int32_t neg_margin0;	/**Margin for Negative Edge in dark region. */
-	int32_t neg_margin1;	/**Margin for Negative Edge in bright region. */
-
-	int32_t dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];	/**Segment data for directional edge weight. */
-	int32_t dew_enhance_seg_y[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];	/**Segment data for directional edge weight. */
-	int32_t dedgew_max;	/**Max Weight for Directional Edge. */
+	int32_t rbzp_strength;	/**< Strength of zipper reduction. */
+
+	int32_t fcstrength;	/**< Strength of false color reduction. */
+	int32_t fcthres_0;	/**< Threshold to prevent chroma coring due to noise or green disparity in dark region. */
+	int32_t fcthres_1;	/**< Threshold to prevent chroma coring due to noise or green disparity in bright region. */
+	int32_t fc_sat_coef;	/**< How much color saturation to maintain in high color saturation region. */
+	int32_t fc_coring_prm;	/**< Chroma coring coefficient for tint color suppression. */
+
+	int32_t aerel_thres0;	/**< Threshold for Non-Directional Reliability at dark region. */
+	int32_t aerel_gain0;	/**< Gain for Non-Directional Reliability at dark region. */
+	int32_t aerel_thres1;	/**< Threshold for Non-Directional Reliability at bright region. */
+	int32_t aerel_gain1;	/**< Gain for Non-Directional Reliability at bright region. */
+
+	int32_t derel_thres0;	/**< Threshold for Directional Reliability at dark region. */
+	int32_t derel_gain0;	/**< Gain for Directional Reliability at dark region. */
+	int32_t derel_thres1;	/**< Threshold for Directional Reliability at bright region. */
+	int32_t derel_gain1;	/**< Gain for Directional Reliability at bright region. */
+
+	int32_t coring_pos0;	/**< Positive Edge Coring Threshold in dark region. */
+	int32_t coring_pos1;	/**< Positive Edge Coring Threshold in bright region. */
+	int32_t coring_neg0;	/**< Negative Edge Coring Threshold in dark region. */
+	int32_t coring_neg1;	/**< Negative Edge Coring Threshold in bright region. */
+
+	int32_t gain_exp;	/**< Common Exponent of Gain. */
+	int32_t gain_pos0;	/**< Gain for Positive Edge in dark region. */
+	int32_t gain_pos1;	/**< Gain for Positive Edge in bright region. */
+	int32_t gain_neg0;	/**< Gain for Negative Edge in dark region. */
+	int32_t gain_neg1;	/**< Gain for Negative Edge in bright region. */
+
+	int32_t pos_margin0;	/**< Margin for Positive Edge in dark region. */
+	int32_t pos_margin1;	/**< Margin for Positive Edge in bright region. */
+	int32_t neg_margin0;	/**< Margin for Negative Edge in dark region. */
+	int32_t neg_margin1;	/**< Margin for Negative Edge in bright region. */
+
+	int32_t dew_enhance_seg_x[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];		/**< Segment data for directional edge weight: X. */
+	int32_t dew_enhance_seg_y[IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS];		/**< Segment data for directional edge weight: Y. */
+	int32_t dew_enhance_seg_slope[(IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)];	/**< Segment data for directional edge weight: Slope. */
+	int32_t dew_enhance_seg_exp[(IA_CSS_NUMBER_OF_DEW_ENHANCE_SEGMENTS - 1)];	/**< Segment data for directional edge weight: Exponent. */
+	int32_t dedgew_max;	/**< Max Weight for Directional Edge. */
 };
 
 #endif /* __IA_CSS_EED1_8_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
index 9fdd597..1fb9f27 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/fpn/fpn_1.0/ia_css_fpn.host.c
@@ -71,20 +71,19 @@ ia_css_fpn_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_frame_info my_info =
-		{ { CEIL_DIV(info->res.width, 2), /* Packed by 2x */
-		    info->res.height
-		  },
-		  CEIL_DIV(info->padded_width, 2), /* Packed by 2x */
-		  info->format,
-		  FPN_BITS_PER_PIXEL,
-		  info->raw_bayer_order,
-		  { info->crop_info.start_column,
-		    info->crop_info.start_line
-		  }
-		};
-	const struct ia_css_fpn_configuration config =
-		{ &my_info };
+	struct ia_css_frame_info my_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
+	const struct ia_css_fpn_configuration config = {
+		&my_info
+	};
+
+	my_info.res.width       = CEIL_DIV(info->res.width, 2);		/* Packed by 2x */
+	my_info.res.height      = info->res.height;
+	my_info.padded_width    = CEIL_DIV(info->padded_width, 2);	/* Packed by 2x */
+	my_info.format          = info->format;
+	my_info.raw_bit_depth   = FPN_BITS_PER_PIXEL;
+	my_info.raw_bayer_order = info->raw_bayer_order;
+	my_info.crop_info       = info->crop_info;
+
 	ia_css_configure_fpn(binary, &config);
 }
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c
index e2e828b..8a746f1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.c
@@ -1,27 +1,17 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #include "ia_css_hdr.host.h"
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h
index d2197b1..34c6a13 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr.host.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h
index b55ff4b..455d741 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_param.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h
index a8fca14..8b2e4f0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/hdr/ia_css_hdr_types.h
@@ -1,5 +1,5 @@
-/* Release Version: irci_master_20150131_0457 */
-/* Release Version: irci_master_20150131_0457 */
+/* Release Version: irci_master_20150303_1500 */
+/* Release Version: irci_master_20150303_1500 */
 /*
  * Support for Intel Camera Imaging ISP subsystem.
  * Copyright (c) 2015, Intel Corporation.
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
index 4a974e7..270f423 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.c
@@ -105,7 +105,19 @@ ia_css_iefd2_6_vmem_encode(
 			to->e_curad_b[0][base+j] = from->cu_radial_slopes_b[j-1];
 		}
 		to->e_curad_x[0][base+6] = from->cu_radial_points_x[5];
+
+		/* Init asrrnd_lut */
+		to->asrrnd_lut[0][base] = 8192;
+		to->asrrnd_lut[0][base+1] = 4096;
+		to->asrrnd_lut[0][base+2] = 2048;
+		to->asrrnd_lut[0][base+3] = 1024;
+		to->asrrnd_lut[0][base+4] = 512;
+		to->asrrnd_lut[0][base+5] = 256;
+		to->asrrnd_lut[0][base+6] = 128;
+		to->asrrnd_lut[0][base+7] = 64;
+		to->asrrnd_lut[0][base+8] = 32;
 	}
+
 }
 
 void
@@ -159,10 +171,24 @@ ia_css_iefd2_6_encode(
 	/* Setup for configurable units */
 	to->e_cued2_a		= from->cu_ed2_slopes_a;
 	to->e_cu_vssnlm_a	= from->cu_vssnlm_slopes_a;
-	to->e_cued2_b		= from->cu_ed2_points_x[0];
-	to->e_cu_vssnlm_b	= ((0-from->cu_vssnlm_points_x[1]) * from->cu_vssnlm_slopes_a)>>4;
+	to->e_cued2_x1		= from->cu_ed2_points_x[0];
+	to->e_cued2_x_diff	= from->cu_ed2_points_x[1] - from->cu_ed2_points_x[0];
+	to->e_cu_vssnlm_x1	= from->cu_vssnlm_points_x[0];
+	to->e_cu_vssnlm_x_diff  = from->cu_vssnlm_points_x[1] - from->cu_vssnlm_points_x[0];
+}
+
+/* TODO: AM: This needs a proper implementation. */
+void
+ia_css_init_iefd2_6_state(
+	void *state,
+	size_t size)
+{
+	(void)state;
+	(void)size;
 }
 
+#ifndef IA_CSS_NO_DEBUG
+/* TODO: AM: This needs a proper implementation. */
 void
 ia_css_iefd2_6_debug_dtrace(
 	const struct ia_css_iefd2_6_config *config,
@@ -171,3 +197,4 @@ ia_css_iefd2_6_debug_dtrace(
 	(void)config;
 	(void)level;
 }
+#endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
index d0e7ce8..580d51fe 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6.host.h
@@ -32,8 +32,15 @@ ia_css_iefd2_6_encode(
 	size_t size);
 
 void
+ia_css_init_iefd2_6_state(
+	void *state,
+	size_t size);
+
+#ifndef IA_CSS_NO_DEBUG
+void
 ia_css_iefd2_6_debug_dtrace(
 	const struct ia_css_iefd2_6_config *config, unsigned level)
 ;
+#endif
 
 #endif /* __IA_CSS_IEFD2_6_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
index 3ca31f2..3079096 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_param.h
@@ -31,6 +31,7 @@ struct iefd2_6_vmem_params {
 	VMEM_ARRAY(e_curad_x, ISP_VEC_NELEMS);
 	VMEM_ARRAY(e_curad_a, ISP_VEC_NELEMS);
 	VMEM_ARRAY(e_curad_b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(asrrnd_lut, ISP_VEC_NELEMS);
 };
 
 struct iefd2_6_dmem_params {
@@ -72,9 +73,11 @@ struct iefd2_6_dmem_params {
 	int32_t vssnlm_y2;
 	int32_t vssnlm_y3;
 	int32_t e_cued2_a;
-	int32_t e_cued2_b;
+	int32_t e_cued2_x1;
+	int32_t e_cued2_x_diff;
 	int32_t e_cu_vssnlm_a;
-	int32_t e_cu_vssnlm_b;
+	int32_t e_cu_vssnlm_x1;
+	int32_t e_cu_vssnlm_x_diff;
 };
 
 #endif /* __IA_CSS_IEFD2_6_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
index 56fd44f..0915f14 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_state.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2014 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _IA_CSS_IEFD2_6_STATE_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
index 4a6ed56..b0eadab 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iefd2_6/ia_css_iefd2_6_types.h
@@ -97,7 +97,7 @@ struct ia_css_iefd2_6_config {
 	int32_t rad_inv_r2;		   /**< Radial R^-2 normelized to (0.5..1).
 						u(8-m_rad_NF).m_rad_NF, [0,255], default 157,
 						ineffective 0 */
-	bool vssnlm_enable;		   /**< Enable bit to use VSSNLM output filter. 
+	bool vssnlm_enable;		   /**< Enable bit to use VSSNLM output filter.
 						bool, [false, true], default true, ineffective false */
 	int32_t vssnlm_x0;		   /**< Vssnlm LUT x0.
 						u8.0, [0,255], default 24, ineffective 0 */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h
index 24b2545..70e3600 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_COMMON_IO_PARAM
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h
index e9af0e6..9d29105 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/common/ia_css_common_io_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_COMMON_IO_TYPES
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h
index 9300568..a5e5f62 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_PLANE_IO_PARAM_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h
index 57ed18f..34e88d4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/io_ls/plane_io_ls/ia_css_plane_io_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_PLANE_IO_TYPES_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
index c17917d..9e41cc0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.c
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #include "ia_css_iterator.host.h"
@@ -29,6 +19,10 @@
 #define IA_CSS_INCLUDE_CONFIGURATIONS
 #include "ia_css_isp_configs.h"
 
+static const struct ia_css_iterator_configuration default_config = {
+	.input_info = (struct ia_css_frame_info *)NULL,
+};
+
 void
 ia_css_iterator_config(
 	struct sh_css_isp_iterator_isp_config *to,
@@ -48,13 +42,15 @@ ia_css_iterator_configure(
 	const struct ia_css_binary *binary,
 	const struct ia_css_frame_info *in_info)
 {
-	struct ia_css_frame_info my_info;
-	struct ia_css_iterator_configuration config = {
-		&binary->in_frame_info,
-		&binary->internal_frame_info,
-		&binary->out_frame_info[0],
-		&binary->vf_frame_info,
-		&binary->dvs_envelope };
+	struct ia_css_frame_info my_info = IA_CSS_BINARY_DEFAULT_FRAME_INFO;
+	struct ia_css_iterator_configuration config = default_config;
+
+	config.input_info    = &binary->in_frame_info;
+	config.internal_info = &binary->internal_frame_info;
+	config.output_info   = &binary->out_frame_info[0];
+	config.vf_info       = &binary->vf_frame_info;
+	config.dvs_envelope  = &binary->dvs_envelope;
+
 	/* Use in_info iso binary->in_frame_info.
 	 * They can differ in padded width in case of scaling, e.g. for capture_pp.
 	 * Find out why.
@@ -77,6 +73,8 @@ ia_css_iterator_configure(
 		my_info.res.width    <<= binary->vf_downscale_log2;
 		my_info.res.height   <<= binary->vf_downscale_log2;
 	}
-	ia_css_configure_iterator (binary, &config);
+
+	ia_css_configure_iterator(binary, &config);
+
 	return IA_CSS_SUCCESS;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
index a436a4d..d8f249c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator.host.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_ITERATOR_HOST_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
index 01b1cfd..d308126 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/iterator/iterator_1.0/ia_css_iterator_param.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef __IA_CSS_ITERATOR_PARAM_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
index ad1ab4d..3d510bf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/macc/macc1_5/ia_css_macc1_5_types.h
@@ -15,6 +15,16 @@
 #ifndef __IA_CSS_MACC1_5_TYPES_H
 #define __IA_CSS_MACC1_5_TYPES_H
 
+/** @file
+* CSS-API header file for Multi-Axis Color Conversion algorithm parameters.
+*/
+
+/** Multi-Axis Color Conversion configuration
+ *
+ * ISP2.6.1: MACC1_5 is used.
+ */
+
+
 /** Number of axes in the MACC table. */
 #define IA_CSS_MACC_NUM_AXES           16
 /** Number of coefficients per MACC axes. */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h
index ffffdac..eeaadfe 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob2/ia_css_ob2_types.h
@@ -15,6 +15,15 @@
 #ifndef __IA_CSS_OB2_TYPES_H
 #define __IA_CSS_OB2_TYPES_H
 
+/** @file
+* CSS-API header file for Optical Black algorithm parameters.
+*/
+
+/** Optical Black configuration
+ *
+ * ISP2.6.1: OB2 is used.
+ */
+
 #include "ia_css_frac.h"
 
 struct ia_css_ob2_config {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
index 5bf1e22..fd891ac 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/ob/ob_1.0/ia_css_ob.host.c
@@ -105,7 +105,7 @@ ia_css_ob_vmem_encode(
 		unsigned sp_obarea_length_bq = ob->area_length_bq;
 		unsigned low = sp_obarea_start_bq;
 		unsigned high = low + sp_obarea_length_bq;
-		unsigned all_ones = ~0U;
+		uint16_t all_ones = ~0;
 
 		for (i = 0; i < OBAREA_MASK_SIZE; i++) {
 			if (i >= low && i < high)
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/output/output_1.0/ia_css_output.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/output/output_1.0/ia_css_output.host.c
index 817fb1e..8fdf47c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/output/output_1.0/ia_css_output.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/output/output_1.0/ia_css_output.host.c
@@ -26,6 +26,18 @@ const struct ia_css_output_config default_output_config = {
 	0
 };
 
+static const struct ia_css_output_configuration default_output_configuration = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
+static const struct ia_css_output0_configuration default_output0_configuration = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
+static const struct ia_css_output1_configuration default_output1_configuration = {
+	.info = (struct ia_css_frame_info *)NULL,
+};
+
 void
 ia_css_output_encode(
 	struct sh_css_isp_output_params *to,
@@ -81,10 +93,14 @@ ia_css_output_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_output_configuration config =
-		{ info };
-	if (info)
+	if (NULL != info) {
+		struct ia_css_output_configuration config =
+				default_output_configuration;
+
+		config.info = info;
+
 		ia_css_configure_output(binary, &config);
+	}
 }
 
 void
@@ -92,10 +108,14 @@ ia_css_output0_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_output0_configuration config =
-		{ info };
-	if (info)
+	if (NULL != info) {
+		struct ia_css_output0_configuration config =
+				default_output0_configuration;
+
+		config.info = info;
+
 		ia_css_configure_output0(binary, &config);
+	}
 }
 
 void
@@ -103,10 +123,15 @@ ia_css_output1_configure(
 	const struct ia_css_binary     *binary,
 	const struct ia_css_frame_info *info)
 {
-	const struct ia_css_output1_configuration config =
-		{ info };
-	if (info)
+
+	if (NULL != info) {
+		struct ia_css_output1_configuration config =
+				default_output1_configuration;
+
+		config.info = info;
+
 		ia_css_configure_output1(binary, &config);
+	}
 }
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
index 18a22e4..d1fb4b1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/qplane/qplane_2/ia_css_qplane.host.c
@@ -23,6 +23,10 @@
 
 #include "ia_css_qplane.host.h"
 
+static const struct ia_css_qplane_configuration default_config = {
+	.pipe = (struct sh_css_sp_pipeline *)NULL,
+};
+
 void
 ia_css_qplane_config(
 	struct sh_css_isp_qplane_isp_config *to,
@@ -38,7 +42,7 @@ ia_css_qplane_config(
 	/* Assume divisiblity here, may need to generalize to fixed point. */
 	assert (elems_a % to->port_b.elems == 0);
 
-	to->inout_port_config       = from->pipe->inout_port_config;
+	to->inout_port_config = from->pipe->inout_port_config;
 	to->format = from->info->format;
 }
 
@@ -48,7 +52,10 @@ ia_css_qplane_configure(
 	const struct ia_css_binary      *binary,
 	const struct ia_css_frame_info  *info)
 {
-	const struct ia_css_qplane_configuration config =
-		{ pipe, info };
+	struct ia_css_qplane_configuration config = default_config;
+
+	config.pipe = pipe;
+	config.info = info;
+
 	ia_css_configure_qplane(binary, &config);
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
index f353ef3..68a27f0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw.host.c
@@ -24,6 +24,11 @@
 
 #include "ia_css_raw.host.h"
 
+
+static const struct ia_css_raw_configuration default_config = {
+	.pipe = (struct sh_css_sp_pipeline *)NULL,
+};
+
 static inline unsigned
 sh_css_elems_bytes_from_info (unsigned raw_bit_depth)
 {
@@ -88,21 +93,21 @@ ia_css_raw_config(
 
 #endif
 	ia_css_dma_configure_from_info(&to->port_b, in_info);
-	to->width_a_over_b = elems_a / to->port_b.elems;
 
 	/* Assume divisiblity here, may need to generalize to fixed point. */
-	assert (in_info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED ||
-		elems_a % to->port_b.elems == 0);
+	assert((in_info->format == IA_CSS_FRAME_FORMAT_RAW_PACKED) ||
+		   (elems_a % to->port_b.elems == 0));
 
-	to->inout_port_config       = from->pipe->inout_port_config;
-	to->format = in_info->format;
+	to->width_a_over_b      = elems_a / to->port_b.elems;
+	to->inout_port_config   = from->pipe->inout_port_config;
+	to->format              = in_info->format;
 	to->required_bds_factor = from->pipe->required_bds_factor;
-	to->two_ppc = from->two_ppc;
-	to->stream_format = css2isp_stream_format(from->stream_format);
-	to->deinterleaved = from->deinterleaved;
+	to->two_ppc             = from->two_ppc;
+	to->stream_format       = css2isp_stream_format(from->stream_format);
+	to->deinterleaved       = from->deinterleaved;
 #if (defined(USE_INPUT_SYSTEM_VERSION_2401) || defined(CONFIG_CSI2_PLUS))
-	to->start_column = in_info->crop_info.start_column;
-	to->start_line = in_info->crop_info.start_line;
+	to->start_column        = in_info->crop_info.start_column;
+	to->start_line          = in_info->crop_info.start_line;
 	to->enable_left_padding = from->enable_left_padding;
 #endif
 }
@@ -117,7 +122,15 @@ ia_css_raw_configure(
 	bool deinterleaved)
 {
 	uint8_t enable_left_padding = (uint8_t)((binary->left_padding) ? 1 : 0);
-	const struct ia_css_raw_configuration config =
-		{ pipe, in_info, internal_info, two_ppc, binary->input_format, deinterleaved, enable_left_padding};
+	struct ia_css_raw_configuration config = default_config;
+
+	config.pipe                = pipe;
+	config.in_info             = in_info;
+	config.internal_info       = internal_info;
+	config.two_ppc             = two_ppc;
+	config.stream_format       = binary->input_format;
+	config.deinterleaved       = deinterleaved;
+	config.enable_left_padding = enable_left_padding;
+
 	ia_css_configure_raw(binary, &config);
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
index 638e359..12168b2 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/raw/raw_1.0/ia_css_raw_param.h
@@ -30,8 +30,8 @@ struct sh_css_isp_raw_isp_config {
 	uint32_t two_ppc;
 	uint32_t stream_format; /* enum sh_stream_format */
 	uint32_t deinterleaved;
-	uint8_t start_column; /*left crop offset*/
-	uint8_t start_line; /*top crop offset*/
+	uint32_t start_column; /*left crop offset*/
+	uint32_t start_line; /*top crop offset*/
 	uint8_t enable_left_padding; /*need this for multiple binary case*/
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
index 8c29e42..f57ed1e 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/s3a/s3a_1.0/ia_css_s3a_types.h
@@ -97,7 +97,22 @@ struct ia_css_3a_grid_info {
 #endif
 };
 
+
 #if defined(SYSTEM_css_skycam_c0_system)
+#if defined USE_NEW_AE_STRUCT || defined USE_NEW_AWB_STRUCT
+#define DEFAULT_3A_GRID_INFO \
+{ \
+	0,				/* ae_enable */ \
+	{0,0,0,0,0,0,0},	        /* AE:     width,height,b_width,b_height,x_start,y_start*/ \
+	0,				/* awb_enable */ \
+	{0,0,0,0,0,0},			/* AWB:    width,height,b_width,b_height,x_start,y_start*/ \
+	0,				/* af_enable */ \
+	{0,0,0,0,0,0,0},		/* AF:     width,height,b_width,b_height,x_start,y_start,ff_en*/ \
+	0,				/* awb_fr_enable */ \
+	{0,0,0,0,0,0,0},                  /* AWB_FR: width,height,b_width,b_height,x_start,y_start,ff_en*/ \
+	0,				/* elem_bit_depth */ \
+}
+#else
 #define DEFAULT_3A_GRID_INFO \
 { \
 	0,				/* ae_enable */ \
@@ -110,6 +125,8 @@ struct ia_css_3a_grid_info {
 	{0,0,0,0,0,0,0},                  /* AWB_FR: width,height,b_width,b_height,x_start,y_start,ff_en*/ \
 	0,				/* elem_bit_depth */ \
 }
+#endif /* USE_NEW_AE_STRUCT || defined USE_NEW_AWB_STRUCT */
+
 #else
 #define DEFAULT_3A_GRID_INFO \
 { \
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h
index f0863ad..4eb4910 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common.host.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _IA_CSS_SDIS_COMMON_HOST_H
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h
index 3102975..295dc60 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/common/ia_css_sdis_common_types.h
@@ -120,16 +120,113 @@ struct ia_css_dvs_grid_info {
 	uint32_t num_ver_coefs;	/**< Number of vertical coefficients. */
 };
 
-#define DEFAULT_DVS_GRID_INFO \
+/** Number of DVS statistics levels
+ */
+#define IA_CSS_DVS_STAT_NUM_OF_LEVELS	3
+
+/** DVS statistics generated by accelerator global configuration
+ */
+struct dvs_stat_public_dvs_global_cfg {
+	unsigned char kappa;
+	/**< DVS statistics global configuration - kappa */
+	unsigned char match_shift;
+	/**< DVS statistics global configuration - match_shift */
+	unsigned char ybin_mode;
+	/**< DVS statistics global configuration - y binning mode */
+};
+
+/** DVS statistics generated by accelerator level grid
+ *  configuration
+ */
+struct dvs_stat_public_dvs_level_grid_cfg {
+	unsigned char grid_width;
+	/**< DVS statistics grid width */
+	unsigned char grid_height;
+	/**< DVS statistics grid height */
+	unsigned char block_width;
+	/**< DVS statistics block width */
+	unsigned char block_height;
+	/**< DVS statistics block  height */
+};
+
+/** DVS statistics generated by accelerator level grid start
+ *  configuration
+ */
+struct dvs_stat_public_dvs_level_grid_start {
+	unsigned short x_start;
+	/**< DVS statistics level x start */
+	unsigned short y_start;
+	/**< DVS statistics level y start */
+	unsigned char enable;
+	/**< DVS statistics level enable */
+};
+
+/** DVS statistics generated by accelerator level grid end
+ *  configuration
+ */
+struct dvs_stat_public_dvs_level_grid_end {
+	unsigned short x_end;
+	/**< DVS statistics level x end */
+	unsigned short y_end;
+	/**< DVS statistics level y end */
+};
+
+/** DVS statistics generated by accelerator Feature Extraction
+ *  Region Of Interest (FE-ROI) configuration
+ */
+struct dvs_stat_public_dvs_level_fe_roi_cfg {
+	unsigned char x_start;
+	/**< DVS statistics fe-roi level x start */
+	unsigned char y_start;
+	/**< DVS statistics fe-roi level y start */
+	unsigned char x_end;
+	/**< DVS statistics fe-roi level x end */
+	unsigned char y_end;
+	/**< DVS statistics fe-roi level y end */
+};
+
+/** DVS statistics generated by accelerator public configuration
+ */
+struct dvs_stat_public_dvs_grd_cfg {
+	struct dvs_stat_public_dvs_level_grid_cfg    grd_cfg;
+	/**< DVS statistics level grid configuration */
+	struct dvs_stat_public_dvs_level_grid_start  grd_start;
+	/**< DVS statistics level grid start configuration */
+	struct dvs_stat_public_dvs_level_grid_end    grd_end;
+	/**< DVS statistics level grid end configuration */
+};
+
+/** DVS statistics grid generated by accelerator
+ */
+struct ia_css_dvs_stat_grid_info {
+	struct dvs_stat_public_dvs_global_cfg       dvs_gbl_cfg;
+	/**< DVS statistics global configuration (kappa, match, binning) */
+	struct dvs_stat_public_dvs_grd_cfg       grd_cfg[IA_CSS_DVS_STAT_NUM_OF_LEVELS];
+	/**< DVS statistics grid configuration (blocks and grids) */
+	struct dvs_stat_public_dvs_level_fe_roi_cfg fe_roi_cfg[IA_CSS_DVS_STAT_NUM_OF_LEVELS];
+	/**< DVS statistics FE ROI (region of interest) configuration */
+};
+
+/** DVS statistics generated by accelerator default grid info
+ */
+#define DEFAULT_DVS_GRID_INFO { \
 { \
-	0,				/* enable */ \
-	0,				/* width */ \
-	0,				/* aligned_width */ \
-	0,				/* height */ \
-	0,				/* aligned_height */ \
-	0,				/* bqs_per_grid_cell */ \
-	0,				/* num_hor_coefs */ \
-	0,				/* num_ver_coefs */ \
+	{ 0, 0, 0},	/* GBL CFG reg: kappa, match_shifrt, binning mode*/ \
+	{{{0, 0, 0, 0}, {0, 0, 0}, {0, 0} }, \
+	{{0, 0, 0, 0}, {0, 0, 0}, {0, 0} }, \
+	{{0, 0, 0, 0}, {0, 0, 0}, {0, 0} } }, \
+	{{0, 0, 0, 0}, {4, 0, 0, 0}, {0, 0, 0, 0} } } \
 }
 
+
+/** Union that holds all types of DVS statistics grid info in
+ *  CSS format
+ * */
+union ia_css_dvs_grid_u {
+	struct ia_css_dvs_stat_grid_info dvs_stat_grid_info;
+	/**< DVS statistics produced by accelerator grid info */
+	struct ia_css_dvs_grid_info dvs_grid_info;
+	/**< DVS (DVS1/DVS2) grid info */
+};
+
 #endif /* __IA_CSS_SDIS_COMMON_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
index c899c6d..0dde842 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_1.0/ia_css_sdis.host.c
@@ -40,18 +40,19 @@ void ia_css_sdis_horicoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_width = from->grid.aligned_width * from->grid.bqs_per_grid_cell;
-	unsigned	 width = from->grid.num_hor_coefs;
+	unsigned width         = from->grid.num_hor_coefs;
 	int      padding       = aligned_width-width;
-	unsigned stride	       = size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
+	unsigned stride        = size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
 	unsigned total_bytes   = aligned_width*IA_CSS_DVS_NUM_COEF_TYPES*sizeof(short);
+	short   *public        = from->hor_coefs;
+	short   *private       = (short*)to;
 	unsigned type;
-	short *public  = from->hor_coefs;
-	short *private = (short*)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
 	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES*ISP_VEC_NELEMS*sizeof(short)) == 0);
+
 	for (type = 0; type < IA_CSS_DVS_NUM_COEF_TYPES; type++) {
 		fill_row(&private[type*stride], &public[type*width], width, padding);
 	}
@@ -63,18 +64,19 @@ void ia_css_sdis_vertcoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_height = from->grid.aligned_height * from->grid.bqs_per_grid_cell;
-	unsigned	 height = from->grid.num_ver_coefs;
-	int      padding	= aligned_height-height;
-	unsigned stride		= size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
-	unsigned total_bytes	= aligned_height*IA_CSS_DVS_NUM_COEF_TYPES*sizeof(short);
+	unsigned height         = from->grid.num_ver_coefs;
+	int      padding        = aligned_height-height;
+	unsigned stride         = size/IA_CSS_DVS_NUM_COEF_TYPES/sizeof(short);
+	unsigned total_bytes    = aligned_height*IA_CSS_DVS_NUM_COEF_TYPES*sizeof(short);
+	short   *public         = from->ver_coefs;
+	short   *private        = (short*)to;
 	unsigned type;
-	short *public  = from->ver_coefs;
-	short *private = (short*)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
 	assert(total_bytes <= size);
 	assert(size % (IA_CSS_DVS_NUM_COEF_TYPES*ISP_VEC_NELEMS*sizeof(short)) == 0);
+
 	for (type = 0; type < IA_CSS_DVS_NUM_COEF_TYPES; type++) {
 		fill_row(&private[type*stride], &public[type*height], height, padding);
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
index 270c723..930061d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/sdis/sdis_2/ia_css_sdis2.host.c
@@ -36,11 +36,11 @@ void ia_css_sdis2_horicoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_width = from->grid.aligned_width * from->grid.bqs_per_grid_cell;
-	unsigned	 width = from->grid.num_hor_coefs;
+	unsigned width         = from->grid.num_hor_coefs;
 	int      padding       = aligned_width-width;
-	unsigned stride	       = size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
+	unsigned stride        = size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
 	unsigned total_bytes   = aligned_width*IA_CSS_DVS2_NUM_COEF_TYPES*sizeof(short);
-	short *private = (short*)to;
+	short   *private       = (short*)to;
 
 
 	/* Copy the table, add padding */
@@ -59,11 +59,11 @@ void ia_css_sdis2_vertcoef_vmem_encode (
 	unsigned size)
 {
 	unsigned aligned_height = from->grid.aligned_height * from->grid.bqs_per_grid_cell;
-	unsigned	 height = from->grid.num_ver_coefs;
-	int      padding	= aligned_height-height;
-	unsigned stride		= size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
-	unsigned total_bytes	= aligned_height*IA_CSS_DVS2_NUM_COEF_TYPES*sizeof(short);
-	short *private = (short*)to;
+	unsigned height         = from->grid.num_ver_coefs;
+	int      padding        = aligned_height-height;
+	unsigned stride         = size/IA_CSS_DVS2_NUM_COEF_TYPES/sizeof(short);
+	unsigned total_bytes    = aligned_height*IA_CSS_DVS2_NUM_COEF_TYPES*sizeof(short);
+	short   *private        = (short*)to;
 
 	/* Copy the table, add padding */
 	assert(padding >= 0);
@@ -114,12 +114,12 @@ void ia_css_get_isp_dvs2_coefficients(
 	IA_CSS_ENTER("void");
 
 	assert(stream != NULL);
-	assert(hor_coefs_odd_real != NULL);
-	assert(hor_coefs_odd_imag != NULL);
+	assert(hor_coefs_odd_real  != NULL);
+	assert(hor_coefs_odd_imag  != NULL);
 	assert(hor_coefs_even_real != NULL);
 	assert(hor_coefs_even_imag != NULL);
-	assert(ver_coefs_odd_real != NULL);
-	assert(ver_coefs_odd_imag != NULL);
+	assert(ver_coefs_odd_real  != NULL);
+	assert(ver_coefs_odd_imag  != NULL);
 	assert(ver_coefs_even_real != NULL);
 	assert(ver_coefs_even_imag != NULL);
 
@@ -150,12 +150,12 @@ void ia_css_get_isp_dvs2_coefficients(
 void ia_css_sdis2_clear_coefficients(
 	struct ia_css_dvs2_coefficients *dvs2_coefs)
 {
-	dvs2_coefs->hor_coefs.odd_real = NULL;
-	dvs2_coefs->hor_coefs.odd_imag = NULL;
+	dvs2_coefs->hor_coefs.odd_real  = NULL;
+	dvs2_coefs->hor_coefs.odd_imag  = NULL;
 	dvs2_coefs->hor_coefs.even_real = NULL;
 	dvs2_coefs->hor_coefs.even_imag = NULL;
-	dvs2_coefs->ver_coefs.odd_real = NULL;
-	dvs2_coefs->ver_coefs.odd_imag = NULL;
+	dvs2_coefs->ver_coefs.odd_real  = NULL;
+	dvs2_coefs->ver_coefs.odd_imag  = NULL;
 	dvs2_coefs->ver_coefs.even_real = NULL;
 	dvs2_coefs->ver_coefs.even_imag = NULL;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
index d8324fe..e775af5 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf.host.c
@@ -37,8 +37,8 @@ ia_css_tdf_vmem_encode(
 
 	for (i = 0; i < ISP_VEC_NELEMS; i++) {
 		to->pyramid[0][i]          = g_pyramid[i/8][i%8];
-		to->threshold_flat[0][i]   = from->TdfThres_flat_table[i];
-		to->threshold_detail[0][i] = from->TdfThres_detail_table[i];
+		to->threshold_flat[0][i]   = from->thres_flat_table[i];
+		to->threshold_detail[0][i] = from->thres_detail_table[i];
 	}
 
 }
@@ -50,19 +50,19 @@ ia_css_tdf_encode(
 	size_t size)
 {
 	(void)size;
-	to->Epsilon_0        = from->TdfEpsilon_0;
-	to->Epsilon_1        = from->TdfEpsilon_1;
-	to->EpsScaleText     = from->TdfEpsScaleText;
-	to->EpsScaleEdge     = from->TdfEpsScaleEdge;
-	to->Sepa_flat 	     = from->TdfSepa_flat;
-	to->Sepa_Edge 	     = from->TdfSepa_Edge;
-	to->Blend_Flat 	     = from->TdfBlend_Flat;
-	to->Blend_Text 	     = from->TdfBlend_Text;
-	to->Blend_Edge 	     = from->TdfBlend_Edge;
-	to->Shading_Gain     = from->TdfShading_Gain;
-	to->Shading_baseGain = from->TdfShading_baseGain;
-	to->LocalY_Gain      = from->TdfLocalY_Gain;
-	to->LocalY_baseGain  = from->TdfLocalY_baseGain;
+	to->Epsilon_0        = from->epsilon_0;
+	to->Epsilon_1        = from->epsilon_1;
+	to->EpsScaleText     = from->eps_scale_text;
+	to->EpsScaleEdge     = from->eps_scale_edge;
+	to->Sepa_flat	     = from->sepa_flat;
+	to->Sepa_Edge	     = from->sepa_edge;
+	to->Blend_Flat	     = from->blend_flat;
+	to->Blend_Text	     = from->blend_text;
+	to->Blend_Edge	     = from->blend_edge;
+	to->Shading_Gain     = from->shading_gain;
+	to->Shading_baseGain = from->shading_base_gain;
+	to->LocalY_Gain      = from->local_y_gain;
+	to->LocalY_baseGain  = from->local_y_base_gain;
 }
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c
index 2944820..9bb42da 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_default.host.c
@@ -15,20 +15,22 @@
 #include "ia_css_tdf_types.h"
 
 const struct ia_css_tdf_config default_tdf_config = {
-	.TdfThres_flat_table = {0},
-	.TdfThres_detail_table = {0},
-	.TdfEpsilon_0 = 4095,
-	.TdfEpsilon_1 = 5733,
-	.TdfEpsScaleText = 409,
-	.TdfEpsScaleEdge = 3686,
-	.TdfSepa_flat = 1294,
-	.TdfSepa_Edge = 4095,
-	.TdfBlend_Flat = 819,
-	.TdfBlend_Text = 819,
-	.TdfBlend_Edge = 8191,
-	.TdfShading_Gain = 1024,
-	.TdfShading_baseGain = 8191,
-	.TdfLocalY_Gain = 0,
-	.TdfLocalY_baseGain = 2047
+	.thres_flat_table = {0},
+	.thres_detail_table = {0},
+	.epsilon_0 = 4095,
+	.epsilon_1 = 5733,
+	.eps_scale_text = 409,
+	.eps_scale_edge = 3686,
+	.sepa_flat = 1294,
+	.sepa_edge = 4095,
+	.blend_flat = 819,
+	.blend_text = 819,
+	.blend_edge = 8191,
+	.shading_gain = 1024,
+	.shading_base_gain = 8191,
+	.local_y_gain = 0,
+	.local_y_base_gain = 2047,
+	.rad_x_origin = 0,
+	.rad_y_origin = 0
 };
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
index 7a5f940..cc47a50 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/tdf/tdf_1.0/ia_css_tdf_types.h
@@ -15,24 +15,38 @@
 #ifndef __IA_CSS_TDF_TYPES_H
 #define __IA_CSS_TDF_TYPES_H
 
+/** @file
+* CSS-API header file for Transform Domain Filter parameters.
+*/
+
 #include "type_support.h"
 
+/** Transform Domain Filter configuration
+ *
+ * \brief TDF public parameters.
+ * \details Struct with all parameters for the TDF kernel that can be set
+ * from the CSS API.
+ *
+ * ISP2.6.1: TDF is used.
+ */
 struct ia_css_tdf_config {
-	int32_t TdfThres_flat_table[64];
-	int32_t TdfThres_detail_table[64];
-	int32_t TdfEpsilon_0;
-	int32_t TdfEpsilon_1;
-	int32_t TdfEpsScaleText;
-	int32_t TdfEpsScaleEdge;
-	int32_t TdfSepa_flat;
-	int32_t TdfSepa_Edge;
-	int32_t TdfBlend_Flat;
-	int32_t TdfBlend_Text;
-	int32_t TdfBlend_Edge;
-	int32_t TdfShading_Gain;
-	int32_t TdfShading_baseGain;
-	int32_t TdfLocalY_Gain;
-	int32_t TdfLocalY_baseGain;
+	int32_t thres_flat_table[64];	/**< Final optimized strength table of NR for flat region. */
+	int32_t thres_detail_table[64];	/**< Final optimized strength table of NR for detail region. */
+	int32_t epsilon_0;		/**< Coefficient to control variance for dark area (for flat region). */
+	int32_t epsilon_1;		/**< Coefficient to control variance for bright area (for flat region). */
+	int32_t eps_scale_text;		/**< Epsilon scaling coefficient for texture region. */
+	int32_t eps_scale_edge;		/**< Epsilon scaling coefficient for edge region. */
+	int32_t sepa_flat;		/**< Threshold to judge flat (edge < m_Flat_thre). */
+	int32_t sepa_edge;		/**< Threshold to judge edge (edge > m_Edge_thre). */
+	int32_t blend_flat;		/**< Blending ratio at flat region. */
+	int32_t blend_text;		/**< Blending ratio at texture region. */
+	int32_t blend_edge;		/**< Blending ratio at edge region. */
+	int32_t shading_gain;		/**< Gain of Shading control. */
+	int32_t shading_base_gain;	/**< Base Gain of Shading control. */
+	int32_t local_y_gain;		/**< Gain of local luminance control. */
+	int32_t local_y_base_gain;	/**< Base gain of local luminance control. */
+	int32_t rad_x_origin;		/**< Initial x coord. for radius computation. */
+	int32_t rad_y_origin;		/**< Initial y coord. for radius computation. */
 };
 
 #endif /* __IA_CSS_TDF_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c
new file mode 100644
index 0000000..7e86bc8
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.c
@@ -0,0 +1,155 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include "type_support.h"
+#include "math_support.h"
+#include "sh_css_defs.h"
+#include "assert_support.h"
+#include "ia_css_xnr3_0_11.host.h"
+
+/*
+ * XNR 3.0.11 division look-up table
+ */
+#define XNR3_0_11_LOOK_UP_TABLE_POINTS 16
+
+static const int16_t x[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+512, 637, 782, 952, 1147, 1372, 1627, 1917, 2242,
+2597, 2992, 3427, 3907, 4432, 5007, 5632};
+
+static const int16_t a[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+-6587, -4309, -2886, -1970, -1362, -7710, -5508,
+-4008, -2931, -2219, -1676, -1280, -999, -769, -616, 0};
+
+static const int16_t b[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+4096, 3292, 2682, 2203, 1828, 1529, 1289, 1094,
+935, 808, 701, 612, 537, 473, 419, 372};
+
+static const int16_t c[XNR3_0_11_LOOK_UP_TABLE_POINTS] = {
+1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+
+/*
+ * Default kernel parameters (weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+ */
+const struct ia_css_xnr3_0_11_config default_xnr3_0_11_config = {
+	7, 7, 7, 7, 7, 2 };
+
+
+/* (void) = ia_css_xnr3_0_11_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_11_vmem_encode(
+	struct sh_css_isp_xnr3_0_11_vmem_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size)
+{
+	unsigned i, j, base;
+	const unsigned total_blocks = 4;
+	const unsigned shuffle_block = 16;
+
+	(void)from;
+	(void)size;
+
+	/* Init */
+	for (i = 0; i < ISP_VEC_NELEMS; i++) {
+		to->x[0][i] = 0;
+		to->a[0][i] = 0;
+		to->b[0][i] = 0;
+		to->c[0][i] = 0;
+	}
+
+
+	/* Constraints on "x":
+	 * - values should be greater or equal to 0.
+	 * - values should be ascending.
+	 */
+	assert(x[0] >= 0);
+
+	for (j = 1; j < XNR3_0_11_LOOK_UP_TABLE_POINTS; j++) {
+		assert(x[j] >= 0);
+		assert(x[j] > x[j-1]);
+
+	}
+
+
+	/* The implementation of the calulating 1/x is based on the availability
+	 * of the OP_vec_shuffle16 operation.
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* TODO: guard this code with above assumptions */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block * i;
+
+		for (j = 0; j < XNR3_0_11_LOOK_UP_TABLE_POINTS; j++) {
+			to->x[0][base + j] = x[j];
+			to->a[0][base + j] = a[j];
+			to->b[0][base + j] = b[j];
+			to->c[0][base + j] = c[j];
+		}
+	}
+
+}
+
+
+
+/* (void) = ia_css_xnr3_0_11_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void
+ia_css_xnr3_0_11_encode(
+	struct sh_css_isp_xnr3_0_11_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size)
+{
+	int kernel_size = XNR_FILTER_SIZE;
+	/* The adjust factor is the next power of 2
+	   w.r.t. the kernel size*/
+	int adjust_factor = ceil_pow2(kernel_size);
+
+	int32_t weight_y0 = from->weight_y0;
+	int32_t weight_y1 = from->weight_y1;
+	int32_t weight_u0 = from->weight_u0;
+	int32_t weight_u1 = from->weight_u1;
+	int32_t weight_v0 = from->weight_v0;
+	int32_t weight_v1 = from->weight_v1;
+
+	(void)size;
+
+	to->weight_y0 = weight_y0;
+	to->weight_u0 = weight_u0;
+	to->weight_v0 = weight_v0;
+	to->weight_ydiff = (weight_y1 - weight_y0) * adjust_factor / kernel_size;
+	to->weight_udiff = (weight_u1 - weight_u0) * adjust_factor / kernel_size;
+	to->weight_vdiff = (weight_v1 - weight_v0) * adjust_factor / kernel_size;
+}
+
+/* (void) = ia_css_xnr3_0_11_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_11_debug_dtrace(
+	const struct ia_css_xnr3_0_11_config *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h
new file mode 100644
index 0000000..8e8b85f
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11.host.h
@@ -0,0 +1,58 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_11_HOST_H
+#define __IA_CSS_XNR3_0_11_HOST_H
+
+#include "ia_css_xnr3_0_11_param.h"
+#include "ia_css_xnr3_0_11_types.h"
+
+/*
+ * Default kernel parameters (weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+ */
+extern const struct ia_css_xnr3_0_11_config default_xnr3_0_11_config;
+
+
+/* (void) = ia_css_xnr3_0_11_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_11_vmem_encode(
+	struct sh_css_isp_xnr3_0_11_vmem_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_11_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void
+ia_css_xnr3_0_11_encode(
+	struct sh_css_isp_xnr3_0_11_params *to,
+	const struct ia_css_xnr3_0_11_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_11_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_11_debug_dtrace(
+	const struct ia_css_xnr3_0_11_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_XNR3_0_11_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h
new file mode 100644
index 0000000..a28cfd4
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_param.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_11_PARAM_H
+#define __IA_CSS_XNR3_0_11_PARAM_H
+
+#include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+/* XNR3.0.11 filter size */
+#define XNR_FILTER_SIZE             11
+
+/*
+ * STRUCT sh_css_isp_xnr3_0_11_vmem_params
+ * -----------------------------------------------
+ * XNR3.0.11 ISP VMEM parameters
+ */
+struct sh_css_isp_xnr3_0_11_vmem_params {
+	VMEM_ARRAY(x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(c, ISP_VEC_NELEMS);
+};
+
+ /*
+ * STRUCT sh_css_isp_xnr3_0_11_params
+ * -----------------------------------------------
+ * XNR3.0.11 ISP parameters
+ */
+struct sh_css_isp_xnr3_0_11_params {
+	int32_t weight_y0;
+	int32_t weight_u0;
+	int32_t weight_v0;
+	int32_t weight_ydiff;
+	int32_t weight_udiff;
+	int32_t weight_vdiff;
+};
+
+#endif  /*__IA_CSS_XNR3_0_11_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h
new file mode 100644
index 0000000..b6bf449
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_11/ia_css_xnr3_0_11_types.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_11_TYPES_H
+#define __IA_CSS_XNR3_0_11_TYPES_H
+
+ /*
+ * STRUCT ia_css_xnr3_0_11_config
+ * -----------------------------------------------
+ * Struct with all parameters for the XNR3.0.11 kernel that can be set
+ * from the CSS API
+ */
+struct ia_css_xnr3_0_11_config {
+	int32_t weight_y0;     /**< Weight for Y range similarity in dark area */
+	int32_t weight_y1;     /**< Weight for Y range similarity in bright area */
+	int32_t weight_u0;     /**< Weight for U range similarity in dark area */
+	int32_t weight_u1;     /**< Weight for U range similarity in bright area */
+	int32_t weight_v0;     /**< Weight for V range similarity in dark area */
+	int32_t weight_v1;     /**< Weight for V range similarity in bright area */
+};
+
+#endif /* __IA_CSS_XNR3_0_11_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c
new file mode 100644
index 0000000..d29b314
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.c
@@ -0,0 +1,154 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include "type_support.h"
+#include "math_support.h"
+#include "sh_css_defs.h"
+#include "assert_support.h"
+#include "ia_css_xnr3_0_5.host.h"
+
+/*
+ * XNR 3.0.5 division look-up table
+ */
+#define XNR3_0_5_LOOK_UP_TABLE_POINTS 16
+
+static const int16_t x[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+1024, 1164, 1320, 1492, 1680, 1884, 2108, 2352,
+2616, 2900, 3208, 3540, 3896, 4276, 4684, 5120};
+
+static const int16_t a[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+-7213, -5580, -4371, -3421, -2722, -2159, -6950, -5585,
+-4529, -3697, -3010, -2485, -2070, -1727, -1428, 0};
+
+static const int16_t b[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+4096, 3603, 3178, 2811, 2497, 2226, 1990, 1783,
+1603, 1446, 1307, 1185, 1077, 981, 895, 819};
+
+static const int16_t c[XNR3_0_5_LOOK_UP_TABLE_POINTS] = {
+1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
+
+/*
+ * Default kernel parameters(weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+ */
+const struct ia_css_xnr3_0_5_config default_xnr3_0_5_config = {
+	8191, 8191, 8191, 8191, 8191, 8191 };
+
+
+/* (void) = ia_css_xnr3_0_5_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_5_vmem_encode(
+	struct sh_css_isp_xnr3_0_5_vmem_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size)
+{
+	unsigned i, j, base;
+	const unsigned total_blocks = 4;
+	const unsigned shuffle_block = 16;
+
+	(void)from;
+	(void)size;
+
+	/* Init */
+	for (i = 0; i < ISP_VEC_NELEMS; i++) {
+		to->x[0][i] = 0;
+		to->a[0][i] = 0;
+		to->b[0][i] = 0;
+		to->c[0][i] = 0;
+	}
+
+
+	/* Constraints on "x":
+	 * - values should be greater or equal to 0.
+	 * - values should be ascending.
+	 */
+	assert(x[0] >= 0);
+
+	for (j = 1; j < XNR3_0_5_LOOK_UP_TABLE_POINTS; j++) {
+		assert(x[j] >= 0);
+		assert(x[j] > x[j-1]);
+
+	}
+
+
+	/* The implementation of the calulating 1/x is based on the availability
+	 * of the OP_vec_shuffle16 operation.
+	 * A 64 element vector is split up in 4 blocks of 16 element. Each array is copied to
+	 * a vector 4 times, (starting at 0, 16, 32 and 48). All array elements are copied or
+	 * initialised as described in the KFS. The remaining elements of a vector are set to 0.
+	 */
+	/* TODO: guard this code with above assumptions */
+	for(i = 0; i < total_blocks; i++) {
+		base = shuffle_block * i;
+
+		for (j = 0; j < XNR3_0_5_LOOK_UP_TABLE_POINTS; j++) {
+			to->x[0][base + j] = x[j];
+			to->a[0][base + j] = a[j];
+			to->b[0][base + j] = b[j];
+			to->c[0][base + j] = c[j];
+		}
+	}
+
+}
+
+
+
+/* (void) = ia_css_xnr3_0_5_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+ */
+void
+ia_css_xnr3_0_5_encode(
+	struct sh_css_isp_xnr3_0_5_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size)
+{
+	int kernel_size = XNR_FILTER_SIZE;
+	/* The adjust factor is the next power of 2
+	   w.r.t. the kernel size*/
+	int adjust_factor = ceil_pow2(kernel_size);
+
+	int32_t weight_y0 = from->weight_y0;
+	int32_t weight_y1 = from->weight_y1;
+	int32_t weight_u0 = from->weight_u0;
+	int32_t weight_u1 = from->weight_u1;
+	int32_t weight_v0 = from->weight_v0;
+	int32_t weight_v1 = from->weight_v1;
+
+	(void)size;
+
+	to->weight_y0 = weight_y0;
+	to->weight_u0 = weight_u0;
+	to->weight_v0 = weight_v0;
+	to->weight_ydiff = (weight_y1 - weight_y0) * adjust_factor / kernel_size;
+	to->weight_udiff = (weight_u1 - weight_u0) * adjust_factor / kernel_size;
+	to->weight_vdiff = (weight_v1 - weight_v0) * adjust_factor / kernel_size;
+}
+
+/* (void) = ia_css_xnr3_0_5_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_5_debug_dtrace(
+	const struct ia_css_xnr3_0_5_config *config,
+	unsigned level)
+{
+	(void)config;
+	(void)level;
+}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h
new file mode 100644
index 0000000..69817a6
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5.host.h
@@ -0,0 +1,59 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_5_HOST_H
+#define __IA_CSS_XNR3_0_5_HOST_H
+
+#include "ia_css_xnr3_0_5_param.h"
+#include "ia_css_xnr3_0_5_types.h"
+
+/*
+ * Default kernel parameters (weights). In general, default is bypass mode or as close
+ * to the ineffective values as possible. Due to the chroma down+upsampling,
+ * perfect bypass mode is not possible for xnr3.
+*/
+extern const struct ia_css_xnr3_0_5_config default_xnr3_0_5_config;
+
+
+
+/* (void) = ia_css_xnr3_0_5_vmem_encode(*to, *from)
+ * -----------------------------------------------
+ * VMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_5_vmem_encode(
+	struct sh_css_isp_xnr3_0_5_vmem_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_5_encode(*to, *from)
+ * -----------------------------------------------
+ * DMEM Encode Function to translate UV parameters from userspace into ISP space
+*/
+void
+ia_css_xnr3_0_5_encode(
+	struct sh_css_isp_xnr3_0_5_params *to,
+	const struct ia_css_xnr3_0_5_config *from,
+	unsigned size);
+
+/* (void) = ia_css_xnr3_0_5_debug_dtrace(*config, level)
+ * -----------------------------------------------
+ * Dummy Function added as the tool expects it
+ */
+void
+ia_css_xnr3_0_5_debug_dtrace(
+	const struct ia_css_xnr3_0_5_config *config,
+	unsigned level);
+
+#endif /* __IA_CSS_XNR3_0_5_HOST_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h
new file mode 100644
index 0000000..fc1d9cc
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_param.h
@@ -0,0 +1,50 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_5_PARAM_H
+#define __IA_CSS_XNR3_0_5_PARAM_H
+
+#include "type_support.h"
+#include "vmem.h" /* needed for VMEM_ARRAY */
+
+/* XNR3.0.5 filter size */
+#define XNR_FILTER_SIZE             5
+
+/*
+ * STRUCT sh_css_isp_xnr3_0_5_vmem_params
+ * -----------------------------------------------
+ * XNR3.0.5 ISP VMEM parameters
+ */
+struct sh_css_isp_xnr3_0_5_vmem_params {
+	VMEM_ARRAY(x, ISP_VEC_NELEMS);
+	VMEM_ARRAY(a, ISP_VEC_NELEMS);
+	VMEM_ARRAY(b, ISP_VEC_NELEMS);
+	VMEM_ARRAY(c, ISP_VEC_NELEMS);
+};
+
+/*
+ * STRUCT sh_css_isp_xnr3_0_5_params
+ * -----------------------------------------------
+ * XNR3.0.5 ISP parameters
+ */
+struct sh_css_isp_xnr3_0_5_params {
+	int32_t weight_y0;
+	int32_t weight_u0;
+	int32_t weight_v0;
+	int32_t weight_ydiff;
+	int32_t weight_udiff;
+	int32_t weight_vdiff;
+};
+
+#endif  /*__IA_CSS_XNR3_0_5_PARAM_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h
new file mode 100644
index 0000000..ba7c81e
--- /dev/null
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr3_0_5/ia_css_xnr3_0_5_types.h
@@ -0,0 +1,33 @@
+/*
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __IA_CSS_XNR3_0_5_TYPES_H
+#define __IA_CSS_XNR3_0_5_TYPES_H
+
+/*
+ * STRUCT ia_css_xnr3_0_5_config
+ * -----------------------------------------------
+ * Struct with all parameters for the XNR3.0.5 kernel that can be set
+ * from the CSS API
+*/
+struct ia_css_xnr3_0_5_config {
+	int32_t weight_y0;     /**< Weight for Y range similarity in dark area */
+	int32_t weight_y1;     /**< Weight for Y range similarity in bright area */
+	int32_t weight_u0;     /**< Weight for U range similarity in dark area */
+	int32_t weight_u1;     /**< Weight for U range similarity in bright area */
+	int32_t weight_v0;     /**< Weight for V range similarity in dark area */
+	int32_t weight_v1;     /**< Weight for V range similarity in bright area */
+};
+
+#endif /* __IA_CSS_XNR3_0_5_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
index 8149303..3018100 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_1.0/ia_css_xnr.host.c
@@ -42,9 +42,9 @@ ia_css_xnr_encode(
 	unsigned size)
 {
 	(void)size;
-	
+
 	to->threshold =
-		uDIGIT_FITTING(from->threshold, 16, SH_CSS_ISP_YUV_BITS);
+		(uint16_t)uDIGIT_FITTING(from->threshold, 16, SH_CSS_ISP_YUV_BITS);
 }
 
 void
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
index a630a2c..b56d9fd 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3.host.c
@@ -34,7 +34,9 @@ const struct ia_css_xnr3_config default_xnr3_config = {
 	/* sigma */
 	{ 0, 0, 0, 0, 0, 0 },
 	/* coring */
-	{ 0, 0, 0, 0 }
+	{ 0, 0, 0, 0 },
+	/* blending */
+	{ 0 }
 };
 
 /*
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
index 8ddd266..8f14d10 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/kernels/xnr/xnr_3.0/ia_css_xnr3_types.h
@@ -31,6 +31,12 @@
  */
 #define IA_CSS_XNR3_CORING_SCALE (1 << 15)
 
+/**
+ * \brief Scale of the XNR blending parameter.
+ * \details The define specifies which fixed-point value represents 1.0.
+ */
+#define IA_CSS_XNR3_BLENDING_SCALE (1 << 11)
+
 
 /**
  * \brief XNR3 Sigma Parameters.
@@ -65,13 +71,28 @@ struct ia_css_xnr3_coring_params {
 };
 
 /**
+ * \brief XNR3 Blending Parameters
+ * \details Blending parameters define the blending strength of filtered
+ * output pixels with the original chroma pixels from before xnr3. The
+ * blending strength is a fixed-point value between 0.0 and 1.0 (inclusive),
+ * scaled with IA_CSS_XNR3_BLENDING_SCALE.
+ * A higher number applies xnr filtering more strongly. A value of 1.0
+ * disables the blending and returns the xnr3 filtered output, while a
+ * value of 0.0 bypasses the entire xnr3 filter.
+ */
+struct ia_css_xnr3_blending_params {
+	int strength;   /**< Blending strength */
+};
+
+/**
  * \brief XNR3 public parameters.
  * \details Struct with all parameters for the XNR3 kernel that can be set
  * from the CSS API.
  */
 struct ia_css_xnr3_config {
-	struct ia_css_xnr3_sigma_params  sigma;   /**< XNR3 sigma parameters */
-	struct ia_css_xnr3_coring_params coring;  /**< XNR3 coring parameters */
+	struct ia_css_xnr3_sigma_params    sigma;    /**< XNR3 sigma parameters */
+	struct ia_css_xnr3_coring_params   coring;   /**< XNR3 coring parameters */
+	struct ia_css_xnr3_blending_params blending; /**< XNR3 blending parameters */
 };
 
 #endif /* __IA_CSS_XNR3_TYPES_H */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h
index ea9fb1d..b1ce736 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_const.h
@@ -1,26 +1,17 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2015 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
+
 #ifndef _COMMON_ISP_CONST_H_
 #define _COMMON_ISP_CONST_H_
 
@@ -113,15 +104,8 @@
 #define SH_CSS_BINARY_ID_ACCELERATION           57
 #define SH_CSS_BINARY_ID_PRE_DE_ISP2            58
 #define SH_CSS_BINARY_ID_KERNEL_TEST_LOAD_STORE 59
-
-/* skycam product pipelines */
-#define SH_CSS_BINARY_ID_PRIMARY                            101
-#define SH_CSS_BINARY_ID_PRIMARY_PP                         102
-#define SH_CSS_BINARY_ID_VIDEO                              103
-#define SH_CSS_BINARY_ID_SC_VIDEO_HIGH_RESOLUTION           104
-#define SH_CSS_BINARY_ID_VIDEO_C0                           105
-#define SH_CSS_BINARY_ID_SC_VIDEO_C0_HIGH_RESOLUTION        106
-#define SH_CSS_BINARY_ID_SC_VIDEO_HIRES                     107
+#define SH_CSS_BINARY_ID_CAPTURE_PP_BLI         60
+#define SH_CSS_BINARY_ID_CAPTURE_PP_LDC         61
 
 /* skycam kerneltest pipelines */
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_NORM              120
@@ -142,7 +126,6 @@
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR               136
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_XNR_STRIPED       137
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_TNR_BLOCK         139
-#define SH_CSS_BINARY_ID_VIDEO_PARTIALPIPE_INPUTCOR_FULL    140
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_ACC_AE            141
 #define SH_CSS_BINARY_ID_VIDEO_RAW                          142
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_ACC_AWB_FR        143
@@ -155,7 +138,6 @@
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_TNR_STRIPED       150
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_DVS_STRIPED       151
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_OBGRID_STRIPED    152
-#define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_BDS_DVS_STRIPED   153
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_COPY_YUV          155
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_COPY_YUV_BLOCK    156
 #define SH_CSS_BINARY_ID_VIDEO_KERNELTEST_COPY_YUV16_BLOCK  157
@@ -169,7 +151,6 @@
 
 
 /* skycam partial test pipelines*/
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_DVS              199
 #define SH_CSS_BINARY_ID_IF_TO_DPC                          201
 #define SH_CSS_BINARY_ID_IF_TO_BDS                          202
 #define SH_CSS_BINARY_ID_IF_TO_NORM                         203
@@ -177,24 +158,16 @@
 #define SH_CSS_BINARY_ID_IF_TO_LIN                          205
 #define SH_CSS_BINARY_ID_IF_TO_SHD                          206
 #define SH_CSS_BINARY_ID_IF_TO_BNR                          207
-#define SH_CSS_BINARY_ID_IF_TO_DM_WO_ANR_STATS              208
-#define SH_CSS_BINARY_ID_IF_TO_DM_3A_WO_ANR                 209
 #define SH_CSS_BINARY_ID_IF_TO_RGBPP                        210
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1                        211
-#define SH_CSS_BINARY_ID_IF_TO_DM_WO_STATS                  213
 #define SH_CSS_BINARY_ID_IF_TO_DM                           214
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_C0                     216
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_ANR_VIA_ISP            217
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_DVS                    218
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_TNR                    219
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_BNR_STRIPED        220
 #define SH_CSS_BINARY_ID_IF_TO_BDS_STRIPED                  224
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_ANR_STRIPED         225
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AWB_BNR_STRIPED    226
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_YUVP2_STRIPED       227
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AF_BNR_STRIPED     228
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AWBFR_BNR_STRIPED  229
-#define SH_CSS_BINARY_ID_IF_NORM_LIN_SHD_AE_BNR_STRIPED     232
 #define SH_CSS_BINARY_ID_IF_TO_REF                          236
 #define SH_CSS_BINARY_ID_IF_TO_DVS_STRIPED                  237
 #define SH_CSS_BINARY_ID_IF_TO_YUVP2_STRIPED                238
@@ -206,34 +179,18 @@
 #define SH_CSS_BINARY_ID_IF_TO_LIN_STRIPED                  244
 #define SH_CSS_BINARY_ID_IF_TO_OB_STRIPED                   245
 #define SH_CSS_BINARY_ID_IF_TO_NORM_STRIPED                 248
-#define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_STATS_C0          251
-#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE            252
 #define SH_CSS_BINARY_ID_COPY_KERNELTEST_OUTPUT_SYSTEM      253
-#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE_C0         254
-#define SH_CSS_BINARY_ID_SC_PRIMARY_SINGLE_STAGE_HR         255
 #define SH_CSS_BINARY_ID_IF_TO_XNR                          256
 #define SH_CSS_BINARY_ID_IF_TO_XNR_STRIPED                  257
 #define SH_CSS_BINARY_ID_IF_TO_REF_STRIPED                  258
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS                   259
-#define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_C0_STRIPED        260
-#define SH_CSS_BINARY_ID_IF_TO_TNR_NO_DVS_C0                261
 #define SH_CSS_BINARY_ID_IF_TO_YUVP1_C0                     262
 #define SH_CSS_BINARY_ID_IF_TO_XNR_PRIMARY                  263
 #define SH_CSS_BINARY_ID_IF_TO_XNR_PRIMARY_STRIPED          264
 #define SH_CSS_BINARY_ID_IF_TO_ANR                          265
 #define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_DVS_STAT_C0         266
-#define SH_CSS_BINARY_ID_VIDEO_TEST_ACC_LACE_STAT_C0        267
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR                  268
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_STRIPED          269
 #define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_STRIPED           270
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_DVS_STRIPED      271
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_NO_TNR     272
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_NO_TNR_STRIPED 273
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS            274
-#define SH_CSS_BINARY_ID_VIDEO_IF_TO_OSYS_NO_DVS_STRIPED    275
 #define SH_CSS_BINARY_ID_IF_TO_OSYS_PRIMARY                 276
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_PRIMARY          277
-#define SH_CSS_BINARY_ID_IF_TO_OSYS_NO_XNR_PRIMARY_STRIPED  278
 #define SH_CSS_BINARY_ID_IF_TO_OSYS_PRIMARY_STRIPED         279
 
 #define XMEM_WIDTH_BITS              HIVE_ISP_DDR_WORD_BITS
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_exprs.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_exprs.h
index 4b0a95d..03f845f 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_exprs.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_exprs.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _COMMON_ISP_EXPRS_H_
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_types.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_types.h
index b4ba1c8..7a73702 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_types.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/isp/modes/interface/isp_types.h
@@ -1,25 +1,15 @@
 /*
- * INTEL CONFIDENTIAL
+ * Support for Intel Camera Imaging ISP subsystem.
+ * Copyright (c) 2015, Intel Corporation.
  *
- * Copyright (C) 2010 - 2013 Intel Corporation.
- * All Rights Reserved.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
  *
- * The source code contained or described herein and all documents
- * related to the source code ("Material") are owned by Intel Corporation
- * or licensors. Title to the Material remains with Intel
- * Corporation or its licensors. The Material contains trade
- * secrets and proprietary and confidential information of Intel or its
- * licensors. The Material is protected by worldwide copyright
- * and trade secret laws and treaty provisions. No part of the Material may
- * be used, copied, reproduced, modified, published, uploaded, posted,
- * transmitted, distributed, or disclosed in any way without Intel's prior
- * express written permission.
- *
- * No License under any patent, copyright, trade secret or other intellectual
- * property right is granted to or conferred upon you by disclosure or
- * delivery of the Materials, either expressly, by implication, inducement,
- * estoppel or otherwise. Any license under such intellectual property rights
- * must be express and approved by Intel in writing.
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
  */
 
 #ifndef _ISP_TYPES_H_
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/interface/ia_css_binary.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/interface/ia_css_binary.h
index b7010f9..78f6c08 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/interface/ia_css_binary.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/interface/ia_css_binary.h
@@ -102,6 +102,7 @@ struct ia_css_binary_descr {
 	bool enable_xnr;
 	bool enable_fractional_ds;
 	bool enable_dpc;
+	bool enable_capture_pp_bli;
 	struct ia_css_resolution dvs_env;
 	enum ia_css_stream_format stream_format;
 	struct ia_css_frame_info *in_info;		/* the info of the input-frame with the
@@ -232,6 +233,12 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 			    struct ia_css_grid_info *info,
 			    struct ia_css_pipe *pipe);
 
+void
+ia_css_binary_dvs_stat_grid_info(
+	const struct ia_css_binary *binary,
+	struct ia_css_grid_info *info,
+	struct ia_css_pipe *pipe);
+
 unsigned
 ia_css_binary_max_vf_width(void);
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c
index eff89fc..48fa021 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/binary/src/binary.c
@@ -36,6 +36,7 @@
 #include "camera/pipe/interface/ia_css_pipe_binarydesc.h"
 #if defined(HAS_RES_MGR)
 #include <components/resolutions_mgr/src/host/resolutions_mgr.host.h>
+#include <components/acc_cluster/acc_dvs_stat/host/dvs_stat.host.h>
 #endif
 
 #include "memory_access.h"
@@ -320,6 +321,18 @@ ia_css_binary_get_shading_info(const struct ia_css_binary *binary,			/* [in] */
 	return err;
 }
 
+static void sh_css_binary_common_grid_info(const struct ia_css_binary *binary,
+				struct ia_css_grid_info *info)
+{
+	assert(binary != NULL);
+	assert(info != NULL);
+
+	info->isp_in_width = binary->internal_frame_info.res.width;
+	info->isp_in_height = binary->internal_frame_info.res.height;
+
+	info->vamem_type = IA_CSS_VAMEM_TYPE_2;
+}
+
 void
 ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 			    struct ia_css_grid_info *info,
@@ -331,7 +344,7 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 	assert(binary != NULL);
 	assert(info != NULL);
 
-	dvs_info = &info->dvs_grid;
+	dvs_info = &info->dvs_grid.dvs_grid_info;
 
 	/* for DIS, we use a division instead of a ceil_div. If this is smaller
 	 * than the 3a grid size, it indicates that the outer values are not
@@ -346,10 +359,37 @@ ia_css_binary_dvs_grid_info(const struct ia_css_binary *binary,
 	dvs_info->num_hor_coefs     = binary->dis.coef.dim.width;
 	dvs_info->num_ver_coefs     = binary->dis.coef.dim.height;
 
-#if defined(IS_ISP_2500_SYSTEM)
-	assert(pipe != NULL);
-	dvs_info->enable            = binary->info->sp.enable.dvs_stats;
+	sh_css_binary_common_grid_info(binary, info);
+}
+
+void
+ia_css_binary_dvs_stat_grid_info(
+	const struct ia_css_binary *binary,
+	struct ia_css_grid_info *info,
+	struct ia_css_pipe *pipe)
+{
+#if defined(HAS_RES_MGR)
+	struct ia_css_dvs_stat_grid_info *dvs_stat_info;
+	unsigned int i;
+
+	assert(binary != NULL);
+	assert(info != NULL);
+	dvs_stat_info = &info->dvs_grid.dvs_stat_grid_info;
+
+	if (binary->info->sp.enable.dvs_stats) {
+		for (i = 0; i < IA_CSS_SKC_DVS_STAT_NUM_OF_LEVELS; i++) {
+			dvs_stat_info->grd_cfg[i].grd_start.enable = 1;
+		}
+		ia_css_dvs_stat_grid_calculate(pipe, dvs_stat_info);
+	}
+	else {
+		memset(dvs_stat_info, 0, sizeof(struct ia_css_dvs_stat_grid_info));
+	}
+
 #endif
+	(void)pipe;
+	sh_css_binary_common_grid_info(binary, info);
+	return;
 }
 
 enum ia_css_err
@@ -954,6 +994,7 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 	bool enable_high_speed;
 	bool enable_dvs_6axis;
 	bool enable_reduced_pipe;
+	bool enable_capture_pp_bli;
 	enum ia_css_err err = IA_CSS_ERR_INTERNAL_ERROR;
 	bool continuous;
 	unsigned int isp_pipe_version;
@@ -993,6 +1034,7 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 	enable_high_speed = descr->enable_high_speed;
 	enable_dvs_6axis  = descr->enable_dvs_6axis;
 	enable_reduced_pipe = descr->enable_reduced_pipe;
+	enable_capture_pp_bli = descr->enable_capture_pp_bli;
 	continuous = descr->continuous;
 	striped = descr->striped;
 	isp_pipe_version = descr->isp_pipe_version;
@@ -1276,6 +1318,13 @@ ia_css_binary_find(struct ia_css_binary_descr *descr,
 			continue;
 		}
 
+		if (candidate->uds.use_bci && enable_capture_pp_bli) {
+			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+				"ia_css_binary_find() [%d] continue: 0x%x & 0x%x)\n",
+				__LINE__, candidate->uds.use_bci,
+				descr->enable_capture_pp_bli);
+			continue;
+		}
 
 		/* reconfigure any variable properties of the binary */
 		err = ia_css_binary_fill_info(xcandidate, online, two_ppc,
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h
index f9807a7..2a47fc4 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/interface/ia_css_debug.h
@@ -68,11 +68,11 @@ enum ia_css_debug_enable_param_dump {
 
 #define IA_CSS_ERROR(fmt, ...) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR, \
-		"%s(): error: " fmt "\n", __func__, ##__VA_ARGS__)
+		"%s() %d: error: " fmt "\n", __func__, __LINE__, ##__VA_ARGS__)
 
 #define IA_CSS_WARNING(fmt, ...) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_WARNING, \
-		"%s(): warning: " fmt "\n", __func__, ##__VA_ARGS__)
+		"%s() %d: warning: " fmt "\n", __func__, __LINE__, ##__VA_ARGS__)
 
 /* Logging macros for public functions (API functions) */
 #define IA_CSS_ENTER(fmt, ...) \
@@ -91,7 +91,7 @@ enum ia_css_debug_enable_param_dump {
 /* Shorthand for returning an enum ia_css_err return value */
 #define IA_CSS_LEAVE_ERR(__err) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, \
-		"%s(): leave: return_err=%d\n", __func__, __err)
+		"%s() %d: leave: return_err=%d\n", __func__, __LINE__, __err)
 
 /* Use this macro for logging other than enter/leave.
  * Note that this macro always uses the PRIVATE logging level.
@@ -112,7 +112,7 @@ enum ia_css_debug_enable_param_dump {
 /* Shorthand for returning an enum ia_css_err return value */
 #define IA_CSS_LEAVE_ERR_PRIVATE(__err) \
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, \
-		"%s(): leave: return_err=%d\n", __func__, __err)
+		"%s() %d: leave: return_err=%d\n", __func__, __LINE__, __err)
 
 /* Use this macro for small functions that do not call other functions. */
 #define IA_CSS_ENTER_LEAVE_PRIVATE(fmt, ...) \
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c
index f863d16..b71a9a1 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/debug/src/ia_css_debug.c
@@ -3282,8 +3282,6 @@ ia_css_debug_dump_stream_config(
 			config->input_config.bayer_order);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sensor_binning_factor: %d\n",
 			config->sensor_binning_factor);
-	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "two_pixels_per_clock: %d\n",
-			config->two_pixels_per_clock);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "pixels_per_clock: %d\n",
 			config->pixels_per_clock);
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "online: %d\n",
@@ -3347,7 +3345,7 @@ static void debug_dump_one_trace(TRACE_CORE_ID proc_id)
 	uint32_t tmp;
 	int i, j, max_trace_points, point_num, limit = -1;
 	/* using a static buffer here as the driver has issues allocating memory */
-	static uint32_t trace_read_buf[TRACE_BUFF_SIZE];
+	static uint32_t trace_read_buf[TRACE_BUFF_SIZE] = {0};
 
 	/* read the header and parse it */
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "~~~ Tracer ");
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/csi_rx_rmgr.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/csi_rx_rmgr.c
index c2d67b3..990a3e0 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/csi_rx_rmgr.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/isys/src/csi_rx_rmgr.c
@@ -44,8 +44,8 @@ bool ia_css_isys_csi_rx_lut_rmgr_acquire(
 	csi_rx_backend_lut_entry_t	*entry)
 {
 	bool retval = false;
-	uint16_t max_num_packets_of_type;
-	uint16_t num_active_of_type;
+	uint32_t max_num_packets_of_type;
+	uint32_t num_active_of_type;
 	isys_csi_rx_rsrc_t *cur_rsrc = NULL;
 	uint16_t i;
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/queue/src/queue_access.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/queue/src/queue_access.h
index 9700492..c2281dd 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/queue/src/queue_access.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/queue/src/queue_access.h
@@ -41,13 +41,13 @@
 	QUEUE_IGNORE_END_FLAG	  | \
 	QUEUE_IGNORE_STEP_FLAG)
 
-#define QUEUE_CB_DESC_INIT(cb_desc) \
-	do { \
-		(cb_desc)->size = 0;		\
-		(cb_desc)->step = 0;		\
-		(cb_desc)->start = 0;		\
-		(cb_desc)->end = 0;		\
-	} while (0)
+#define QUEUE_CB_DESC_INIT(cb_desc)	\
+	do {				\
+		(cb_desc)->size  = 0;	\
+		(cb_desc)->step  = 0;	\
+		(cb_desc)->start = 0;	\
+		(cb_desc)->end   = 0;	\
+	} while(0)
 
 struct ia_css_queue {
 	uint8_t type;        /* Specify remote/local type of access */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c
index e737aef..8718361 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/runtime/spctrl/src/spctrl.c
@@ -79,8 +79,8 @@ enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
 	if (sizeof(hrt_vaddress) > sizeof(hrt_data)) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
 				    "size of hrt_vaddress can not be greater than hrt_data\n");
-		mmgr_free(spctrl_cfg->code_size);
-		spctrl_cfg->code_size = mmgr_NULL;
+		mmgr_free(code_addr);
+		code_addr = mmgr_NULL;
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	}
 
@@ -88,8 +88,8 @@ enum ia_css_err ia_css_spctrl_load_fw(sp_ID_t sp_id,
 	if ((init_dmem_cfg->ddr_data_addr % HIVE_ISP_DDR_WORD_BYTES) != 0) {
 		ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
 				    "DDR address pointer is not properly aligned for DMA transfer\n");
-		mmgr_free(spctrl_cfg->code_size);
-		spctrl_cfg->code_size = mmgr_NULL;
+		mmgr_free(code_addr);
+		code_addr = mmgr_NULL;
 		return IA_CSS_ERR_INTERNAL_ERROR;
 	}
 #endif
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c
index 61caf40..fd6474d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css.c
@@ -100,6 +100,10 @@ static int thread_alive;
 #include "components/acc_cluster/gen/host/acc_cluster.host.h"
 #endif
 
+#if defined(IS_ISP_2500_SYSTEM)
+#include "components/dvs/sc_dvs_1.0/host/dvs.host.h"
+#endif
+
 /* Name of the sp program: should not be built-in */
 #define SP_PROG_NAME "sp"
 #if defined(HAS_SEC_SP)
@@ -184,10 +188,7 @@ static bool fw_explicitly_loaded = false;
  * Local prototypes
  */
 static enum ia_css_err
-allocate_delay_frames(enum ia_css_pipe_id mode,
-		struct ia_css_video_settings *mycs_video,
-		struct ia_css_capture_settings *mycs_capture,
-		unsigned int dvs_frame_delay);
+allocate_delay_frames(struct ia_css_pipe *pipe);
 
 static enum ia_css_err
 sh_css_pipe_start(struct ia_css_stream *stream);
@@ -208,7 +209,7 @@ sh_css_init_host_sp_control_vars(void);
 static void
 sh_css_mmu_set_page_table_base_index(hrt_data base_index);
 
-static enum ia_css_err set_num_primary_stages(unsigned int *num, unsigned int version);
+static enum ia_css_err set_num_primary_stages(unsigned int *num, enum ia_css_pipe_version version);
 
 static bool
 need_capture_pp(const struct ia_css_pipe *pipe);
@@ -228,6 +229,8 @@ static bool
 need_downscaling(const struct ia_css_resolution in_res,
 		const struct ia_css_resolution out_res);
 
+static bool need_capt_ldc(const struct ia_css_pipe *pipe);
+
 static enum ia_css_err
 sh_css_pipe_load_binaries(struct ia_css_pipe *pipe);
 
@@ -1791,6 +1794,10 @@ ia_css_init(const struct ia_css_env *env,
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 #endif
 
+#if !defined(IS_ISP_2500_SYSTEM)
+	sh_css_params_map_and_store_default_gdc_lut();
+#endif
+
 	IA_CSS_LEAVE_ERR(err);
 	return err;
 }
@@ -2475,6 +2482,11 @@ ia_css_pipe_destroy(struct ia_css_pipe *pipe)
 		break;
 	}
 
+	if (pipe->scaler_pp_lut != mmgr_NULL) {
+		mmgr_free(pipe->scaler_pp_lut);
+		pipe->scaler_pp_lut = mmgr_NULL;
+	}
+
 	my_css.active_pipes[ia_css_pipe_get_pipe_num(pipe)] = NULL;
 	sh_css_pipe_free_shading_table(pipe);
 
@@ -2499,6 +2511,11 @@ ia_css_uninit(void)
 	print_pc_histogram();
 #endif
 
+#if !defined(IS_ISP_2500_SYSTEM)
+	sh_css_params_free_default_gdc_lut();
+#endif
+
+
 	/* TODO: JB: implement decent check and handling of freeing mipi frames */
 	//assert(ref_count_mipi_allocation == 0); //mipi frames are not freed
 	/* cleanup generic data */
@@ -4555,7 +4572,6 @@ static enum ia_css_event_type convert_event_sp_to_host_domain[] = {
 	IA_CSS_EVENT_TYPE_ACC_STAGE_COMPLETE,	/**< Extension stage executed. */
 	IA_CSS_EVENT_TYPE_TIMER,		/**< Timing measurement data. */
 	IA_CSS_EVENT_TYPE_PORT_EOF,		/**< End Of Frame event, sent when in buffered sensor mode. */
-	IA_CSS_EVENT_TYPE_FW_ERROR,		/**< Unrecoverable error encountered by FW. */
 	IA_CSS_EVENT_TYPE_FW_WARNING,		/**< Performance warning encountered by FW */
 	IA_CSS_EVENT_TYPE_FW_ASSERT,		/**< Assertion hit by FW */
 	0,					/** error if sp passes  SH_CSS_SP_EVENT_NR_OF_TYPES as a valid event. */
@@ -4608,7 +4624,6 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	event->pipe = NULL;
 	event->port = IA_CSS_CSI2_PORT0;
 	event->exp_id = 0;
-	event->fw_error = IA_CSS_FW_SUCCESS;
 	event->fw_warning = IA_CSS_FW_WARNING_NONE;
 	event->fw_handle = 0;
 	event->timer_data = 0;
@@ -4616,7 +4631,7 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	event->timer_subcode = 0;
 
 	if (event->type == IA_CSS_EVENT_TYPE_TIMER) {
-		/* timer event  get the 2nd event and decode the data into the event struct */
+		/* timer event ??? get the 2nd event and decode the data into the event struct */
 		uint32_t tmp_data;
 		/* 1st event: LSB 16-bit timer data and code */
 		event->timer_data = ((payload[1] & 0xFF) | ((payload[3] & 0xFF) << 8));
@@ -4624,7 +4639,7 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 		payload[0] = payload[1] = payload[2] = payload[3] = 0;
 		ret_err = ia_css_bufq_dequeue_psys_event(payload);
 		if (ret_err != IA_CSS_SUCCESS) {
-			/* no 2nd event  an error */
+			/* no 2nd event ??? an error */
 			/* Putting IA_CSS_ERROR is resulting in failures in
 			 * Merrifield smoke testing  */
 			IA_CSS_WARNING("Timer: Error de-queuing the 2nd TIMER event!!!\n");
@@ -4655,8 +4670,6 @@ ia_css_dequeue_psys_event(struct ia_css_event *event)
 	if (event->type == IA_CSS_EVENT_TYPE_PORT_EOF) {
 		event->port = (enum ia_css_csi2_port)payload[1];
 		event->exp_id = payload[3];
-	} else if (event->type == IA_CSS_EVENT_TYPE_FW_ERROR) {
-		event->fw_error = (enum ia_css_fw_err)payload[1];
 	} else if (event->type == IA_CSS_EVENT_TYPE_FW_WARNING) {
 		event->fw_warning = (enum ia_css_fw_warning)payload[1];
 		/* exp_id is only available in these warning types */
@@ -5100,7 +5113,6 @@ sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
 
 	binary = ia_css_pipe_get_s3a_binary(pipe);
 
-
 	if (binary) {
 		err = ia_css_binary_3a_grid_info(binary, info, pipe);
 		if (err != IA_CSS_SUCCESS)
@@ -5110,10 +5122,15 @@ sh_css_pipe_get_grid_info(struct ia_css_pipe *pipe,
 
 	binary = ia_css_pipe_get_sdis_binary(pipe);
 
-	if (binary)
+	if (binary) {
 		ia_css_binary_dvs_grid_info(binary, info, pipe);
-	else
-		memset(&info->dvs_grid, 0, sizeof(info->dvs_grid));
+		ia_css_binary_dvs_stat_grid_info(binary, info, pipe);
+	} else {
+		memset(&info->dvs_grid.dvs_grid_info, 0,
+			   sizeof(info->dvs_grid.dvs_grid_info));
+		memset(&info->dvs_grid.dvs_stat_grid_info, 0,
+			   sizeof(info->dvs_grid.dvs_stat_grid_info));
+	}
 
 	if (binary != NULL) {
 		/* copy pipe does not have ISP binary*/
@@ -5278,10 +5295,12 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 					 &mycs->video_binary);
 
 		if (err != IA_CSS_SUCCESS) {
+#if !defined(IS_ISP_2500_SYSTEM)
 			if (video_vf_info) {
 				/* This will do another video binary lookup later for YUV_LINE format*/
 				need_vf_pp = true;
 			} else
+#endif
 				return err;
 		} else if (video_vf_info) {
 			/* The first video binary lookup is successful, but we may
@@ -5310,7 +5329,8 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 
 			vf_info_format = video_vf_info->format;
 
-			ia_css_frame_info_set_format(video_vf_info,
+			if (!pipe->config.enable_vfpp_bci)
+				ia_css_frame_info_set_format(video_vf_info,
 					IA_CSS_FRAME_FORMAT_YUV_LINE);
 
 			ia_css_binary_destroy_isp_parameters(&mycs->video_binary);
@@ -5369,9 +5389,20 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	if (pipe->enable_viewfinder[IA_CSS_PIPE_OUTPUT_STAGE_0] && need_vf_pp) {
 		struct ia_css_binary_descr vf_pp_descr;
 
-		ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
-			&mycs->video_binary.vf_frame_info,
-			pipe_vf_out_info);
+		if (mycs->video_binary.vf_frame_info.format
+				== IA_CSS_FRAME_FORMAT_YUV_LINE) {
+			ia_css_pipe_get_vfpp_binarydesc(pipe, &vf_pp_descr,
+				&mycs->video_binary.vf_frame_info,
+				pipe_vf_out_info);
+		} else {
+			/* output from main binary is not yuv line. currently this is
+			 * possible only when bci is enabled on vfpp output */
+			assert(pipe->config.enable_vfpp_bci == true);
+			ia_css_pipe_get_yuvscaler_binarydesc(pipe, &vf_pp_descr,
+				&mycs->video_binary.vf_frame_info,
+				pipe_vf_out_info, NULL, NULL);
+		}
+
 		err = ia_css_binary_find(&vf_pp_descr,
 				&mycs->vf_pp_binary);
 		if (err != IA_CSS_SUCCESS)
@@ -5379,7 +5410,7 @@ static enum ia_css_err load_video_binaries(struct ia_css_pipe *pipe)
 	}
 #endif
 
-	err = allocate_delay_frames(pipe->mode, mycs, NULL, pipe->dvs_frame_delay);
+	err = allocate_delay_frames(pipe);
 
 	if (err != IA_CSS_SUCCESS)
 		return err;
@@ -5653,7 +5684,16 @@ static bool need_capture_pp(
 	return false;
 }
 
-static enum ia_css_err set_num_primary_stages(unsigned int *num, unsigned int version)
+static bool need_capt_ldc(
+	const struct ia_css_pipe *pipe)
+{
+	IA_CSS_ENTER_LEAVE_PRIVATE("");
+	assert(pipe != NULL);
+	assert(pipe->mode == IA_CSS_PIPE_ID_CAPTURE);
+	return (pipe->extra_config.enable_dvs_6axis) ? true:false;
+}
+
+static enum ia_css_err set_num_primary_stages(unsigned int *num, enum ia_css_pipe_version version)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
 
@@ -5684,6 +5724,7 @@ static enum ia_css_err load_primary_binaries(
 	bool continuous = false;
 	bool need_pp = false;
 	bool need_isp_copy_binary = false;
+	bool need_ldc = false;
 #ifdef USE_INPUT_SYSTEM_VERSION_2401
 	bool sensor = false;
 #endif
@@ -5691,7 +5732,8 @@ static enum ia_css_err load_primary_binaries(
 				 prim_out_info,
 				 capt_pp_out_info, vf_info,
 				 *vf_pp_in_info, *pipe_out_info,
-				 *pipe_vf_out_info;
+				 *pipe_vf_out_info, *capt_pp_in_info,
+				 capt_ldc_out_info;
 #if defined(HAS_RES_MGR)
 	struct ia_css_frame_info bds_out_info;
 #endif
@@ -5837,12 +5879,17 @@ static enum ia_css_err load_primary_binaries(
 		capt_pp_out_info = pipe->output_info[0];
 	}
 
+	/* TODO Do we disable ldc for skycam */
+	need_ldc = need_capt_ldc(pipe);
+
 	/* we build up the pipeline starting at the end */
 	/* Capture post-processing */
 	if (need_pp) {
 		struct ia_css_binary_descr capture_pp_descr;
+		capt_pp_in_info = need_ldc ? &capt_ldc_out_info : &prim_out_info;
+
 		ia_css_pipe_get_capturepp_binarydesc(pipe,
-			&capture_pp_descr, &prim_out_info,
+			&capture_pp_descr, capt_pp_in_info,
 			&capt_pp_out_info, &vf_info);
 #if defined(HAS_RES_MGR)
 			bds_out_info.res = pipe->config.bayer_ds_out_res;
@@ -5854,6 +5901,20 @@ static enum ia_css_err load_primary_binaries(
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
+
+		if(need_ldc) {
+			struct ia_css_binary_descr capt_ldc_descr;
+			ia_css_pipe_get_ldc_binarydesc(pipe,
+				&capt_ldc_descr, &prim_out_info,
+				&capt_ldc_out_info);
+
+			err = ia_css_binary_find(&capt_ldc_descr,
+						&mycs->capture_ldc_binary);
+			if (err != IA_CSS_SUCCESS) {
+				IA_CSS_LEAVE_ERR_PRIVATE(err);
+				return err;
+			}
+		}
 	} else {
 		prim_out_info = *pipe_out_info;
 	}
@@ -5916,7 +5977,7 @@ static enum ia_css_err load_primary_binaries(
 		}
 	}
 #endif
-	err = allocate_delay_frames(pipe->mode, NULL, mycs, pipe->dvs_frame_delay);
+	err = allocate_delay_frames(pipe);
 
 	if (err != IA_CSS_SUCCESS)
 		return err;
@@ -5945,67 +6006,87 @@ static enum ia_css_err load_primary_binaries(
 }
 
 static enum ia_css_err
-allocate_delay_frames(enum ia_css_pipe_id mode,
-		struct ia_css_video_settings *mycs_video,
-		struct ia_css_capture_settings *mycs_capture,
-		unsigned int dvs_frame_delay)
+allocate_delay_frames(struct ia_css_pipe *pipe)
 {
 	unsigned int num_delay_frames = 0, i = 0;
+	unsigned int dvs_frame_delay = 0;
 	struct ia_css_frame_info ref_info;
 	enum ia_css_err err = IA_CSS_SUCCESS;
+	enum ia_css_pipe_id mode = IA_CSS_PIPE_ID_VIDEO;
+	struct ia_css_frame **delay_frames = NULL;
 
-	if (((mode == IA_CSS_PIPE_ID_CAPTURE) && (mycs_capture == NULL)) ||
-	    ((mode == IA_CSS_PIPE_ID_VIDEO) && (mycs_video == NULL))) {
+	if (pipe == NULL) {
+		IA_CSS_ERROR("Invalid args - pipe %x", pipe);
 		return IA_CSS_ERR_INVALID_ARGUMENTS;
-	 }
+	}
 
-	if (mode == IA_CSS_PIPE_ID_CAPTURE) {
-#if defined (IS_ISP_2500_SYSTEM)
-		ref_info               = mycs_capture->primary_binary[0].internal_frame_info;
-		ref_info.format        = IA_CSS_FRAME_FORMAT_YUV420_16;
-		ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
+	mode = pipe->mode;
+	dvs_frame_delay = pipe->dvs_frame_delay;
+
+	if (dvs_frame_delay > 0)
+		num_delay_frames = dvs_frame_delay + 1;
+
+	switch (mode) {
+		case IA_CSS_PIPE_ID_CAPTURE:
+		{
+			struct ia_css_capture_settings *mycs_capture = &pipe->pipe_settings.capture;
+#ifndef IS_ISP_2500_SYSTEM
+			(void)mycs_capture;
+			return err;
 #else
-		return err;
+			ref_info = mycs_capture->primary_binary[0].internal_frame_info;
+			ref_info.format = IA_CSS_FRAME_FORMAT_YUV420_16;
+			/* There should be atleast 1 delay/ref frame for capture mode */
+			if (num_delay_frames == 0)
+				num_delay_frames = 1;
+			delay_frames = mycs_capture->delay_frames;
 #endif
-	} else if (mode == IA_CSS_PIPE_ID_VIDEO) {
-		ref_info               = mycs_video->video_binary.internal_frame_info;
-#if defined (IS_ISP_2500_SYSTEM)
-		ref_info.format        = IA_CSS_FRAME_FORMAT_YUV420_16;
+		}
+		break;
+		case IA_CSS_PIPE_ID_VIDEO:
+		{
+			struct ia_css_video_settings *mycs_video = &pipe->pipe_settings.video;
+			ref_info = mycs_video->video_binary.internal_frame_info;
+#ifdef IS_ISP_2500_SYSTEM
+			ref_info.format = IA_CSS_FRAME_FORMAT_YUV420_16;
 #else
-		ref_info.format        = IA_CSS_FRAME_FORMAT_YUV420;
+			/*The ref frame expects
+			 * 	1. Y plane
+			 * 	2. UV plane with line interleaving, like below
+			 * 		UUUUUU(width/2 times) VVVVVVVV..(width/2 times)
+			 *
+			 *	This format is not YUV420(which has Y, U and V planes).
+			 *	Its closer to NV12, except that the UV plane has UV 
+			 *	interleaving, like UVUVUVUVUVUVUVUVU...
+			 *
+			 *	TODO: make this ref_frame format as a separate frame format
+			 */
+			ref_info.format        = IA_CSS_FRAME_FORMAT_NV12;
 #endif
-		ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
-	} else {
-		return IA_CSS_ERR_INVALID_ARGUMENTS;
+			delay_frames = mycs_video->delay_frames;
+		}
+		break;
+		default:
+			return IA_CSS_ERR_INVALID_ARGUMENTS;
+
 	}
 
-	if (dvs_frame_delay > 0)
-		num_delay_frames = dvs_frame_delay + 1;
-	else {
-		if (mode == IA_CSS_PIPE_ID_CAPTURE)
-			num_delay_frames = 1; /* There should be atleast 1 delay/ref frame for capture mode */
-		else if (mode == IA_CSS_PIPE_ID_VIDEO)
-			num_delay_frames = 0;
-		else
-			return IA_CSS_ERR_INVALID_ARGUMENTS;
+	ref_info.raw_bit_depth = SH_CSS_REF_BIT_DEPTH;
+
+#ifdef IS_ISP_2500_SYSTEM
+	err = dvs_calc_gdc_in_buff_padding(&pipe->config, &ref_info);
+	if (err != IA_CSS_SUCCESS) {
+		return err;
 	}
+#endif
 
+	assert(num_delay_frames <= MAX_NUM_VIDEO_DELAY_FRAMES);
 	for (i = 0; i < num_delay_frames; i++) {
-		if (mode == IA_CSS_PIPE_ID_CAPTURE)
-			err = ia_css_frame_allocate_from_info(&mycs_capture->delay_frames[i],
-					&ref_info);
-		else if (mode == IA_CSS_PIPE_ID_VIDEO)
-			err = ia_css_frame_allocate_from_info(&mycs_video->delay_frames[i],
-					&ref_info);
-
+		err = ia_css_frame_allocate_from_info(&delay_frames[i],	&ref_info);
 		if (err != IA_CSS_SUCCESS)
 			return err;
-
 #ifdef HRT_CSIM
-		if (mode == IA_CSS_PIPE_ID_CAPTURE)
-			ia_css_frame_zero(mycs_capture->delay_frames[i]);
-		else if (mode == IA_CSS_PIPE_ID_VIDEO)
-			ia_css_frame_zero(mycs_video->delay_frames[i]);
+		ia_css_frame_zero(delay_frames[i]);
 #endif
 	}
 
@@ -6380,6 +6461,7 @@ unload_capture_binaries(struct ia_css_pipe *pipe)
 	ia_css_binary_unload(&pipe->pipe_settings.capture.anr_gdc_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.post_isp_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.capture_pp_binary);
+	ia_css_binary_unload(&pipe->pipe_settings.capture.capture_ldc_binary);
 	ia_css_binary_unload(&pipe->pipe_settings.capture.vf_pp_binary);
 
 	for (i = 0; i < pipe->pipe_settings.capture.num_yuv_scaler; i++)
@@ -6583,6 +6665,7 @@ static enum ia_css_err ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pi
 	in_info.res = pipe->config.input_effective_res;
 	in_info.padded_width = in_info.res.width;
 	descr->num_output_stage = 0;
+	/* Find out how much scaling we need for each output */
 	for (i = 0; i < IA_CSS_PIPE_MAX_OUTPUT_STAGE; i++) {
 		if (pipe->output_info[i].res.width != 0) {
 			out_info[i] = &pipe->output_info[i];
@@ -6596,29 +6679,21 @@ static enum ia_css_err ia_css_pipe_create_cas_scaler_desc(struct ia_css_pipe *pi
 			ver_scale_factor[i] = CEIL_DIV(in_info.res.height, out_info[i]->res.height);
 			/* use the same horizontal and vertical scaling factor for simplicity */
 			assert(hor_scale_factor[i] == ver_scale_factor[i]);
+			scale_factor = 1;
+			do {
+				num_stages++;
+				scale_factor *= max_scale_factor_per_stage;
+			} while (scale_factor < hor_scale_factor[i]);
+
+			in_info.res = out_info[i]->res;
 		}
-		if (hor_scale_factor[i] > scale_factor)
-			scale_factor = hor_scale_factor[i];
 	}
 
-	i = 1;
-	while (i < scale_factor) {
-		num_stages++;
-		i *= max_scale_factor_per_stage;
-	}
 	if (need_yuv_scaler_stage(pipe) && (num_stages == 0))
 		num_stages = 1;
 
 	descr->num_stage = num_stages;
 
-	/* if two outputs requires the same number of scaling stages, we
-	 * extent it by one because we only have fixed number of output pins. */
-	if ((out_info[0] != NULL) && (out_info[1] != NULL) &&
-		((out_info[0]->res.width == out_info[1]->res.width) ||
-		(out_info[0]->res.width == in_info.res.width))&&
-		(descr->num_output_stage > 1)) {
-		descr->num_stage += 1;
-	}
 	descr->in_info = sh_css_malloc(descr->num_stage * sizeof(struct ia_css_frame_info));
 	if (descr->in_info == NULL) {
 		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
@@ -7412,7 +7487,8 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 			     *anr_gdc_binary,
 			     *post_isp_binary,
 			     *yuv_scaler_binary,
-			     *capture_pp_binary;
+			     *capture_pp_binary,
+			     *capture_ldc_binary;
 	bool need_pp = false;
 	bool raw;
 
@@ -7431,6 +7507,7 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	unsigned int i, num_yuv_scaler, num_primary_stage;
 	bool need_yuv_pp = false;
 	bool *is_output_stage = NULL;
+	bool need_ldc = false;
 
 	IA_CSS_ENTER_PRIVATE("");
 	assert(pipe != NULL);
@@ -7510,11 +7587,13 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 	yuv_scaler_binary = pipe->pipe_settings.capture.yuv_scaler_binary;
 	num_yuv_scaler	  = pipe->pipe_settings.capture.num_yuv_scaler;
 	is_output_stage   = pipe->pipe_settings.capture.is_output_stage;
+	capture_ldc_binary = &pipe->pipe_settings.capture.capture_ldc_binary;
 
 	need_pp = (need_capture_pp(pipe) || pipe->output_stage) &&
 		  mode != IA_CSS_CAPTURE_MODE_RAW &&
 		  mode != IA_CSS_CAPTURE_MODE_BAYER;
 	need_yuv_pp = (yuv_scaler_binary != NULL && yuv_scaler_binary->info != NULL);
+	need_ldc = (capture_ldc_binary != NULL && capture_ldc_binary->info != NULL);
 
 	if (pipe->pipe_settings.capture.copy_binary.info) {
 		if (raw) {
@@ -7660,9 +7739,20 @@ create_host_regular_capture_pipeline(struct ia_css_pipe *pipe)
 		}
 	}
 
-	if (need_pp) {
-		in_frame = current_stage->args.out_frame[0];
-		err = add_capture_pp_stage(pipe, me, in_frame, need_yuv_pp ? NULL : out_frame,
+	if (need_pp && current_stage) {
+		struct ia_css_frame *local_in_frame = NULL;
+		local_in_frame = current_stage->args.out_frame[0];
+
+		if(need_ldc) {
+			ia_css_pipe_util_set_output_frames(out_frames, 0, NULL);
+			ia_css_pipe_get_generic_stage_desc(&stage_desc, capture_ldc_binary,
+				out_frames, local_in_frame, NULL);
+			err = ia_css_pipeline_create_and_add_stage(me,
+				&stage_desc,
+				&current_stage);
+			local_in_frame = current_stage->args.out_frame[0];
+		}
+		err = add_capture_pp_stage(pipe, me, local_in_frame, need_yuv_pp ? NULL : out_frame,
 					   capture_pp_binary,
 					   &current_stage);
 		if (err != IA_CSS_SUCCESS) {
@@ -8337,6 +8427,7 @@ void ia_css_stream_config_defaults(struct ia_css_stream_config *stream_config)
 	memset(stream_config, 0, sizeof(*stream_config));
 	stream_config->online = true;
 	stream_config->left_padding = -1;
+	stream_config->pixels_per_clock = 1;
 	/* temporary default value for backwards compatibility.
 	 * This field used to be hardcoded within CSS but this has now
 	 * been moved to the stream_config struct. */
@@ -8433,8 +8524,14 @@ ia_css_pipe_create_extra(const struct ia_css_pipe_config *config,
 	else
 		internal_pipe->dvs_frame_delay = 1;
 
+	/* skycam has delayed frames in capture and video */
+#if defined(IS_ISP_2500_SYSTEM)
+	if (internal_pipe->config.mode != IA_CSS_PIPE_MODE_CAPTURE && internal_pipe->config.mode != IA_CSS_PIPE_MODE_VIDEO)
+		internal_pipe->dvs_frame_delay = 0;
+#else
 	if (internal_pipe->config.mode != IA_CSS_PIPE_MODE_VIDEO)
 		internal_pipe->dvs_frame_delay = 0;
+#endif
 
 	/* we still keep enable_raw_binning for backward compatibility, for any new
 	   fractional bayer downscaling, we should use bayer_ds_out_res. if both are
@@ -8563,6 +8660,20 @@ ia_css_pipe_get_info(const struct ia_css_pipe *pipe,
 	return IA_CSS_SUCCESS;
 }
 
+bool ia_css_pipe_has_dvs_stats(struct ia_css_pipe_info *pipe_info)
+{
+	unsigned int i;
+
+	if (pipe_info != NULL) {
+		for (i = 0; i < IA_CSS_DVS_STAT_NUM_OF_LEVELS; i++) {
+			if (pipe_info->grid_info.dvs_grid.dvs_stat_grid_info.grd_cfg[i].grd_start.enable)
+				return true;
+		}
+	}
+
+	return false;
+}
+
 #if defined(USE_INPUT_SYSTEM_VERSION_2)
 /* Configuration of INPUT_SYSTEM_VERSION_2401 is done on SP */
 static enum ia_css_err
@@ -8832,11 +8943,6 @@ ia_css_stream_create(const struct ia_css_stream_config *stream_config,
 		curr_stream->config.mode =  IA_CSS_INPUT_MODE_BUFFERED_SENSOR;
 	}
 #endif
-	/* TO BE REMOVED when all drivers move to CSS API 2.1 */
-	if (curr_stream->config.pixels_per_clock == 0)
-		curr_stream->config.pixels_per_clock =
-			curr_stream->config.two_pixels_per_clock ? 2 : 1;
-
 	/* in case driver doesn't configure init number of raw buffers, configure it here */
 	if (curr_stream->config.target_num_cont_raw_buf == 0)
 		curr_stream->config.target_num_cont_raw_buf = NUM_CONTINUOUS_FRAMES;
@@ -9612,7 +9718,7 @@ ia_css_pipe_get_sdis_binary(const struct ia_css_pipe *pipe)
 #endif
 		binary = NULL;
 
-        return binary;
+	return binary;
 }
 
 #if defined(IS_ISP_2500_SYSTEM)
@@ -9668,7 +9774,8 @@ ia_css_pipe_get_dvs_filter(const struct ia_css_pipe *pipe, struct ia_css_resolut
 		IA_CSS_ERROR("Invalid args: pipe %x res %x", pipe, res);
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 	} else {
-		res->width = res->height = SH_CSS_MIN_DVS_ENVELOPE; /* MIN DVS ENV is the filter size used by GDC */
+		/* MIN DVS ENV is the filter size used by GDC */
+		res->width = res->height = SH_CSS_MIN_DVS_ENVELOPE;
 	}
 	return err;
 }
@@ -9684,9 +9791,8 @@ ia_css_pipe_get_gdc_in_buffer_info(const struct ia_css_pipe *pipe,
 		IA_CSS_ERROR("Invalid args: pipe %x res %x offset %x", pipe, res, offset);
 		err = IA_CSS_ERR_INVALID_ARGUMENTS;
 	} else {
-		ia_css_pipe_get_bds_resolution(pipe, res);
-		offset->x = 0;
-		offset->y = 0;
+		*res = pipe->config.gdc_in_buffer_res;
+		*offset = pipe->config.gdc_in_buffer_offset;
 	}
 	return err;
 }
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c
index 27659e8..e3f0303 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_firmware.c
@@ -47,10 +47,10 @@ struct fw_param {
 /* Warning: same order as SH_CSS_BINARY_ID_* */
 static struct firmware_header *firmware_header;
 
-/* The string STR(irci_master_20150131_0457) is a place holder
+/* The string STR(irci_master_20150303_1500) is a place holder
  * which will be replaced with the actual RELEASE_VERSION
  * during package generation. Please do not modify  */
-static const char *release_version = STR(irci_master_20150131_0457);
+static const char *release_version = STR(irci_master_20150303_1500);
 
 #define MAX_FW_REL_VER_NAME	300
 static char FW_rel_ver_name[MAX_FW_REL_VER_NAME] = "---";
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_hrt.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_hrt.c
index 4e6aeb8..0bfebce 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_hrt.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_hrt.c
@@ -30,16 +30,8 @@
 #define __INLINE_FIFO_MONITOR__
 #include "fifo_monitor.h"
 
-#if !defined(HAS_NO_INPUT_SYSTEM)
-#include "input_system.h"	/* MIPI_PREDICTOR_NONE,... */
-#endif
-
 /* System independent */
 #include "sh_css_internal.h"
-#if !defined(HAS_NO_INPUT_SYSTEM)
-#include "ia_css_isys.h"
-#endif
-
 
 bool sh_css_hrt_system_is_idle(void)
 {
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h
index ccebd57..905eee8 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_internal.h
@@ -230,7 +230,6 @@ enum sh_css_sp_event_type {
 	SH_CSS_SP_EVENT_ACC_STAGE_COMPLETE,
 	SH_CSS_SP_EVENT_TIMER,
 	SH_CSS_SP_EVENT_PORT_EOF,
-	SH_CSS_SP_EVENT_FW_ERROR,
 	SH_CSS_SP_EVENT_FW_WARNING,
 	SH_CSS_SP_EVENT_FW_ASSERT,
 	SH_CSS_SP_EVENT_NR_OF_TYPES		/* must be last */
@@ -537,11 +536,15 @@ ia_css_metadata_free_multiple(unsigned int num_bufs, struct ia_css_metadata **bu
 
 /* Macro for handling pipe_qos_config */
 #define QOS_INVALID                  (~0U)
+#define QOS_ALL_STAGES_DISABLED      (0U)
 #define QOS_STAGE_MASK(num)          (0x00000001 << num)
 #define SH_CSS_IS_QOS_PIPE(pipe)               ((pipe)->pipe_qos_config != QOS_INVALID)
 #define SH_CSS_QOS_STAGE_ENABLE(pipe, num)     ((pipe)->pipe_qos_config |= QOS_STAGE_MASK(num))
 #define SH_CSS_QOS_STAGE_DISABLE(pipe, num)    ((pipe)->pipe_qos_config &= ~QOS_STAGE_MASK(num))
 #define SH_CSS_QOS_STAGE_IS_ENABLED(pipe, num) ((pipe)->pipe_qos_config & QOS_STAGE_MASK(num))
+#define SH_CSS_QOS_MODE_PIPE_ADD(mode, pipe)    ((mode) |= (0x1 << (pipe)->pipe_id))
+#define SH_CSS_QOS_MODE_PIPE_REMOVE(mode, pipe) ((mode) &= ~(0x1 << (pipe)->pipe_id))
+#define SH_CSS_IS_QOS_ONLY_MODE(mode)           ((mode) == (0x1 << IA_CSS_PIPE_ID_ACC))
 
 /* Information for a pipeline */
 struct sh_css_sp_pipeline {
@@ -561,6 +564,7 @@ struct sh_css_sp_pipeline {
 	uint32_t	num_stages;		/* the pipe config */
 	uint32_t	running;	/* needed for pipe termination */
 	hrt_vaddress	sp_stage_addr[SH_CSS_MAX_STAGES];
+	hrt_vaddress	scaler_pp_lut; /* Early bound LUT */
 #ifndef __SP
 	uint32_t	dummy; /* stage ptr is only used on sp but lives in
 				  this struct; needs cleanup */
@@ -1022,9 +1026,6 @@ sh_css_params_init(void);
 void
 sh_css_params_uninit(void);
 
-void
-sh_css_params_reconfigure_gdc_lut(void);
-
 void *
 sh_css_malloc(size_t size);
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.c
index 598baea..acc3e3b 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.c
@@ -19,6 +19,7 @@
 #include "sh_css_defs.h"
 #include "sh_css_internal.h"
 #include "ia_css_debug.h"
+#include "ia_css_pipe_binarydesc.h"
 
 #include "sh_css_hrt.h"
 
@@ -70,7 +71,8 @@ static void
 crop_and_interpolate(unsigned int cropped_width,
 		     unsigned int cropped_height,
 		     unsigned int left_padding,
-		     unsigned int right_padding,
+		     int right_padding,
+		     int top_padding,
 		     const struct ia_css_shading_table *in_table,
 		     struct ia_css_shading_table *out_table,
 		     enum ia_css_sc_color color)
@@ -104,29 +106,31 @@ crop_and_interpolate(unsigned int cropped_width,
 	out_cell_size = CEIL_DIV(padded_width, out_table->width - 1);
 	in_cell_size  = CEIL_DIV(sensor_width, table_width - 1);
 
-	out_start_col = (sensor_width - cropped_width)/2 - left_padding;
-	out_start_row = (sensor_height - cropped_height)/2;
+	out_start_col = ((int)sensor_width - (int)cropped_width)/2 - left_padding;
+	out_start_row = ((int)sensor_height - (int)cropped_height)/2 - top_padding;
 	table_cell_w = (int)((table_width-1) * in_cell_size);
 	table_cell_h = (table_height-1) * in_cell_size;
 
 	for (i = 0; i < out_table->height; i++) {
-		unsigned int ty, src_y0, src_y1, sy0, sy1, dy0, dy1, divy;
+		int ty, src_y0, src_y1;
+		unsigned int sy0, sy1, dy0, dy1, divy;
 
 		/* calculate target point and make sure it falls within
 		   the table */
 		ty = out_start_row + i * out_cell_size;
-		ty = min(ty, sensor_height-1);
-		ty = min(ty, table_cell_h);
 
 		/* calculate closest source points in shading table and
 		   make sure they fall within the table */
-		src_y0 = ty / in_cell_size;
+		src_y0 = ty / (int)in_cell_size;
 		if (in_cell_size < out_cell_size)
 			src_y1 = (ty + out_cell_size) / in_cell_size;
 		else
 			src_y1 = src_y0 + 1;
-		src_y0 = min(src_y0, table_height-1);
-		src_y1 = min(src_y1, table_height-1);
+		src_y0 = clamp(src_y0, 0, (int)table_height-1);
+		src_y1 = clamp(src_y1, 0, (int)table_height-1);
+		ty = min(clamp(ty, 0, (int)sensor_height-1),
+				 (int)table_cell_h);
+
 		/* calculate closest source points for distance computation */
 		sy0 = min(src_y0 * in_cell_size, sensor_height-1);
 		sy1 = min(src_y1 * in_cell_size, sensor_height-1);
@@ -221,15 +225,21 @@ void
 prepare_shading_table(const struct ia_css_shading_table *in_table,
 		      unsigned int sensor_binning,
 		      struct ia_css_shading_table **target_table,
-		      const struct ia_css_binary *binary)
+		      const struct ia_css_binary *binary,
+		      unsigned int bds_factor)
 {
 	unsigned int input_width,
 		     input_height,
 		     table_width,
 		     table_height,
 		     left_padding,
-		     right_padding,
+		     top_padding,
+		     padded_width,
+		     left_cropping,
 		     i;
+	unsigned int bds_numerator, bds_denominator;
+	int right_padding;
+
 	struct ia_css_shading_table *result;
 
 	assert(target_table != NULL);
@@ -240,14 +250,26 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 		return;
 	}
 
+	padded_width = binary->in_frame_info.padded_width;
 	/* We use the ISP input resolution for the shading table because
 	   shading correction is performed in the bayer domain (before bayer
 	   down scaling). */
+#if defined(USE_INPUT_SYSTEM_VERSION_2401)
+	padded_width = CEIL_MUL(binary->effective_in_frame_res.width + 2*ISP_VEC_NELEMS,
+					2*ISP_VEC_NELEMS);
+#endif
 	input_height  = binary->in_frame_info.res.height;
 	input_width   = binary->in_frame_info.res.width;
 	left_padding  = binary->left_padding;
-	right_padding = binary->in_frame_info.padded_width -
-			(input_width + left_padding);
+	left_cropping = (binary->info->sp.pipeline.left_cropping == 0) ?
+			binary->dvs_envelope.width : 2*ISP_VEC_NELEMS;
+
+	sh_css_bds_factor_get_numerator_denominator
+		(bds_factor, &bds_numerator, &bds_denominator);
+
+	left_padding  = (left_padding + binary->info->sp.pipeline.left_cropping) * bds_numerator / bds_denominator - binary->info->sp.pipeline.left_cropping;
+	right_padding = (binary->internal_frame_info.res.width - binary->effective_in_frame_res.width * bds_denominator / bds_numerator - left_cropping) * bds_numerator / bds_denominator;
+	top_padding = binary->info->sp.pipeline.top_cropping * bds_numerator / bds_denominator - binary->info->sp.pipeline.top_cropping;
 
 	/* We take into account the binning done by the sensor. We do this
 	   by cropping the non-binned part of the shading table and then
@@ -259,6 +281,7 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	   shading table. */
 	left_padding  <<= sensor_binning;
 	right_padding <<= sensor_binning;
+	top_padding   <<= sensor_binning;
 
 	/* during simulation, the used resolution can exceed the sensor
 	   resolution, so we clip it. */
@@ -281,7 +304,7 @@ prepare_shading_table(const struct ia_css_shading_table *in_table,
 	   requested resolution and decimation factor. */
 	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
 		crop_and_interpolate(input_width, input_height,
-				     left_padding, right_padding,
+				     left_padding, right_padding, top_padding,
 				     in_table,
 				     result, i);
 	}
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.h
index 6620681..acc049d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_param_shading.h
@@ -27,7 +27,8 @@ void
 prepare_shading_table(const struct ia_css_shading_table *in_table,
 		      unsigned int sensor_binning,
 		      struct ia_css_shading_table **target_table,
-		      const struct ia_css_binary *binary);
+		      const struct ia_css_binary *binary,
+		      unsigned int bds_factor);
 
 #endif /* __SH_CSS_PARAMS_SHADING_H */
 
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c
index 5f8e9fa..065518c 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.c
@@ -30,6 +30,7 @@
 
 #include "platform_support.h"
 #include "assert_support.h"
+#include "misc_support.h"	/* NOT_USED */
 #include "math_support.h"	/* max(), min()  EVEN_FLOOR()*/
 
 #include "ia_css_stream.h"
@@ -152,6 +153,11 @@ static hrt_vaddress xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
 static hrt_vaddress xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
 						[SH_CSS_MAX_STAGES];
 
+#if !defined(IS_ISP_2500_SYSTEM)
+static hrt_vaddress default_gdc_lut;
+static int interleaved_lut_temp[4][HRT_GDC_N];
+#endif
+
 /* END DO NOT MOVE INTO VIMALS_WORLD */
 
 /* Digital Zoom lookup table. See documentation for more details about the
@@ -1384,14 +1390,14 @@ store_fpntbl(struct ia_css_isp_parameters *params, hrt_vaddress ptr)
 static void
 convert_raw_to_fpn(struct ia_css_isp_parameters *params)
 {
-	short maxval = 0;
+	int maxval = 0;
 	unsigned int i;
 
 	assert(params != NULL);
 
 	/* Find the maximum value in the table */
 	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++) {
-		short val = params->fpn_config.data[i];
+		int val = params->fpn_config.data[i];
 		/* Make sure FPN value can be represented in 13-bit unsigned
 		 * number (ISP precision - 1), but note that actual input range
 		 * depends on precision of input frame data.
@@ -1412,7 +1418,7 @@ convert_raw_to_fpn(struct ia_css_isp_parameters *params)
 	params->fpn_config.shift = 0;
 	while (maxval > 63) {
 /* MW: BUG, is "63" a system or application property */
-		maxval /= 2;
+		maxval >>= 1;
 		params->fpn_config.shift++;
 	}
 	/* Adjust the values in the table for the shift value */
@@ -2383,21 +2389,23 @@ sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
 
 #if !defined(IS_ISP_2500_SYSTEM)
 static void
-sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
-			   const struct ia_css_dvs_6axis_config  *dvs_config)
+sh_css_set_pipe_dvs_6axis_config(const struct ia_css_pipe *pipe,
+							struct ia_css_isp_parameters *params,
+							const struct ia_css_dvs_6axis_config  *dvs_config)
 {
 	if (dvs_config == NULL)
 		return;
 	assert(params != NULL);
+	assert(pipe != NULL);
 	assert(dvs_config->height_y == dvs_config->height_uv);
 	assert((dvs_config->width_y - 1) == 2 * (dvs_config->width_uv - 1));
 
 	IA_CSS_ENTER_PRIVATE("dvs_config=%p", dvs_config);
 
-	copy_dvs_6axis_table(params->dvs_6axis_config, dvs_config);
+	copy_dvs_6axis_table(params->pipe_dvs_6axis_config[pipe->mode], dvs_config);
 
 #if !defined(HAS_NO_DVS_6AXIS_CONFIG_UPDATE)
-	params->dvs_6axis_config_changed = true;
+	params->pipe_dvs_6axis_config_changed[pipe->mode] = true;
 #endif
 
 	IA_CSS_LEAVE_PRIVATE("void");
@@ -2406,27 +2414,29 @@ sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
 
 #if !defined(IS_ISP_2500_SYSTEM)
 static void
-sh_css_get_dvs_6axis_config(const struct ia_css_isp_parameters *params,
+sh_css_get_pipe_dvs_6axis_config(const struct ia_css_pipe *pipe,
+				const struct ia_css_isp_parameters *params,
 				struct ia_css_dvs_6axis_config *dvs_config)
 {
 	if (dvs_config == NULL)
 		return;
 	assert(params != NULL);
+	assert(pipe != NULL);
 	assert(dvs_config->height_y == dvs_config->height_uv);
 	assert((dvs_config->width_y - 1) == 2 * dvs_config->width_uv - 1);
 
 	IA_CSS_ENTER_PRIVATE("dvs_config=%p", dvs_config);
 
-	if ((dvs_config->width_y == params->dvs_6axis_config->width_y) &&
-	    (dvs_config->height_y == params->dvs_6axis_config->height_y) &&
-	    (dvs_config->width_uv == params->dvs_6axis_config->width_uv) &&
-	    (dvs_config->height_uv == params->dvs_6axis_config->height_uv) &&
+	if ((dvs_config->width_y == params->pipe_dvs_6axis_config[pipe->mode]->width_y) &&
+	    (dvs_config->height_y == params->pipe_dvs_6axis_config[pipe->mode]->height_y) &&
+	    (dvs_config->width_uv == params->pipe_dvs_6axis_config[pipe->mode]->width_uv) &&
+	    (dvs_config->height_uv == params->pipe_dvs_6axis_config[pipe->mode]->height_uv) &&
 	     dvs_config->xcoords_y &&
 	     dvs_config->ycoords_y &&
 	     dvs_config->xcoords_uv &&
 	     dvs_config->ycoords_uv)
 	{
-		copy_dvs_6axis_table(dvs_config, params->dvs_6axis_config);
+		copy_dvs_6axis_table(dvs_config, params->pipe_dvs_6axis_config[pipe->mode]);
 	}
 
 	IA_CSS_LEAVE_PRIVATE("void");
@@ -2604,12 +2614,6 @@ ia_css_pipe_set_isp_config(struct ia_css_pipe *pipe,
 
 	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config=%p\n", config);
 
-	/* When pipe config and stream configs are seperated the below assignement
-	 * pipe_in = NULL can be removed
-	 */
-	if(pipe->stream->config.continuous)
-		pipe_in = NULL;
-
 #if defined(SH_CSS_ENABLE_PER_FRAME_PARAMS)
 	if (config->output_frame)
 		err = sh_css_set_per_frame_isp_config_on_pipe(pipe->stream, config, pipe);
@@ -2714,8 +2718,8 @@ sh_css_init_isp_params_from_config(struct ia_css_pipe *pipe,
 	sh_css_set_nr_config(params, config->nr_config);
 	sh_css_set_ee_config(params, config->ee_config);
 	sh_css_set_baa_config(params, config->baa_config);
-	if (params->dvs_6axis_config)
-		sh_css_set_dvs_6axis_config(params, config->dvs_6axis_config);
+	if (params->pipe_dvs_6axis_config[pipe->mode])
+		sh_css_set_pipe_dvs_6axis_config(pipe, params, config->dvs_6axis_config);
 	sh_css_set_dz_config(params, config->dz_config);
 	sh_css_set_motion_vector(params, config->motion_vector);
 	sh_css_set_shading_table(pipe->stream, params, config->shading_table);
@@ -2771,7 +2775,7 @@ ia_css_pipe_get_isp_config(struct ia_css_pipe *pipe,
 #else
 	sh_css_get_ee_config(params, config->ee_config);
 	sh_css_get_baa_config(params, config->baa_config);
-	sh_css_get_dvs_6axis_config(params, config->dvs_6axis_config);
+	sh_css_get_pipe_dvs_6axis_config(pipe, params, config->dvs_6axis_config);
 	sh_css_get_macc_table(params, config->macc_table);
 	sh_css_get_gamma_table(params, config->gamma_table);
 	sh_css_get_ctc_table(params, config->ctc_table);
@@ -3067,7 +3071,6 @@ enum ia_css_err
 ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 {
 	enum ia_css_err err = IA_CSS_SUCCESS;
-	unsigned isp_pipe_version = SH_CSS_ISP_PIPE_VERSION_1;
 	unsigned i;
 	struct sh_css_ddr_address_map *ddr_ptrs;
 	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
@@ -3084,17 +3087,6 @@ ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
 	g_param_buffer_dequeue_count = 0;
 	g_param_buffer_enqueue_count = 0;
 
-	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
-	/* this code assumes that all the pipes have the same pipeversion. */
-	for (i = 1; i < (unsigned)stream->num_pipes; i++) {
-	    assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(stream->pipes[i]));
-	}
-
-	/* done once */
-#if !defined(IS_ISP_2500_SYSTEM)
-	sh_css_params_reconfigure_gdc_lut();
-#endif
-
 	stream->per_frame_isp_params_configs = NULL;
 	err = sh_css_create_isp_params(stream,
 				       &stream->isp_params_configs);
@@ -3233,6 +3225,7 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		bool use_default_config)
 {
 #if !defined(IS_ISP_2500_SYSTEM)
+	int i = 0;
 	unsigned isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
 #endif
 	struct ia_css_isp_parameters *stream_params = stream->isp_params_configs;
@@ -3292,7 +3285,6 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		ia_css_set_formats_config(params, &default_formats_config);
 		ia_css_set_param_exceptions(params);
 
-		/* gdc_lut_store is moved to ia_css_stream_isp_parameters_init() */
 		params->fpn_config.data = NULL;
 		params->config_changed[IA_CSS_FPN_ID] = true;
 		params->fpn_config.enabled = 0;
@@ -3306,9 +3298,6 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 		params->sc_table = NULL;
 		params->sc_table_changed = true;
 
-		params->dvs_6axis_config = NULL;
-		params->dvs_6axis_config_changed = true;
-
 		ia_css_sdis2_clear_coefficients(&params->dvs2_coefs);
 		params->dvs2_coef_table_changed = true;
 
@@ -3367,8 +3356,6 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 
 		ia_css_set_param_exceptions(params);
 
-		/* gdc_lut_store is moved to ia_css_stream_isp_parameters_init() */
-
 		params->fpn_config.data = stream_params->fpn_config.data;
 		params->config_changed[IA_CSS_FPN_ID] = stream_params->config_changed[IA_CSS_FPN_ID];
 		params->fpn_config.enabled = stream_params->fpn_config.enabled;
@@ -3384,9 +3371,13 @@ sh_css_init_isp_params_from_global(struct ia_css_stream *stream,
 			params->sc_table_changed = true;
 		}
 
-		if (stream_params->dvs_6axis_config)
-			params->dvs_6axis_config = generate_dvs_6axis_table_from_config(stream_params->dvs_6axis_config);
-
+		/* Only IA_CSS_PIPE_ID_VIDEO & IA_CSS_PIPE_ID_CAPTURE will support dvs_6axis_config*/
+		for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+			if (stream_params->pipe_dvs_6axis_config[i]) {
+				params->pipe_dvs_6axis_config[i] =
+						generate_dvs_6axis_table_from_config(stream_params->pipe_dvs_6axis_config[i]);
+				}
+		}
 		ia_css_set_sdis_config(params, &stream_params->dvs_coefs);
 		params->dis_coef_table_changed = stream_params->dis_coef_table_changed;
 
@@ -3454,16 +3445,120 @@ sh_css_params_init(void)
 }
 
 #if !defined(IS_ISP_2500_SYSTEM)
-void sh_css_params_reconfigure_gdc_lut(void)
+static void host_lut_store(const void *lut)
 {
 	unsigned i;
 
+	for (i = 0; i < N_GDC_ID; i++)
+		gdc_lut_store((gdc_ID_t)i, (const int (*)[HRT_GDC_N]) lut);
+}
+#endif
+
+enum ia_css_err ia_css_pipe_set_bci_scaler_lut(struct ia_css_pipe *pipe,
+	const void *lut)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+	bool store = true;
+	IA_CSS_ENTER("pipe=%p lut=%p", pipe, lut);
+
+	if (lut == NULL || pipe == NULL) {
+		err = IA_CSS_ERR_INVALID_ARGUMENTS;
+		IA_CSS_LEAVE("err=%d", err);
+		return err;
+	}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+	/* If the pipe belongs to a stream and the stream has started, it is not
+	 * safe to store lut to gdc HW. If pipe->stream is NULL, then no stream is
+	 * created with this pipe, so it is safe to do this operation. */
+	if (pipe->stream && pipe->stream->started) {
+		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
+			"unable to set scaler lut since stream has started\n");
+		store = false;
+		err = IA_CSS_ERR_NOT_SUPPORTED;
+	}
+
+	/* Free any existing tables. */
+	if (pipe->scaler_pp_lut != mmgr_NULL) {
+		mmgr_free(pipe->scaler_pp_lut);
+		pipe->scaler_pp_lut = mmgr_NULL;
+	}
+
+	if (store) {
+		pipe->scaler_pp_lut = mmgr_malloc(sizeof(zoom_table));
+		if (pipe->scaler_pp_lut == mmgr_NULL) {
+			IA_CSS_LEAVE("lut(%p) err=%d", pipe->scaler_pp_lut, err);
+			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+		}
+
+		gdc_lut_convert_to_isp_format((const int(*)[HRT_GDC_N])lut, interleaved_lut_temp);
+		mmgr_store(pipe->scaler_pp_lut, (int *)interleaved_lut_temp,
+			sizeof(zoom_table));
+	}
+#endif
+
+	IA_CSS_LEAVE("lut(%p) err=%d store(%d)", pipe->scaler_pp_lut, err, store);
+	return err;
+}
+
+/* if pipe is NULL, returns default lut addr. */
+hrt_vaddress sh_css_pipe_get_pp_gdc_lut(const struct ia_css_pipe *pipe)
+{
+#if !defined(IS_ISP_2500_SYSTEM)
+	assert(pipe != NULL);
+
+	if (pipe->scaler_pp_lut != mmgr_NULL)
+		return pipe->scaler_pp_lut;
+	else
+		return sh_css_params_get_default_gdc_lut();
+#else
+	NOT_USED(pipe);
+	return mmgr_NULL;
+#endif
+}
+
+#if !defined(IS_ISP_2500_SYSTEM)
+enum ia_css_err sh_css_params_map_and_store_default_gdc_lut(void)
+{
+	enum ia_css_err err = IA_CSS_SUCCESS;
+
 	IA_CSS_ENTER_PRIVATE("void");
 
-	for (i = 0; i < N_GDC_ID; i++)
-		gdc_lut_store((gdc_ID_t)i, zoom_table);
+	/* Is table already mapped? Nothing to do if it is mapped. */
+	if (default_gdc_lut != mmgr_NULL)
+		return err;
+
+	host_lut_store((void *)zoom_table);
+
+	default_gdc_lut = mmgr_malloc(sizeof(zoom_table));
+	if (default_gdc_lut == mmgr_NULL)
+		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
+
+	gdc_lut_convert_to_isp_format((const int(*)[HRT_GDC_N])zoom_table,
+		interleaved_lut_temp);
+	mmgr_store(default_gdc_lut, (int *)interleaved_lut_temp,
+		sizeof(zoom_table));
+
+	IA_CSS_LEAVE_PRIVATE("lut(%p) err=%d", default_gdc_lut, err);
+	return err;
+}
+
+void sh_css_params_free_default_gdc_lut(void)
+{
+	IA_CSS_ENTER_PRIVATE("void");
+
+	if (default_gdc_lut != mmgr_NULL) {
+		mmgr_free(default_gdc_lut);
+		default_gdc_lut = mmgr_NULL;
+	}
 
 	IA_CSS_LEAVE_PRIVATE("void");
+
+}
+
+hrt_vaddress sh_css_params_get_default_gdc_lut(void)
+{
+	return default_gdc_lut;
 }
 #endif
 
@@ -3505,7 +3600,7 @@ sh_css_param_clear_param_sets(void)
 	do {                  \
 		ia_css_refcount_decrement(id, x);     \
 		(x) = mmgr_NULL;  \
-	} while (0)
+	} while(0)
 
 static void free_map(struct sh_css_ddr_address_map *map)
 {
@@ -3546,6 +3641,11 @@ ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
 		free_map(&params->pipe_ddr_ptrs[i]);
 		if (per_frame_params)
 			free_map(&per_frame_params->pipe_ddr_ptrs[i]);
+		/* Free up theDVS table memory blocks before recomputing new table */
+		if (params->pipe_dvs_6axis_config[i])
+			free_dvs_6axis_table(&(params->pipe_dvs_6axis_config[i]));
+		if (per_frame_params && per_frame_params->pipe_dvs_6axis_config[i])
+			free_dvs_6axis_table(&(per_frame_params->pipe_dvs_6axis_config[i]));
 	}
 	free_map(&params->ddr_ptrs);
 	if (per_frame_params)
@@ -3561,12 +3661,6 @@ ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
 	stripe_table_release();
 #endif
 
-	/* Free up theDVS table memory blocks before recomputing new table */
-	if (params->dvs_6axis_config)
-		free_dvs_6axis_table(&(params->dvs_6axis_config));
-	if (per_frame_params && per_frame_params->dvs_6axis_config)
-		free_dvs_6axis_table(&(per_frame_params->dvs_6axis_config));
-
 	/* Free up sc_config (temporal shading table) if it is allocated. */
 	if (params->sc_config) {
 		ia_css_shading_table_free(params->sc_config);
@@ -3861,12 +3955,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 
 	IA_CSS_ENTER_PRIVATE("pipe=%p, isp_parameters_id=%d", pipe_in, params->isp_parameters_id);
 	raw_bit_depth = ia_css_stream_input_format_bits_per_pixel(curr_pipe->stream);
-	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(curr_pipe);
-	/* this code assuemes that all the pipes have the same pipeversion. */
-	for (i = 1; i < curr_pipe->stream->num_pipes; i++) {
-		assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(curr_pipe->stream->pipes[i]));
-	}
-
 
 	/* now make the map available to the sp */
 	if (!commit) {
@@ -3889,6 +3977,7 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		pipe = curr_pipe->stream->pipes[i];
 		pipeline = ia_css_pipe_get_pipeline(pipe);
 		pipe_num = ia_css_pipe_get_pipe_num(pipe);
+		isp_pipe_version = ia_css_pipe_get_isp_pipe_version(pipe);
 		ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);
 #if defined(IS_ISP_2500_SYSTEM)
 		if (ia_css_pipeline_is_mapped(pipe_num) == false) {
@@ -3938,7 +4027,7 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 			if (err != IA_CSS_SUCCESS)
 			    return err;
 		}
-#else
+#endif
 		/* check if to actually update the parameters for this pipe */
 		/* When API change is implemented making good distinction between
 		* stream config and pipe config this skipping code can be moved out of the #ifdef */
@@ -3946,7 +4035,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 			IA_CSS_LOG("skipping pipe %x", pipe);
 			continue;
 		}
-#endif
 
 		/* BZ 125915, should be moved till after "update other buff" */
 		/* update the other buffers to the pipe specific copies */
@@ -4003,13 +4091,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		}
 #endif
 
-		/* check if to actually update the parameters for this pipe */
-		/* When API change is implemented making good distinction between
-		* stream config and pipe config this skipping code can be removed */
-		if (pipe_in && (pipe != pipe_in)) {
-			IA_CSS_LOG("skipping pipe %x", pipe);
-			continue;
-		}
 		/* last make referenced copy */
 		err = ref_sh_css_ddr_address_map(
 				cur_map,
@@ -4073,6 +4154,7 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 		}
 		/* clean-up old copy */
 		ia_css_dequeue_param_buffers(/*pipe_num*/);
+		params->pipe_dvs_6axis_config_changed[pipeline->pipe_id] = false;
 	} /* end for each 'active' pipeline */
 	/* clear the changed flags after all params
 	for all pipelines have been updated */
@@ -4083,7 +4165,6 @@ sh_css_param_update_isp_params(struct ia_css_pipe *curr_pipe,
 	params->morph_table_changed = false;
 	params->dz_config_changed = false;
 	params->motion_config_changed = false;
-	params->dvs_6axis_config_changed = false;
 /* ------ deprecated(bz675) : from ------ */
 	params->shading_settings_changed = false;
 /* ------ deprecated(bz675) : to ------ */
@@ -4113,7 +4194,6 @@ sh_css_params_write_to_ddr_internal(
 #if !defined(IS_ISP_2500_SYSTEM)
 	/* struct is > 128 bytes so it should not be on stack (see checkpatch) */
 	static struct ia_css_macc_table converted_macc_table;
-	(void)pipe;
 #endif
 
 	IA_CSS_ENTER_PRIVATE("void");
@@ -4236,7 +4316,7 @@ sh_css_params_write_to_ddr_internal(
 					(const struct ia_css_shading_table *)params->sc_table,
 					params->sensor_binning,
 					&params->sc_config,
-					binary);
+					binary, pipe->required_bds_factor);
 				if (params->sc_config == NULL) {
 					IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
 					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
@@ -4271,16 +4351,16 @@ sh_css_params_write_to_ddr_internal(
 
 			if (binary->info->sp.pipeline.isp_pipe_version == SH_CSS_ISP_PIPE_VERSION_1) {
 				converted_macc_table.data[idx] =
-				  sDIGIT_FITTING(params->macc_table.data[j],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx+1] =
-				  sDIGIT_FITTING(params->macc_table.data[j+1],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j+1],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx+2] =
-				  sDIGIT_FITTING(params->macc_table.data[j+2],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j+2],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 				converted_macc_table.data[idx+3] =
-				  sDIGIT_FITTING(params->macc_table.data[j+3],
+				  (int16_t)sDIGIT_FITTING(params->macc_table.data[j+3],
 				  13, SH_CSS_MACC_COEF_SHIFT);
 			} else if (binary->info->sp.pipeline.isp_pipe_version == SH_CSS_ISP_PIPE_VERSION_2_2) {
 				converted_macc_table.data[idx] =
@@ -4316,31 +4396,48 @@ sh_css_params_write_to_ddr_internal(
 				&ddr_map->dvs_6axis_params_y,
 				&ddr_map_size->dvs_6axis_params_y,
 				(size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3),
-				params->dvs_6axis_config_changed,
+				params->pipe_dvs_6axis_config_changed[pipe_id],
 				&err);
 		if (err != IA_CSS_SUCCESS) {
 			IA_CSS_LEAVE_ERR_PRIVATE(err);
 			return err;
 		}
-		if (params->dvs_6axis_config_changed || buff_realloced) {
-			if (params->dvs_6axis_config == NULL) /* Generate default DVS unity table on start up*/
-			{
-				struct ia_css_resolution dvs_offset;
-				dvs_offset.width  = (PIX_SHIFT_FILTER_RUN_IN_X + binary->dvs_envelope.width) / 2;
-				dvs_offset.height = (PIX_SHIFT_FILTER_RUN_IN_Y + binary->dvs_envelope.height) / 2;
 
-				params->dvs_6axis_config = generate_dvs_6axis_table(&binary->out_frame_info[0].res,
-										    &dvs_offset);
-				if (params->dvs_6axis_config == NULL) {
+		if (params->pipe_dvs_6axis_config_changed[pipe_id] || buff_realloced) {
+			const struct ia_css_frame_info *dvs_in_frame_info;
+
+			if ( stage->args.delay_frames[0] ) {
+				/*When delay frames are present(as in case of video),
+				they are used for dvs. Configure DVS using those params*/
+				dvs_in_frame_info = &stage->args.delay_frames[0]->info;
+			} else {
+				/*Otherwise, use input frame to configure DVS*/
+				dvs_in_frame_info = &stage->args.in_frame->info;
+			}
+
+			/* Generate default DVS unity table on start up*/
+			if (params->pipe_dvs_6axis_config[pipe_id] == NULL) {
+
+				struct ia_css_resolution dvs_offset;
+				dvs_offset.width  =
+						(PIX_SHIFT_FILTER_RUN_IN_X + binary->dvs_envelope.width) / 2;
+				dvs_offset.height =
+						(PIX_SHIFT_FILTER_RUN_IN_Y + binary->dvs_envelope.height) / 2;
+
+				params->pipe_dvs_6axis_config[pipe_id] =
+						generate_dvs_6axis_table(&binary->out_frame_info[0].res, &dvs_offset);
+				if (params->pipe_dvs_6axis_config[pipe_id] == NULL) {
 					IA_CSS_LEAVE_ERR_PRIVATE(IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
 					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
 				}
-				params->dvs_6axis_config_changed = true;
+				params->pipe_dvs_6axis_config_changed[pipe_id] = true;
 			}
 
-			store_dvs_6axis_config(params,
-						binary,
-						ddr_map->dvs_6axis_params_y);
+			store_dvs_6axis_config(params->pipe_dvs_6axis_config[pipe_id],
+				binary,
+				dvs_in_frame_info,
+				ddr_map->dvs_6axis_params_y);
+			params->isp_params_changed = true;
 		}
 	}
 
@@ -4520,6 +4617,20 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream *stre
 /* ------ deprecated(bz675) : from ------ */
 		const struct ia_css_binary *binary
 			= ia_css_stream_get_shading_correction_binary(stream);
+		struct ia_css_pipe *pipe;
+
+		/**********************************************************************/
+		/* following code is copied from function ia_css_stream_get_shading_correction_binary()
+		 * to match with the binary */
+		pipe = stream->pipes[0];
+
+		if (stream->num_pipes == 2) {
+			assert(stream->pipes[1] != NULL);
+			if (stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_VIDEO ||
+			    stream->pipes[1]->config.mode == IA_CSS_PIPE_MODE_PREVIEW)
+				pipe = stream->pipes[1];
+		}
+		/**********************************************************************/
 		if (binary) {
 			if (params->sc_config) {
 				ia_css_shading_table_free(params->sc_config);
@@ -4529,7 +4640,7 @@ struct ia_css_shading_table *ia_css_get_shading_table(struct ia_css_stream *stre
 				(const struct ia_css_shading_table *)params->sc_table,
 				params->sensor_binning,
 				&params->sc_config,
-				binary);
+				binary, pipe->required_bds_factor);
 
 			table = params->sc_config;
 			/* The sc_config will be freed in the
@@ -4698,9 +4809,11 @@ sh_css_invalidate_params(struct ia_css_stream *stream)
 	params->motion_config_changed = true;
 
 	/*Free up theDVS table memory blocks before recomputing new table  */
-	if (params->dvs_6axis_config)
-		free_dvs_6axis_table(&(params->dvs_6axis_config));
-	params->dvs_6axis_config_changed = true;
+	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
+		if (params->pipe_dvs_6axis_config[i])
+			free_dvs_6axis_table(&(params->pipe_dvs_6axis_config[i]));
+			params->pipe_dvs_6axis_config_changed[i] = true;
+	}
 
 	IA_CSS_LEAVE_PRIVATE("void");
 }
@@ -5224,7 +5337,8 @@ ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
 	assert(stream != NULL);
 	params = stream->isp_params_configs;
 
-	if (!params || (params && !params->dvs_6axis_config)) {
+	/* Backward compatibility by default consider pipe as Video*/
+	if (!params || (params && !params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO])) {
 		goto err;
 	}
 
@@ -5232,10 +5346,10 @@ ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
 	if (!dvs_config)
 		goto err;
 
-	dvs_config->width_y = width_y = params->dvs_6axis_config->width_y;
-	dvs_config->height_y = height_y = params->dvs_6axis_config->height_y;
-	dvs_config->width_uv = width_uv = params->dvs_6axis_config->width_uv;
-	dvs_config->height_uv = height_uv = params->dvs_6axis_config->height_uv;
+	dvs_config->width_y = width_y = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_y;
+	dvs_config->height_y = height_y = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_y;
+	dvs_config->width_uv = width_uv = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->width_uv;
+	dvs_config->height_uv = height_uv = params->pipe_dvs_6axis_config[IA_CSS_PIPE_ID_VIDEO]->height_uv;
 	IA_CSS_LOG("table Y: W %d H %d", width_y, height_y);
 	IA_CSS_LOG("table UV: W %d H %d", width_uv, height_uv);
 	dvs_config->xcoords_y = (uint32_t *)sh_css_malloc(width_y * height_y * sizeof(uint32_t));
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.h b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.h
index 30f362e..8ffcbdf 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.h
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_params.h
@@ -84,9 +84,8 @@ struct ia_css_isp_parameters {
 	struct ia_css_anr_config    anr_config;
 	struct ia_css_ce_config     ce_config;
 	struct ia_css_formats_config     formats_config;
-
+/* ---- deprecated: replaced with pipe_dvs_6axis_config---- */
 	struct ia_css_dvs_6axis_config  *dvs_6axis_config;
-
 	struct ia_css_ecd_config    ecd_config;
 	struct ia_css_ynr_config    ynr_config;
 	struct ia_css_yee_config    yee_config;
@@ -110,6 +109,7 @@ struct ia_css_isp_parameters {
 	struct ia_css_2500_lin_kernel_config  lin_2500_config;
 	struct ia_css_2500_tnr_kernel_config  tnr_2500_config;
 #endif
+	struct ia_css_dvs_6axis_config  *pipe_dvs_6axis_config[IA_CSS_PIPE_ID_NUM];
 /* ------ deprecated(bz675) : from ------ */
 	struct ia_css_shading_settings shading_settings;
 /* ------ deprecated(bz675) : to ------ */
@@ -126,10 +126,12 @@ struct ia_css_isp_parameters {
 	bool morph_table_changed;
 	bool sc_table_changed;
 	bool anr_thres_changed;
+/* ---- deprecated: replaced with pipe_dvs_6axis_config_changed ---- */
 	bool dvs_6axis_config_changed;
 /* ------ deprecated(bz675) : from ------ */
 	bool shading_settings_changed;
 /* ------ deprecated(bz675) : to ------ */
+	bool pipe_dvs_6axis_config_changed[IA_CSS_PIPE_ID_NUM];
 
 	bool config_changed[IA_CSS_NUM_PARAMETER_IDS];
 
@@ -162,4 +164,16 @@ ia_css_params_alloc_convert_sctbl(
 struct ia_css_isp_config *
 sh_css_pipe_isp_config_get(struct ia_css_pipe *pipe);
 
+enum ia_css_err
+sh_css_params_map_and_store_default_gdc_lut(void);
+
+void
+sh_css_params_free_default_gdc_lut(void);
+
+hrt_vaddress
+sh_css_params_get_default_gdc_lut(void);
+
+hrt_vaddress
+sh_css_pipe_get_pp_gdc_lut(const struct ia_css_pipe *pipe);
+
 #endif /* _SH_CSS_PARAMS_H_ */
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_sp.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_sp.c
index bbb2a30..8f42d3d 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_sp.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/sh_css_sp.c
@@ -971,7 +971,7 @@ sh_css_sp_init_stage(struct ia_css_binary *binary,
 
 	/* Make sure binary name is smaller than allowed string size */
 	assert(strlen(binary_name) < SH_CSS_MAX_BINARY_NAME-1);
-	strncpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME);
+	strncpy(sh_css_isp_stage.binary_name, binary_name, SH_CSS_MAX_BINARY_NAME-1);
 	sh_css_isp_stage.binary_name[SH_CSS_MAX_BINARY_NAME - 1] = 0;
 	sh_css_isp_stage.mem_initializers = *isp_mem_if;
 
@@ -1191,6 +1191,7 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 	/* Get first stage */
 	struct ia_css_pipeline_stage *stage        = NULL;
 	struct ia_css_binary	     *first_binary = NULL;
+	struct ia_css_pipe *pipe = NULL;
 	unsigned num;
 
 	enum ia_css_pipe_id pipe_id = id;
@@ -1274,6 +1275,13 @@ sh_css_sp_init_pipeline(struct ia_css_pipeline *me,
 
 	sh_css_sp_group.pipe[thread_id].inout_port_config = me->inout_port_config;
 
+	pipe = find_pipe_by_num(pipe_num);
+	assert(pipe != NULL);
+	if (pipe == NULL) {
+		return;
+	}
+	sh_css_sp_group.pipe[thread_id].scaler_pp_lut = sh_css_pipe_get_pp_gdc_lut(pipe);
+
 #if defined(SH_CSS_ENABLE_METADATA)
 	if (md_info != NULL && md_info->size > 0) {
 		sh_css_sp_group.pipe[thread_id].metadata.width  = md_info->resolution.width;
diff --git a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c
index af53ff4..4d234e9 100644
--- a/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c
+++ b/drivers/external_drivers/camera/drivers/media/pci/atomisp2/css2401a0_v21/spmem_dump.c
@@ -22,118 +22,118 @@
 
 #define _hrt_cell_load_program_sp(proc) _hrt_cell_load_program_embedded(proc, sp)
 
-/* function longjmp: 6457 */
+/* function longjmp: 6823 */
 
-/* function tmpmem_init_dmem: 61F3 */
+/* function tmpmem_init_dmem: 656E */
 
-/* function ia_css_dmaproxy_sp_set_addr_B: 3915 */
+/* function ia_css_dmaproxy_sp_set_addr_B: 3BB8 */
 
 /* function debug_buffer_set_ddr_addr: DD */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_mipi
 #define HIVE_MEM_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_mipi 0x7340
+#define HIVE_ADDR_vbuf_mipi 0x7388
 #define HIVE_SIZE_vbuf_mipi 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_mipi scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_mipi 0x7340
+#define HIVE_ADDR_sp_vbuf_mipi 0x7388
 #define HIVE_SIZE_sp_vbuf_mipi 12
 
-/* function ia_css_event_sp_decode: 3AEA */
+/* function ia_css_event_sp_decode: 3DA9 */
 
-/* function ia_css_queue_get_size: 4DA5 */
+/* function ia_css_queue_get_size: 5118 */
 
-/* function ia_css_queue_load: 53E6 */
+/* function ia_css_queue_load: 5759 */
 
-/* function setjmp: 6460 */
+/* function setjmp: 682C */
 
-/* function ia_css_pipeline_sp_sfi_get_current_frame: 26C4 */
+/* function ia_css_pipeline_sp_sfi_get_current_frame: 27A6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_isys_event_queue
 #define HIVE_MEM_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x571C
+#define HIVE_ADDR_sem_for_sp2host_isys_event_queue 0x5760
 #define HIVE_SIZE_sem_for_sp2host_isys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_isys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x571C
+#define HIVE_ADDR_sp_sem_for_sp2host_isys_event_queue 0x5760
 #define HIVE_SIZE_sp_sem_for_sp2host_isys_event_queue 20
 
-/* function ia_css_dmaproxy_sp_wait_for_ack: 69AC */
+/* function ia_css_dmaproxy_sp_wait_for_ack: 6DBF */
 
-/* function ia_css_sp_rawcopy_func: 5551 */
+/* function ia_css_sp_rawcopy_func: 58C4 */
 
-/* function ia_css_tagger_buf_sp_pop_marked: 3074 */
+/* function ia_css_tagger_buf_sp_pop_marked: 326B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_CSI_RX_BE_SID_WIDTH
 #define HIVE_MEM_N_CSI_RX_BE_SID_WIDTH scalar_processor_2400_dmem
-#define HIVE_ADDR_N_CSI_RX_BE_SID_WIDTH 0x1D4
+#define HIVE_ADDR_N_CSI_RX_BE_SID_WIDTH 0x1D0
 #define HIVE_SIZE_N_CSI_RX_BE_SID_WIDTH 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_N_CSI_RX_BE_SID_WIDTH scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_N_CSI_RX_BE_SID_WIDTH 0x1D4
+#define HIVE_ADDR_sp_N_CSI_RX_BE_SID_WIDTH 0x1D0
 #define HIVE_SIZE_sp_N_CSI_RX_BE_SID_WIDTH 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stage
 #define HIVE_MEM_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stage 0x6C40
+#define HIVE_ADDR_isp_stage 0x6C88
 #define HIVE_SIZE_isp_stage 832
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stage scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stage 0x6C40
+#define HIVE_ADDR_sp_isp_stage 0x6C88
 #define HIVE_SIZE_sp_isp_stage 832
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_raw
 #define HIVE_MEM_vbuf_raw scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_raw 0x37C
+#define HIVE_ADDR_vbuf_raw 0x378
 #define HIVE_SIZE_vbuf_raw 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_raw scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_raw 0x37C
+#define HIVE_ADDR_sp_vbuf_raw 0x378
 #define HIVE_SIZE_sp_vbuf_raw 4
 
-/* function ia_css_sp_bin_copy_func: 5532 */
+/* function ia_css_sp_bin_copy_func: 58A5 */
 
-/* function ia_css_queue_item_store: 5134 */
+/* function ia_css_queue_item_store: 54A7 */
 
-/* function input_system_reset: 1278 */
+/* function input_system_reset: 1286 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5AF4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5B38
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_metadata_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5AF4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 0x5B38
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_metadata_bufs 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5B08
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5B4C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_buffer_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5B08
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 0x5B4C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_buffer_bufs 160
 
 /* function sp_start_isp: 39C */
@@ -141,108 +141,108 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_binary_group
 #define HIVE_MEM_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_binary_group 0x7030
+#define HIVE_ADDR_sp_binary_group 0x7078
 #define HIVE_SIZE_sp_binary_group 32
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_binary_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_binary_group 0x7030
+#define HIVE_ADDR_sp_sp_binary_group 0x7078
 #define HIVE_SIZE_sp_sp_binary_group 32
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sw_state
 #define HIVE_MEM_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sw_state 0x72EC
+#define HIVE_ADDR_sp_sw_state 0x7334
 #define HIVE_SIZE_sp_sw_state 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sw_state scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sw_state 0x72EC
+#define HIVE_ADDR_sp_sp_sw_state 0x7334
 #define HIVE_SIZE_sp_sp_sw_state 4
 
-/* function ia_css_thread_sp_main: 13E9 */
+/* function ia_css_thread_sp_main: 13F7 */
 
-/* function ia_css_ispctrl_sp_init_internal_buffers: 3CF0 */
+/* function ia_css_ispctrl_sp_init_internal_buffers: 3FAF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_psys_event_queue_handle
 #define HIVE_MEM_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x5BA8
+#define HIVE_ADDR_sp2host_psys_event_queue_handle 0x5BEC
 #define HIVE_SIZE_sp2host_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x5BA8
+#define HIVE_ADDR_sp_sp2host_psys_event_queue_handle 0x5BEC
 #define HIVE_SIZE_sp_sp2host_psys_event_queue_handle 12
 
-/* function pixelgen_unit_test: E5A */
+/* function pixelgen_unit_test: E68 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp2host_psys_event_queue
 #define HIVE_MEM_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x5730
+#define HIVE_ADDR_sem_for_sp2host_psys_event_queue 0x5774
 #define HIVE_SIZE_sem_for_sp2host_psys_event_queue 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp2host_psys_event_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x5730
+#define HIVE_ADDR_sp_sem_for_sp2host_psys_event_queue 0x5774
 #define HIVE_SIZE_sp_sem_for_sp2host_psys_event_queue 20
 
-/* function ia_css_tagger_sp_propagate_frame: 2B8B */
+/* function ia_css_tagger_sp_propagate_frame: 2D0B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_stop_copy_preview
 #define HIVE_MEM_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_stop_copy_preview 0x72D0
+#define HIVE_ADDR_sp_stop_copy_preview 0x7318
 #define HIVE_SIZE_sp_stop_copy_preview 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_stop_copy_preview scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_stop_copy_preview 0x72D0
+#define HIVE_ADDR_sp_sp_stop_copy_preview 0x7318
 #define HIVE_SIZE_sp_sp_stop_copy_preview 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_handles
 #define HIVE_MEM_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_handles 0x734C
+#define HIVE_ADDR_vbuf_handles 0x7394
 #define HIVE_SIZE_vbuf_handles 960
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_handles scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_handles 0x734C
+#define HIVE_ADDR_sp_vbuf_handles 0x7394
 #define HIVE_SIZE_sp_vbuf_handles 960
 
-/* function ia_css_queue_store: 529A */
+/* function ia_css_queue_store: 560D */
 
-/* function ia_css_sp_flash_register: 328E */
+/* function ia_css_sp_flash_register: 34D9 */
 
-/* function ia_css_sp_rawcopy_dummy_function: 599A */
+/* function ia_css_sp_rawcopy_dummy_function: 5D0D */
 
-/* function ia_css_pipeline_sp_init: 1F44 */
+/* function ia_css_pipeline_sp_init: 2003 */
 
-/* function ia_css_tagger_sp_configure: 2A88 */
+/* function ia_css_tagger_sp_configure: 2BFB */
 
-/* function ia_css_ispctrl_sp_end_binary: 3B33 */
+/* function ia_css_ispctrl_sp_end_binary: 3DF2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5BB4
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5BF8
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5BB4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 0x5BF8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_per_frame_ddr_ptrs 20
 
-/* function pixelgen_tpg_run: F10 */
+/* function pixelgen_tpg_run: F1E */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_is_pending_mask
@@ -259,70 +259,70 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_frame
 #define HIVE_MEM_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_frame 0x5744
+#define HIVE_ADDR_sp_all_cb_elems_frame 0x5788
 #define HIVE_SIZE_sp_all_cb_elems_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x5744
+#define HIVE_ADDR_sp_sp_all_cb_elems_frame 0x5788
 #define HIVE_SIZE_sp_sp_all_cb_elems_frame 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_isys_event_queue_handle
 #define HIVE_MEM_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x5BC8
+#define HIVE_ADDR_sp2host_isys_event_queue_handle 0x5C0C
 #define HIVE_SIZE_sp2host_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x5BC8
+#define HIVE_ADDR_sp_sp2host_isys_event_queue_handle 0x5C0C
 #define HIVE_SIZE_sp_sp2host_isys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_com
 #define HIVE_MEM_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_com 0x3E18
+#define HIVE_ADDR_host_sp_com 0x3E48
 #define HIVE_SIZE_host_sp_com 220
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_com scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_com 0x3E18
+#define HIVE_ADDR_sp_host_sp_com 0x3E48
 #define HIVE_SIZE_sp_host_sp_com 220
 
-/* function ia_css_queue_get_free_space: 4EF9 */
+/* function ia_css_queue_get_free_space: 526C */
 
 /* function exec_image_pipe: 5E6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_init_dmem_data
 #define HIVE_MEM_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_init_dmem_data 0x72F0
+#define HIVE_ADDR_sp_init_dmem_data 0x7338
 #define HIVE_SIZE_sp_init_dmem_data 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_init_dmem_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_init_dmem_data 0x72F0
+#define HIVE_ADDR_sp_sp_init_dmem_data 0x7338
 #define HIVE_SIZE_sp_sp_init_dmem_data 24
 
-/* function ia_css_sp_metadata_start: 5A74 */
+/* function ia_css_sp_metadata_start: 5DE7 */
 
-/* function ia_css_bufq_sp_init_buffer_queues: 32DF */
+/* function ia_css_bufq_sp_init_buffer_queues: 352A */
 
-/* function ia_css_pipeline_sp_stop: 1F27 */
+/* function ia_css_pipeline_sp_stop: 1FE6 */
 
-/* function ia_css_tagger_sp_connect_pipes: 2EFD */
+/* function ia_css_tagger_sp_connect_pipes: 30D4 */
 
 /* function sp_isys_copy_wait: 644 */
 
 /* function is_isp_debug_buffer_full: 337 */
 
-/* function ia_css_dmaproxy_sp_configure_channel_from_info: 3898 */
+/* function ia_css_dmaproxy_sp_configure_channel_from_info: 3B3B */
 
-/* function encode_and_post_timer_event: A9A */
+/* function encode_and_post_timer_event: AA8 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_input_system_bz2788_active
@@ -339,69 +339,69 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_IBUF_CTRL_PROCS
 #define HIVE_MEM_N_IBUF_CTRL_PROCS scalar_processor_2400_dmem
-#define HIVE_ADDR_N_IBUF_CTRL_PROCS 0x200
+#define HIVE_ADDR_N_IBUF_CTRL_PROCS 0x1FC
 #define HIVE_SIZE_N_IBUF_CTRL_PROCS 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_N_IBUF_CTRL_PROCS scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_N_IBUF_CTRL_PROCS 0x200
+#define HIVE_ADDR_sp_N_IBUF_CTRL_PROCS 0x1FC
 #define HIVE_SIZE_sp_N_IBUF_CTRL_PROCS 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_per_frame_data
 #define HIVE_MEM_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_per_frame_data 0x3EF4
+#define HIVE_ADDR_sp_per_frame_data 0x3F24
 #define HIVE_SIZE_sp_per_frame_data 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_per_frame_data scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_per_frame_data 0x3EF4
+#define HIVE_ADDR_sp_sp_per_frame_data 0x3F24
 #define HIVE_SIZE_sp_sp_per_frame_data 4
 
-/* function ia_css_rmgr_sp_vbuf_dequeue: 5F4F */
+/* function ia_css_rmgr_sp_vbuf_dequeue: 62C2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_psys_event_queue_handle
 #define HIVE_MEM_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x5BD4
+#define HIVE_ADDR_host2sp_psys_event_queue_handle 0x5C18
 #define HIVE_SIZE_host2sp_psys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_psys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x5BD4
+#define HIVE_ADDR_sp_host2sp_psys_event_queue_handle 0x5C18
 #define HIVE_SIZE_sp_host2sp_psys_event_queue_handle 12
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_xmem_bin_addr
 #define HIVE_MEM_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_xmem_bin_addr 0x3EF8
+#define HIVE_ADDR_xmem_bin_addr 0x3F28
 #define HIVE_SIZE_xmem_bin_addr 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_xmem_bin_addr scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_xmem_bin_addr 0x3EF8
+#define HIVE_ADDR_sp_xmem_bin_addr 0x3F28
 #define HIVE_SIZE_sp_xmem_bin_addr 4
 
-/* function tmr_clock_init: 16E3 */
+/* function tmr_clock_init: 16F9 */
 
-/* function ia_css_pipeline_sp_run: 1A91 */
+/* function ia_css_pipeline_sp_run: 1AB8 */
 
-/* function memcpy: 6500 */
+/* function memcpy: 68CC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_ISYS2401_DMA_CHANNEL_PROCS
 #define HIVE_MEM_N_ISYS2401_DMA_CHANNEL_PROCS scalar_processor_2400_dmem
-#define HIVE_ADDR_N_ISYS2401_DMA_CHANNEL_PROCS 0x218
+#define HIVE_ADDR_N_ISYS2401_DMA_CHANNEL_PROCS 0x214
 #define HIVE_SIZE_N_ISYS2401_DMA_CHANNEL_PROCS 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_N_ISYS2401_DMA_CHANNEL_PROCS scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_N_ISYS2401_DMA_CHANNEL_PROCS 0x218
+#define HIVE_ADDR_sp_N_ISYS2401_DMA_CHANNEL_PROCS 0x214
 #define HIVE_SIZE_sp_N_ISYS2401_DMA_CHANNEL_PROCS 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -419,68 +419,68 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_ready_queue
 #define HIVE_MEM_ia_css_thread_sp_ready_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_ready_queue 0x27C
+#define HIVE_ADDR_ia_css_thread_sp_ready_queue 0x278
 #define HIVE_SIZE_ia_css_thread_sp_ready_queue 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_ready_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x27C
+#define HIVE_ADDR_sp_ia_css_thread_sp_ready_queue 0x278
 #define HIVE_SIZE_sp_ia_css_thread_sp_ready_queue 12
 
-/* function stream2mmio_send_command: DFC */
+/* function stream2mmio_send_command: E0A */
 
-/* function ia_css_uds_sp_scale_params: 6209 */
+/* function ia_css_uds_sp_scale_params: 65D5 */
 
-/* function ia_css_circbuf_increase_size: 14CE */
+/* function ia_css_circbuf_increase_size: 14DC */
 
-/* function __divu: 647E */
+/* function __divu: 684A */
 
-/* function ia_css_thread_sp_get_state: 1311 */
+/* function ia_css_thread_sp_get_state: 131F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_stop
 #define HIVE_MEM_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_stop 0x5754
+#define HIVE_ADDR_sem_for_cont_capt_stop 0x5798
 #define HIVE_SIZE_sem_for_cont_capt_stop 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_stop scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x5754
+#define HIVE_ADDR_sp_sem_for_cont_capt_stop 0x5798
 #define HIVE_SIZE_sp_sem_for_cont_capt_stop 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_SHORT_PACKET_LUT_ENTRIES
 #define HIVE_MEM_N_SHORT_PACKET_LUT_ENTRIES scalar_processor_2400_dmem
-#define HIVE_ADDR_N_SHORT_PACKET_LUT_ENTRIES 0x1B0
+#define HIVE_ADDR_N_SHORT_PACKET_LUT_ENTRIES 0x1AC
 #define HIVE_SIZE_N_SHORT_PACKET_LUT_ENTRIES 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_N_SHORT_PACKET_LUT_ENTRIES scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_N_SHORT_PACKET_LUT_ENTRIES 0x1B0
+#define HIVE_ADDR_sp_N_SHORT_PACKET_LUT_ENTRIES 0x1AC
 #define HIVE_SIZE_sp_N_SHORT_PACKET_LUT_ENTRIES 12
 
-/* function thread_fiber_sp_main: 14C7 */
+/* function thread_fiber_sp_main: 14D5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_pipe_thread
 #define HIVE_MEM_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pipe_thread 0x5898
+#define HIVE_ADDR_sp_isp_pipe_thread 0x58DC
 #define HIVE_SIZE_sp_isp_pipe_thread 340
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_pipe_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x5898
+#define HIVE_ADDR_sp_sp_isp_pipe_thread 0x58DC
 #define HIVE_SIZE_sp_sp_isp_pipe_thread 340
 
-/* function ia_css_parambuf_sp_handle_parameter_sets: 192A */
+/* function ia_css_parambuf_sp_handle_parameter_sets: 193F */
 
-/* function ia_css_spctrl_sp_set_state: 5A90 */
+/* function ia_css_spctrl_sp_set_state: 5E03 */
 
-/* function ia_css_thread_sem_sp_signal: 66E3 */
+/* function ia_css_thread_sem_sp_signal: 6AAF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_IRQ_BASE
@@ -494,7 +494,7 @@
 #define HIVE_ADDR_sp_IRQ_BASE 0x2C
 #define HIVE_SIZE_sp_IRQ_BASE 16
 
-/* function ia_css_virtual_isys_sp_isr_init: 5B2F */
+/* function ia_css_virtual_isys_sp_isr_init: 5EA2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_TIMED_CTRL_BASE
@@ -508,11 +508,11 @@
 #define HIVE_ADDR_sp_TIMED_CTRL_BASE 0x40
 #define HIVE_SIZE_sp_TIMED_CTRL_BASE 4
 
-/* function ia_css_isys_sp_generate_exp_id: 5DDF */
+/* function ia_css_isys_sp_generate_exp_id: 6152 */
 
-/* function ia_css_rmgr_sp_init: 5E4A */
+/* function ia_css_rmgr_sp_init: 61BD */
 
-/* function ia_css_thread_sem_sp_init: 67B4 */
+/* function ia_css_thread_sem_sp_init: 6B80 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_is_isp_requested
@@ -529,107 +529,109 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_frame
 #define HIVE_MEM_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_frame 0x5768
+#define HIVE_ADDR_sem_for_reading_cb_frame 0x57AC
 #define HIVE_SIZE_sem_for_reading_cb_frame 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x5768
+#define HIVE_ADDR_sp_sem_for_reading_cb_frame 0x57AC
 #define HIVE_SIZE_sp_sem_for_reading_cb_frame 40
 
-/* function ia_css_dmaproxy_sp_execute: 3800 */
+/* function ia_css_dmaproxy_sp_execute: 3AA3 */
 
-/* function csi_rx_backend_rst: CD8 */
+/* function csi_rx_backend_rst: CE6 */
 
-/* function ia_css_queue_is_empty: 4DE0 */
+/* function ia_css_queue_is_empty: 5153 */
 
-/* function ia_css_pipeline_sp_has_stopped: 1F1D */
+/* function ia_css_pipeline_sp_has_stopped: 1FDC */
 
-/* function ia_css_circbuf_extract: 15CE */
+/* function ia_css_circbuf_extract: 15E0 */
 
-/* function ia_css_tagger_buf_sp_is_locked_from_start: 31BB */
+/* function ia_css_tagger_buf_sp_is_locked_from_start: 33BA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_sp_thread
 #define HIVE_MEM_current_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_current_sp_thread 0x278
+#define HIVE_ADDR_current_sp_thread 0x274
 #define HIVE_SIZE_current_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_sp_thread 0x278
+#define HIVE_ADDR_sp_current_sp_thread 0x274
 #define HIVE_SIZE_sp_current_sp_thread 4
 
-/* function ia_css_spctrl_sp_get_spid: 5A97 */
+/* function ia_css_spctrl_sp_get_spid: 5E0A */
 
-/* function ia_css_dmaproxy_sp_read_byte_addr: 69DA */
+/* function ia_css_bufq_sp_reset_buffers: 35B1 */
 
-/* function ia_css_rmgr_sp_uninit: 5E43 */
+/* function ia_css_dmaproxy_sp_read_byte_addr: 6DED */
+
+/* function ia_css_rmgr_sp_uninit: 61B6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack
 #define HIVE_MEM_sp_threads_stack scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_stack 0x168
+#define HIVE_ADDR_sp_threads_stack 0x164
 #define HIVE_SIZE_sp_threads_stack 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_stack scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_stack 0x168
+#define HIVE_ADDR_sp_sp_threads_stack 0x164
 #define HIVE_SIZE_sp_sp_threads_stack 24
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_STREAM2MMIO_SID_PROCS
 #define HIVE_MEM_N_STREAM2MMIO_SID_PROCS scalar_processor_2400_dmem
-#define HIVE_ADDR_N_STREAM2MMIO_SID_PROCS 0x21C
+#define HIVE_ADDR_N_STREAM2MMIO_SID_PROCS 0x218
 #define HIVE_SIZE_N_STREAM2MMIO_SID_PROCS 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_N_STREAM2MMIO_SID_PROCS scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_N_STREAM2MMIO_SID_PROCS 0x21C
+#define HIVE_ADDR_sp_N_STREAM2MMIO_SID_PROCS 0x218
 #define HIVE_SIZE_sp_N_STREAM2MMIO_SID_PROCS 12
 
-/* function ia_css_circbuf_peek: 15B0 */
+/* function ia_css_circbuf_peek: 15C2 */
 
-/* function ia_css_parambuf_sp_wait_for_in_param: 16F2 */
+/* function ia_css_parambuf_sp_wait_for_in_param: 1708 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cb_elems_param
 #define HIVE_MEM_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cb_elems_param 0x5790
+#define HIVE_ADDR_sp_all_cb_elems_param 0x57D4
 #define HIVE_SIZE_sp_all_cb_elems_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cb_elems_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x5790
+#define HIVE_ADDR_sp_sp_all_cb_elems_param 0x57D4
 #define HIVE_SIZE_sp_sp_all_cb_elems_param 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_pipeline_sp_curr_binary_id
 #define HIVE_MEM_pipeline_sp_curr_binary_id scalar_processor_2400_dmem
-#define HIVE_ADDR_pipeline_sp_curr_binary_id 0x288
+#define HIVE_ADDR_pipeline_sp_curr_binary_id 0x284
 #define HIVE_SIZE_pipeline_sp_curr_binary_id 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_pipeline_sp_curr_binary_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_pipeline_sp_curr_binary_id 0x288
+#define HIVE_ADDR_sp_pipeline_sp_curr_binary_id 0x284
 #define HIVE_SIZE_sp_pipeline_sp_curr_binary_id 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame_desc
 #define HIVE_MEM_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame_desc 0x57A0
+#define HIVE_ADDR_sp_all_cbs_frame_desc 0x57E4
 #define HIVE_SIZE_sp_all_cbs_frame_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x57A0
+#define HIVE_ADDR_sp_sp_all_cbs_frame_desc 0x57E4
 #define HIVE_SIZE_sp_sp_all_cbs_frame_desc 8
 
 /* function sp_isys_copy_func_v2: 629 */
@@ -637,170 +639,172 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_cb_param
 #define HIVE_MEM_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_cb_param 0x57A8
+#define HIVE_ADDR_sem_for_reading_cb_param 0x57EC
 #define HIVE_SIZE_sem_for_reading_cb_param 40
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x57A8
+#define HIVE_ADDR_sp_sem_for_reading_cb_param 0x57EC
 #define HIVE_SIZE_sp_sem_for_reading_cb_param 40
 
-/* function ia_css_queue_get_used_space: 4EAD */
+/* function ia_css_queue_get_used_space: 5220 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_cont_capt_start
 #define HIVE_MEM_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_cont_capt_start 0x57D0
+#define HIVE_ADDR_sem_for_cont_capt_start 0x5814
 #define HIVE_SIZE_sem_for_cont_capt_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_cont_capt_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x57D0
+#define HIVE_ADDR_sp_sem_for_cont_capt_start 0x5814
 #define HIVE_SIZE_sp_sem_for_cont_capt_start 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tmp_heap
 #define HIVE_MEM_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_tmp_heap 0x7050
+#define HIVE_ADDR_tmp_heap 0x7098
 #define HIVE_SIZE_tmp_heap 640
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tmp_heap scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tmp_heap 0x7050
+#define HIVE_ADDR_sp_tmp_heap 0x7098
 #define HIVE_SIZE_sp_tmp_heap 640
 
-/* function ia_css_rmgr_sp_get_num_vbuf: 614B */
+/* function ia_css_rmgr_sp_get_num_vbuf: 64C6 */
 
-/* function ia_css_ispctrl_sp_output_compute_dma_info: 4456 */
+/* function ia_css_ispctrl_sp_output_compute_dma_info: 47C9 */
 
-/* function ia_css_tagger_sp_lock_exp_id: 28B0 */
+/* function ia_css_tagger_sp_lock_exp_id: 29E6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5BE0
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5C24
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_s3a_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5BE0
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 0x5C24
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_s3a_bufs 60
 
-/* function ia_css_queue_is_full: 4F44 */
+/* function ia_css_queue_is_full: 52B7 */
 
 /* function debug_buffer_init_isp: E4 */
 
-/* function ia_css_tagger_sp_exp_id_is_locked: 27FE */
+/* function ia_css_tagger_sp_exp_id_is_locked: 292C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem
 #define HIVE_MEM_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x770C
+#define HIVE_ADDR_ia_css_rmgr_sp_mipi_frame_sem 0x7754
 #define HIVE_SIZE_ia_css_rmgr_sp_mipi_frame_sem 60
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rmgr_sp_mipi_frame_sem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x770C
+#define HIVE_ADDR_sp_ia_css_rmgr_sp_mipi_frame_sem 0x7754
 #define HIVE_SIZE_sp_ia_css_rmgr_sp_mipi_frame_sem 60
 
-/* function ia_css_rmgr_sp_refcount_dump: 5F2A */
+/* function ia_css_rmgr_sp_refcount_dump: 629D */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5C1C
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5C60
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5C1C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 0x5C60
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_isp_parameters_id 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_pipe_threads
 #define HIVE_MEM_sp_pipe_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_pipe_threads 0x154
+#define HIVE_ADDR_sp_pipe_threads 0x150
 #define HIVE_SIZE_sp_pipe_threads 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_pipe_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_pipe_threads 0x154
+#define HIVE_ADDR_sp_sp_pipe_threads 0x150
 #define HIVE_SIZE_sp_sp_pipe_threads 20
 
-/* function sp_event_proxy_func: 783 */
+/* function sp_event_proxy_func: 78D */
 
-/* function ibuf_ctrl_run: D71 */
+/* function ibuf_ctrl_run: D7F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_isys_event_queue_handle
 #define HIVE_MEM_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x5C30
+#define HIVE_ADDR_host2sp_isys_event_queue_handle 0x5C74
 #define HIVE_SIZE_host2sp_isys_event_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_isys_event_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x5C30
+#define HIVE_ADDR_sp_host2sp_isys_event_queue_handle 0x5C74
 #define HIVE_SIZE_sp_host2sp_isys_event_queue_handle 12
 
-/* function ia_css_thread_sp_yield: 665C */
+/* function ia_css_thread_sp_yield: 6A28 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param_desc
 #define HIVE_MEM_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param_desc 0x57E4
+#define HIVE_ADDR_sp_all_cbs_param_desc 0x5828
 #define HIVE_SIZE_sp_all_cbs_param_desc 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param_desc scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x57E4
+#define HIVE_ADDR_sp_sp_all_cbs_param_desc 0x5828
 #define HIVE_SIZE_sp_sp_all_cbs_param_desc 8
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb
 #define HIVE_MEM_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x6C34
+#define HIVE_ADDR_ia_css_dmaproxy_sp_invalidate_tlb 0x6C78
 #define HIVE_SIZE_ia_css_dmaproxy_sp_invalidate_tlb 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_sp_invalidate_tlb scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x6C34
+#define HIVE_ADDR_sp_ia_css_dmaproxy_sp_invalidate_tlb 0x6C78
 #define HIVE_SIZE_sp_ia_css_dmaproxy_sp_invalidate_tlb 4
 
-/* function ia_css_thread_sp_fork: 139E */
+/* function ia_css_thread_sp_fork: 13AC */
 
-/* function ia_css_tagger_sp_destroy: 2F07 */
+/* function ia_css_tagger_sp_destroy: 30DE */
 
-/* function ia_css_dmaproxy_sp_vmem_read: 37A0 */
+/* function ia_css_dmaproxy_sp_vmem_read: 3A43 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_LONG_PACKET_LUT_ENTRIES
 #define HIVE_MEM_N_LONG_PACKET_LUT_ENTRIES scalar_processor_2400_dmem
-#define HIVE_ADDR_N_LONG_PACKET_LUT_ENTRIES 0x1BC
+#define HIVE_ADDR_N_LONG_PACKET_LUT_ENTRIES 0x1B8
 #define HIVE_SIZE_N_LONG_PACKET_LUT_ENTRIES 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_N_LONG_PACKET_LUT_ENTRIES scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_N_LONG_PACKET_LUT_ENTRIES 0x1BC
+#define HIVE_ADDR_sp_N_LONG_PACKET_LUT_ENTRIES 0x1B8
 #define HIVE_SIZE_sp_N_LONG_PACKET_LUT_ENTRIES 12
 
 /* function initialize_sp_group: 5F6 */
 
-/* function ia_css_thread_sp_init: 13CA */
+/* function ia_css_thread_sp_init: 13D8 */
+
+/* function ia_css_isys_sp_reset_exp_id: 6149 */
 
-/* function ia_css_isys_sp_reset_exp_id: 5DD6 */
+/* function qos_scheduler_update_fps: 65C5 */
 
-/* function ia_css_ispctrl_sp_set_stream_base_addr: 4B1E */
+/* function ia_css_ispctrl_sp_set_stream_base_addr: 4E91 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_DMEM_BASE
@@ -826,48 +830,48 @@
 #define HIVE_ADDR_sp_SP_DMEM_BASE 0x4
 #define HIVE_SIZE_sp_SP_DMEM_BASE 4
 
-/* function ibuf_ctrl_transfer: D59 */
+/* function ibuf_ctrl_transfer: D67 */
 
-/* function ia_css_dmaproxy_sp_read: 3816 */
+/* function ia_css_dmaproxy_sp_read: 3AB9 */
 
-/* function virtual_isys_stream_is_capture_done: 5B53 */
+/* function virtual_isys_stream_is_capture_done: 5EC6 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_raw_copy_line_count
 #define HIVE_MEM_raw_copy_line_count scalar_processor_2400_dmem
-#define HIVE_ADDR_raw_copy_line_count 0x360
+#define HIVE_ADDR_raw_copy_line_count 0x35C
 #define HIVE_SIZE_raw_copy_line_count 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_raw_copy_line_count scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_raw_copy_line_count 0x360
+#define HIVE_ADDR_sp_raw_copy_line_count 0x35C
 #define HIVE_SIZE_sp_raw_copy_line_count 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_tag_cmd_queue_handle
 #define HIVE_MEM_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x5C3C
+#define HIVE_ADDR_host2sp_tag_cmd_queue_handle 0x5C80
 #define HIVE_SIZE_host2sp_tag_cmd_queue_handle 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_tag_cmd_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x5C3C
+#define HIVE_ADDR_sp_host2sp_tag_cmd_queue_handle 0x5C80
 #define HIVE_SIZE_sp_host2sp_tag_cmd_queue_handle 12
 
-/* function ia_css_queue_peek: 4E23 */
+/* function ia_css_queue_peek: 5196 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_frame_cnt
 #define HIVE_MEM_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x5AE8
+#define HIVE_ADDR_ia_css_flash_sp_frame_cnt 0x5B2C
 #define HIVE_SIZE_ia_css_flash_sp_frame_cnt 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_frame_cnt scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x5AE8
+#define HIVE_ADDR_sp_ia_css_flash_sp_frame_cnt 0x5B2C
 #define HIVE_SIZE_sp_ia_css_flash_sp_frame_cnt 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -882,66 +886,66 @@
 #define HIVE_ADDR_sp_event_can_send_token_mask 0x88
 #define HIVE_SIZE_sp_event_can_send_token_mask 44
 
-/* function csi_rx_frontend_stop: C03 */
+/* function csi_rx_frontend_stop: C11 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_thread
 #define HIVE_MEM_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_thread 0x6F80
+#define HIVE_ADDR_isp_thread 0x6FC8
 #define HIVE_SIZE_isp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_thread 0x6F80
+#define HIVE_ADDR_sp_isp_thread 0x6FC8
 #define HIVE_SIZE_sp_isp_thread 4
 
-/* function encode_and_post_sp_event_non_blocking: AE2 */
+/* function encode_and_post_sp_event_non_blocking: AF0 */
 
 /* function is_ddr_debug_buffer_full: 2CC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_fiber
 #define HIVE_MEM_sp_threads_fiber scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_fiber 0x198
+#define HIVE_ADDR_sp_threads_fiber 0x194
 #define HIVE_SIZE_sp_threads_fiber 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_fiber scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_fiber 0x198
+#define HIVE_ADDR_sp_sp_threads_fiber 0x194
 #define HIVE_SIZE_sp_sp_threads_fiber 24
 
-/* function encode_and_post_sp_event: A6B */
+/* function encode_and_post_sp_event: A79 */
 
 /* function debug_enqueue_ddr: EE */
 
-/* function ia_css_rmgr_sp_refcount_init_vbuf: 5EE5 */
+/* function ia_css_rmgr_sp_refcount_init_vbuf: 6258 */
 
-/* function dmaproxy_sp_read_write: 6A65 */
+/* function dmaproxy_sp_read_write: 6E9C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer
 #define HIVE_MEM_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6C38
+#define HIVE_ADDR_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6C7C
 #define HIVE_SIZE_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_dmaproxy_isp_dma_cmd_buffer scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6C38
+#define HIVE_ADDR_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 0x6C7C
 #define HIVE_SIZE_sp_ia_css_dmaproxy_isp_dma_cmd_buffer 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host2sp_buffer_queue_handle
 #define HIVE_MEM_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_host2sp_buffer_queue_handle 0x5C48
+#define HIVE_ADDR_host2sp_buffer_queue_handle 0x5C8C
 #define HIVE_SIZE_host2sp_buffer_queue_handle 480
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host2sp_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x5C48
+#define HIVE_ADDR_sp_host2sp_buffer_queue_handle 0x5C8C
 #define HIVE_SIZE_sp_host2sp_buffer_queue_handle 480
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -956,55 +960,55 @@
 #define HIVE_ADDR_sp_ia_css_flash_sp_in_service 0x3054
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_service 4
 
-/* function ia_css_dmaproxy_sp_process: 67DC */
+/* function ia_css_dmaproxy_sp_process: 6BA8 */
 
-/* function ia_css_tagger_buf_sp_mark_from_end: 3268 */
+/* function ia_css_tagger_buf_sp_mark_from_end: 349E */
 
-/* function ia_css_ispctrl_sp_init_cs: 3C20 */
+/* function ia_css_ispctrl_sp_init_cs: 3EDF */
 
-/* function ia_css_spctrl_sp_init: 5AA5 */
+/* function ia_css_spctrl_sp_init: 5E18 */
 
-/* function sp_event_proxy_init: 798 */
+/* function sp_event_proxy_init: 7A2 */
 
-/* function input_system_input_port_close: 108D */
+/* function input_system_input_port_close: 109B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_previous_clock_tick
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_previous_clock_tick scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x5E28
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x5E6C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_previous_clock_tick 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x5E28
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 0x5E6C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_previous_clock_tick 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_output
 #define HIVE_MEM_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_output 0x3EFC
+#define HIVE_ADDR_sp_output 0x3F2C
 #define HIVE_SIZE_sp_output 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_output scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_output 0x3EFC
+#define HIVE_ADDR_sp_sp_output 0x3F2C
 #define HIVE_SIZE_sp_sp_output 16
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5E3C
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5E80
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5E3C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 0x5E80
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_host2sp_buf_queues 800
 
-/* function pixelgen_prbs_config: E85 */
+/* function pixelgen_prbs_config: E93 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_CTRL_BASE
@@ -1030,53 +1034,53 @@
 #define HIVE_ADDR_sp_INPUT_FORMATTER_BASE 0x4C
 #define HIVE_SIZE_sp_INPUT_FORMATTER_BASE 16
 
-/* function sp_dma_proxy_reset_channels: 3A54 */
+/* function sp_dma_proxy_reset_channels: 3D13 */
 
-/* function ia_css_tagger_sp_update_size: 2FE9 */
+/* function ia_css_tagger_sp_update_size: 31D2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_host_sp_queue
 #define HIVE_MEM_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x615C
+#define HIVE_ADDR_ia_css_bufq_host_sp_queue 0x61A0
 #define HIVE_SIZE_ia_css_bufq_host_sp_queue 2008
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_host_sp_queue scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x615C
+#define HIVE_ADDR_sp_ia_css_bufq_host_sp_queue 0x61A0
 #define HIVE_SIZE_sp_ia_css_bufq_host_sp_queue 2008
 
-/* function thread_fiber_sp_create: 1436 */
+/* function thread_fiber_sp_create: 1444 */
 
-/* function ia_css_dmaproxy_sp_set_increments: 3902 */
+/* function ia_css_dmaproxy_sp_set_increments: 3BA5 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_frame
 #define HIVE_MEM_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_frame 0x57EC
+#define HIVE_ADDR_sem_for_writing_cb_frame 0x5830
 #define HIVE_SIZE_sem_for_writing_cb_frame 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x57EC
+#define HIVE_ADDR_sp_sem_for_writing_cb_frame 0x5830
 #define HIVE_SIZE_sp_sem_for_writing_cb_frame 20
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_writing_cb_param
 #define HIVE_MEM_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_writing_cb_param 0x5800
+#define HIVE_ADDR_sem_for_writing_cb_param 0x5844
 #define HIVE_SIZE_sem_for_writing_cb_param 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_writing_cb_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x5800
+#define HIVE_ADDR_sp_sem_for_writing_cb_param 0x5844
 #define HIVE_SIZE_sp_sem_for_writing_cb_param 20
 
-/* function pixelgen_tpg_is_done: EFF */
+/* function pixelgen_tpg_is_done: F0D */
 
-/* function ia_css_isys_stream_capture_indication: 5C59 */
+/* function ia_css_isys_stream_capture_indication: 5FCC */
 
 /* function sp_start_isp_entry: 392 */
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1086,51 +1090,53 @@
 #endif
 #define HIVE_ADDR_sp_sp_start_isp_entry 0x392
 
-/* function ia_css_tagger_buf_sp_unmark_all: 3201 */
+/* function ia_css_tagger_buf_sp_unmark_all: 3422 */
 
-/* function ia_css_tagger_buf_sp_unmark_from_start: 3242 */
+/* function ia_css_tagger_buf_sp_unmark_from_start: 3463 */
 
-/* function ia_css_dmaproxy_sp_channel_acquire: 3A80 */
+/* function ia_css_dmaproxy_sp_channel_acquire: 3D3F */
 
-/* function ia_css_rmgr_sp_add_num_vbuf: 6127 */
+/* function ia_css_rmgr_sp_add_num_vbuf: 64A2 */
 
-/* function ibuf_ctrl_config: D7D */
+/* function ibuf_ctrl_config: D8B */
 
-/* function ia_css_isys_stream_stop: 5CD1 */
+/* function ia_css_isys_stream_stop: 6044 */
 
-/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 376C */
+/* function __ia_css_dmaproxy_sp_wait_for_ack_text: 3A0F */
 
-/* function ia_css_bufq_sp_is_dynamic_buffer: 3655 */
+/* function ia_css_tagger_sp_acquire_buf_elem: 2904 */
+
+/* function ia_css_bufq_sp_is_dynamic_buffer: 38F8 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_group
 #define HIVE_MEM_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_group 0x3F0C
-#define HIVE_SIZE_sp_group 6156
+#define HIVE_ADDR_sp_group 0x3F3C
+#define HIVE_SIZE_sp_group 6176
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_group 0x3F0C
-#define HIVE_SIZE_sp_sp_group 6156
+#define HIVE_ADDR_sp_sp_group 0x3F3C
+#define HIVE_SIZE_sp_sp_group 6176
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_event_proxy_thread
 #define HIVE_MEM_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_event_proxy_thread 0x59EC
+#define HIVE_ADDR_sp_event_proxy_thread 0x5A30
 #define HIVE_SIZE_sp_event_proxy_thread 68
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_event_proxy_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_event_proxy_thread 0x59EC
+#define HIVE_ADDR_sp_sp_event_proxy_thread 0x5A30
 #define HIVE_SIZE_sp_sp_event_proxy_thread 68
 
-/* function ia_css_thread_sp_kill: 1364 */
+/* function ia_css_thread_sp_kill: 1372 */
 
-/* function ia_css_tagger_sp_create: 2FAC */
+/* function ia_css_tagger_sp_create: 318C */
 
-/* function tmpmem_acquire_dmem: 61D4 */
+/* function tmpmem_acquire_dmem: 654F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_MMU_BASE
@@ -1144,29 +1150,31 @@
 #define HIVE_ADDR_sp_MMU_BASE 0x24
 #define HIVE_SIZE_sp_MMU_BASE 8
 
-/* function ia_css_dmaproxy_sp_channel_release: 3A6C */
+/* function ia_css_dmaproxy_sp_channel_release: 3D2B */
 
-/* function pixelgen_prbs_run: E73 */
+/* function pixelgen_prbs_run: E81 */
 
-/* function ia_css_dmaproxy_sp_is_idle: 3A4C */
+/* function ia_css_dmaproxy_sp_is_idle: 3D0B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_qos_start
 #define HIVE_MEM_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_qos_start 0x5814
+#define HIVE_ADDR_sem_for_qos_start 0x5858
 #define HIVE_SIZE_sem_for_qos_start 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_qos_start scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_qos_start 0x5814
+#define HIVE_ADDR_sp_sem_for_qos_start 0x5858
 #define HIVE_SIZE_sp_sem_for_qos_start 20
 
-/* function isp_hmem_load: B55 */
+/* function isp_hmem_load: B63 */
+
+/* function ia_css_tagger_sp_release_buf_elem: 28E0 */
 
-/* function ia_css_eventq_sp_send: 3AC2 */
+/* function ia_css_eventq_sp_send: 3D81 */
 
-/* function ia_css_tagger_buf_sp_unlock_from_start: 3177 */
+/* function ia_css_tagger_buf_sp_unlock_from_start: 3352 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_debug_buffer_ddr_address
@@ -1180,33 +1188,33 @@
 #define HIVE_ADDR_sp_debug_buffer_ddr_address 0xBC
 #define HIVE_SIZE_sp_debug_buffer_ddr_address 4
 
-/* function sp_isys_copy_request: 6E3 */
+/* function sp_isys_copy_request: 6ED */
 
-/* function ia_css_rmgr_sp_refcount_retain_vbuf: 5FBF */
+/* function ia_css_rmgr_sp_refcount_retain_vbuf: 6332 */
 
-/* function ia_css_thread_sp_set_priority: 135C */
+/* function ia_css_thread_sp_set_priority: 136A */
 
-/* function sizeof_hmem: BFC */
+/* function sizeof_hmem: C0A */
 
-/* function input_system_channel_open: 1233 */
+/* function input_system_channel_open: 1241 */
 
-/* function pixelgen_tpg_stop: EED */
+/* function pixelgen_tpg_stop: EFB */
 
-/* function tmpmem_release_dmem: 61C3 */
+/* function tmpmem_release_dmem: 653E */
 
-/* function ia_css_dmaproxy_sp_set_width_exception: 38ED */
+/* function ia_css_dmaproxy_sp_set_width_exception: 3B90 */
 
-/* function sp_event_assert: 91F */
+/* function sp_event_assert: 929 */
 
-/* function ia_css_flash_sp_init_internal_params: 32D4 */
+/* function ia_css_flash_sp_init_internal_params: 351F */
 
-/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 3007 */
+/* function ia_css_tagger_buf_sp_pop_unmarked_and_unlocked: 3203 */
 
-/* function __modu: 64C4 */
+/* function __modu: 6890 */
 
-/* function ia_css_dmaproxy_sp_init_isp_vector: 3772 */
+/* function ia_css_dmaproxy_sp_init_isp_vector: 3A15 */
 
-/* function input_system_channel_transfer: 121C */
+/* function input_system_channel_transfer: 122A */
 
 /* function isp_vamem_store: 0 */
 
@@ -1222,57 +1230,59 @@
 #define HIVE_ADDR_sp_GDC_BASE 0x44
 #define HIVE_SIZE_sp_GDC_BASE 8
 
-/* function ia_css_queue_local_init: 510E */
+/* function ia_css_queue_local_init: 5481 */
 
-/* function sp_event_proxy_callout_func: 6591 */
+/* function sp_event_proxy_callout_func: 695D */
+
+/* function qos_scheduler_schedule_stage: 6596 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_thread_sp_num_ready_threads
 #define HIVE_MEM_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x5A34
+#define HIVE_ADDR_ia_css_thread_sp_num_ready_threads 0x5A78
 #define HIVE_SIZE_ia_css_thread_sp_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_thread_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x5A34
+#define HIVE_ADDR_sp_ia_css_thread_sp_num_ready_threads 0x5A78
 #define HIVE_SIZE_sp_ia_css_thread_sp_num_ready_threads 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_threads_stack_size
 #define HIVE_MEM_sp_threads_stack_size scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_threads_stack_size 0x180
+#define HIVE_ADDR_sp_threads_stack_size 0x17C
 #define HIVE_SIZE_sp_threads_stack_size 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_threads_stack_size scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_threads_stack_size 0x180
+#define HIVE_ADDR_sp_sp_threads_stack_size 0x17C
 #define HIVE_SIZE_sp_sp_threads_stack_size 24
 
-/* function ia_css_ispctrl_sp_isp_done_row_striping: 443C */
+/* function ia_css_ispctrl_sp_isp_done_row_striping: 47AF */
 
-/* function __ia_css_virtual_isys_sp_isr_text: 5AE8 */
+/* function __ia_css_virtual_isys_sp_isr_text: 5E5B */
 
-/* function ia_css_queue_dequeue: 4F8C */
+/* function ia_css_queue_dequeue: 52FF */
 
-/* function ia_css_dmaproxy_sp_configure_channel: 69F1 */
+/* function ia_css_dmaproxy_sp_configure_channel: 6E04 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_current_thread_fiber_sp
 #define HIVE_MEM_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_current_thread_fiber_sp 0x5A3C
+#define HIVE_ADDR_current_thread_fiber_sp 0x5A80
 #define HIVE_SIZE_current_thread_fiber_sp 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_current_thread_fiber_sp scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_current_thread_fiber_sp 0x5A3C
+#define HIVE_ADDR_sp_current_thread_fiber_sp 0x5A80
 #define HIVE_SIZE_sp_current_thread_fiber_sp 4
 
-/* function ia_css_circbuf_pop: 165E */
+/* function ia_css_circbuf_pop: 1674 */
 
-/* function memset: 6543 */
+/* function memset: 690F */
 
 /* function irq_raise_set_token: B6 */
 
@@ -1288,105 +1298,105 @@
 #define HIVE_ADDR_sp_GPIO_BASE 0x3C
 #define HIVE_SIZE_sp_GPIO_BASE 4
 
-/* function pixelgen_prbs_stop: E61 */
+/* function pixelgen_prbs_stop: E6F */
 
-/* function ia_css_pipeline_acc_stage_enable: 1EFB */
+/* function ia_css_pipeline_acc_stage_enable: 1FA7 */
 
-/* function ia_css_tagger_sp_unlock_exp_id: 2823 */
+/* function ia_css_tagger_sp_unlock_exp_id: 2951 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_ph
 #define HIVE_MEM_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_ph 0x7308
+#define HIVE_ADDR_isp_ph 0x7350
 #define HIVE_SIZE_isp_ph 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_ph scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_ph 0x7308
+#define HIVE_ADDR_sp_isp_ph 0x7350
 #define HIVE_SIZE_sp_isp_ph 28
 
-/* function ia_css_ispctrl_sp_init_ds: 3D7F */
+/* function ia_css_ispctrl_sp_init_ds: 403E */
 
-/* function get_xmem_base_addr_raw: 410F */
+/* function get_xmem_base_addr_raw: 43DF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_param
 #define HIVE_MEM_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_param 0x5828
+#define HIVE_ADDR_sp_all_cbs_param 0x586C
 #define HIVE_SIZE_sp_all_cbs_param 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_param scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_param 0x5828
+#define HIVE_ADDR_sp_sp_all_cbs_param 0x586C
 #define HIVE_SIZE_sp_sp_all_cbs_param 16
 
-/* function pixelgen_tpg_config: F22 */
+/* function pixelgen_tpg_config: F30 */
 
-/* function ia_css_circbuf_create: 16AC */
+/* function ia_css_circbuf_create: 16C2 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_sp_group
 #define HIVE_MEM_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_sp_group 0x5838
+#define HIVE_ADDR_sem_for_sp_group 0x587C
 #define HIVE_SIZE_sem_for_sp_group 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_sp_group scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_sp_group 0x5838
+#define HIVE_ADDR_sp_sem_for_sp_group 0x587C
 #define HIVE_SIZE_sp_sem_for_sp_group 20
 
-/* function csi_rx_frontend_run: C14 */
+/* function csi_rx_frontend_run: C22 */
 
-/* function ia_css_framebuf_sp_wait_for_in_frame: 6152 */
+/* function ia_css_framebuf_sp_wait_for_in_frame: 64CD */
 
-/* function ia_css_isys_stream_open: 5D86 */
+/* function ia_css_isys_stream_open: 60F9 */
 
-/* function ia_css_sp_rawcopy_tag_frame: 5914 */
+/* function ia_css_sp_rawcopy_tag_frame: 5C87 */
 
-/* function input_system_channel_configure: 124F */
+/* function input_system_channel_configure: 125D */
 
-/* function isp_hmem_clear: B25 */
+/* function isp_hmem_clear: B33 */
 
-/* function ia_css_framebuf_sp_release_in_frame: 6195 */
+/* function ia_css_framebuf_sp_release_in_frame: 6510 */
 
-/* function stream2mmio_config: E0D */
+/* function stream2mmio_config: E1B */
 
-/* function ia_css_ispctrl_sp_start_binary: 3BFE */
+/* function ia_css_ispctrl_sp_start_binary: 3EBD */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs
 #define HIVE_MEM_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x6934
+#define HIVE_ADDR_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x6978
 #define HIVE_SIZE_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x6934
+#define HIVE_ADDR_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 0x6978
 #define HIVE_SIZE_sp_ia_css_bufq_sp_h_pipe_private_ddr_ptrs 20
 
-/* function ia_css_eventq_sp_recv: 3A94 */
+/* function ia_css_eventq_sp_recv: 3D53 */
 
-/* function csi_rx_frontend_config: C6C */
+/* function csi_rx_frontend_config: C7A */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_pool
 #define HIVE_MEM_isp_pool scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_pool 0x370
+#define HIVE_ADDR_isp_pool 0x36C
 #define HIVE_SIZE_isp_pool 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_pool scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_pool 0x370
+#define HIVE_ADDR_sp_isp_pool 0x36C
 #define HIVE_SIZE_sp_isp_pool 4
 
-/* function ia_css_rmgr_sp_rel_gen: 5E8C */
+/* function ia_css_rmgr_sp_rel_gen: 61FF */
 
-/* function css_get_frame_processing_time_end: 27EE */
+/* function css_get_frame_processing_time_end: 28D0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_event_any_pending_mask
@@ -1400,47 +1410,49 @@
 #define HIVE_ADDR_sp_event_any_pending_mask 0x388
 #define HIVE_SIZE_sp_event_any_pending_mask 8
 
-/* function ia_css_pipeline_sp_get_pipe_io_status: 1A8A */
+/* function ia_css_pipeline_sp_get_pipe_io_status: 1AB1 */
 
 /* function sh_css_decode_tag_descr: 352 */
 
 /* function debug_enqueue_isp: 27B */
 
-/* function ia_css_spctrl_sp_uninit: 5A9E */
+/* function qos_scheduler_update_stage_budget: 6584 */
+
+/* function ia_css_spctrl_sp_uninit: 5E11 */
 
-/* function csi_rx_backend_run: C5A */
+/* function csi_rx_backend_run: C68 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x6948
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_dis_bufs 0x698C
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_dis_bufs 140
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_dis_bufs scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x6948
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_dis_bufs 0x698C
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_dis_bufs 140
 
-/* function ia_css_tagger_buf_sp_lock_from_start: 3199 */
+/* function ia_css_tagger_buf_sp_lock_from_start: 3386 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_isp_idle
 #define HIVE_MEM_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_isp_idle 0x584C
+#define HIVE_ADDR_sem_for_isp_idle 0x5890
 #define HIVE_SIZE_sem_for_isp_idle 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_isp_idle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_isp_idle 0x584C
+#define HIVE_ADDR_sp_sem_for_isp_idle 0x5890
 #define HIVE_SIZE_sp_sem_for_isp_idle 20
 
-/* function ia_css_dmaproxy_sp_write_byte_addr: 37CF */
+/* function ia_css_dmaproxy_sp_write_byte_addr: 3A72 */
 
-/* function ia_css_dmaproxy_sp_init: 3746 */
+/* function ia_css_dmaproxy_sp_init: 39E9 */
 
-/* function ia_css_bufq_sp_release_dynamic_buf_clock_tick: 3366 */
+/* function ia_css_bufq_sp_release_dynamic_buf_clock_tick: 35F1 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_VAMEM_BASE
@@ -1454,49 +1466,49 @@
 #define HIVE_ADDR_sp_ISP_VAMEM_BASE 0x14
 #define HIVE_SIZE_sp_ISP_VAMEM_BASE 12
 
-/* function input_system_channel_sync: 1196 */
+/* function input_system_channel_sync: 11A4 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_rawcopy_sp_tagger
 #define HIVE_MEM_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x72D4
+#define HIVE_ADDR_ia_css_rawcopy_sp_tagger 0x731C
 #define HIVE_SIZE_ia_css_rawcopy_sp_tagger 24
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_rawcopy_sp_tagger scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x72D4
+#define HIVE_ADDR_sp_ia_css_rawcopy_sp_tagger 0x731C
 #define HIVE_SIZE_sp_ia_css_rawcopy_sp_tagger 24
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x69D4
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_exp_ids 0x6A18
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_exp_ids 70
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_exp_ids scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x69D4
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_exp_ids 0x6A18
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_exp_ids 70
 
-/* function ia_css_queue_item_load: 5200 */
+/* function ia_css_queue_item_load: 5573 */
 
-/* function ia_css_spctrl_sp_get_state: 5A89 */
+/* function ia_css_spctrl_sp_get_state: 5DFC */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_callout_sp_thread
 #define HIVE_MEM_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_callout_sp_thread 0x5A30
+#define HIVE_ADDR_callout_sp_thread 0x5A74
 #define HIVE_SIZE_callout_sp_thread 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_callout_sp_thread scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_callout_sp_thread 0x5A30
+#define HIVE_ADDR_sp_callout_sp_thread 0x5A74
 #define HIVE_SIZE_sp_callout_sp_thread 4
 
-/* function thread_fiber_sp_init: 14BD */
+/* function thread_fiber_sp_init: 14CB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_SP_PMEM_BASE
@@ -1513,83 +1525,83 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_input_stream_format
 #define HIVE_MEM_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_input_stream_format 0x3DFC
+#define HIVE_ADDR_sp_isp_input_stream_format 0x3E2C
 #define HIVE_SIZE_sp_isp_input_stream_format 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_input_stream_format scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3DFC
+#define HIVE_ADDR_sp_sp_isp_input_stream_format 0x3E2C
 #define HIVE_SIZE_sp_sp_isp_input_stream_format 20
 
-/* function __mod: 64B0 */
+/* function __mod: 687C */
 
-/* function ia_css_dmaproxy_sp_init_dmem_channel: 3830 */
+/* function ia_css_dmaproxy_sp_init_dmem_channel: 3AD3 */
 
-/* function ia_css_thread_sp_join: 138D */
+/* function ia_css_thread_sp_join: 139B */
 
-/* function ia_css_dmaproxy_sp_add_command: 6AD0 */
+/* function ia_css_dmaproxy_sp_add_command: 6F07 */
 
-/* function ia_css_sp_metadata_thread_func: 5A82 */
+/* function ia_css_sp_metadata_thread_func: 5DF5 */
 
-/* function __sp_event_proxy_func_critical: 657E */
+/* function __sp_event_proxy_func_critical: 694A */
 
-/* function ia_css_pipeline_sp_wait_for_isys_stream_N: 5BF6 */
+/* function ia_css_pipeline_sp_wait_for_isys_stream_N: 5F69 */
 
-/* function ia_css_sp_metadata_wait: 5A7B */
+/* function ia_css_sp_metadata_wait: 5DEE */
 
-/* function ia_css_circbuf_peek_from_start: 1592 */
+/* function ia_css_circbuf_peek_from_start: 15A4 */
 
-/* function ia_css_event_sp_encode: 3B1F */
+/* function ia_css_event_sp_encode: 3DDE */
 
-/* function ia_css_thread_sp_run: 1400 */
+/* function ia_css_thread_sp_run: 140E */
 
 /* function sp_isys_copy_func: 618 */
 
-/* function ia_css_sp_isp_param_init_isp_memories: 4C89 */
+/* function ia_css_sp_isp_param_init_isp_memories: 4FFC */
 
-/* function register_isr: 917 */
+/* function register_isr: 921 */
 
 /* function irq_raise: C8 */
 
-/* function ia_css_dmaproxy_sp_mmu_invalidate: 370D */
+/* function ia_css_dmaproxy_sp_mmu_invalidate: 39B0 */
 
-/* function csi_rx_backend_disable: C26 */
+/* function csi_rx_backend_disable: C34 */
 
-/* function pipeline_sp_initialize_stage: 202C */
+/* function pipeline_sp_initialize_stage: 20EB */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_N_CSI_RX_FE_CTRL_DLANES
 #define HIVE_MEM_N_CSI_RX_FE_CTRL_DLANES scalar_processor_2400_dmem
-#define HIVE_ADDR_N_CSI_RX_FE_CTRL_DLANES 0x1C8
+#define HIVE_ADDR_N_CSI_RX_FE_CTRL_DLANES 0x1C4
 #define HIVE_SIZE_N_CSI_RX_FE_CTRL_DLANES 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_N_CSI_RX_FE_CTRL_DLANES scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_N_CSI_RX_FE_CTRL_DLANES 0x1C8
+#define HIVE_ADDR_sp_N_CSI_RX_FE_CTRL_DLANES 0x1C4
 #define HIVE_SIZE_sp_N_CSI_RX_FE_CTRL_DLANES 12
 
-/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 69C3 */
+/* function ia_css_dmaproxy_sp_read_byte_addr_mmio: 6DD6 */
 
-/* function ia_css_ispctrl_sp_done_ds: 3D66 */
+/* function ia_css_ispctrl_sp_done_ds: 4025 */
 
-/* function csi_rx_backend_config: C7D */
+/* function csi_rx_backend_config: C8B */
 
-/* function ia_css_sp_isp_param_get_mem_inits: 4C64 */
+/* function ia_css_sp_isp_param_get_mem_inits: 4FD7 */
 
-/* function ia_css_parambuf_sp_init_buffer_queues: 1A70 */
+/* function ia_css_parambuf_sp_init_buffer_queues: 1A85 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_pfp_spref
 #define HIVE_MEM_vbuf_pfp_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_pfp_spref 0x378
+#define HIVE_ADDR_vbuf_pfp_spref 0x374
 #define HIVE_SIZE_vbuf_pfp_spref 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_pfp_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_pfp_spref 0x378
+#define HIVE_ADDR_sp_vbuf_pfp_spref 0x374
 #define HIVE_SIZE_sp_vbuf_pfp_spref 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
@@ -1607,196 +1619,198 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_pipe_private_frames
 #define HIVE_MEM_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x6A1C
+#define HIVE_ADDR_ia_css_bufq_sp_pipe_private_frames 0x6A60
 #define HIVE_SIZE_ia_css_bufq_sp_pipe_private_frames 280
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_pipe_private_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x6A1C
+#define HIVE_ADDR_sp_ia_css_bufq_sp_pipe_private_frames 0x6A60
 #define HIVE_SIZE_sp_ia_css_bufq_sp_pipe_private_frames 280
 
+/* function qos_scheduler_init_stage_budget: 65BD */
+
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp2host_buffer_queue_handle
 #define HIVE_MEM_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp2host_buffer_queue_handle 0x6B34
+#define HIVE_ADDR_sp2host_buffer_queue_handle 0x6B78
 #define HIVE_SIZE_sp2host_buffer_queue_handle 96
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp2host_buffer_queue_handle scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x6B34
+#define HIVE_ADDR_sp_sp2host_buffer_queue_handle 0x6B78
 #define HIVE_SIZE_sp_sp2host_buffer_queue_handle 96
 
-/* function ia_css_ispctrl_sp_init_isp_vars: 4983 */
+/* function ia_css_ispctrl_sp_init_isp_vars: 4CF6 */
 
-/* function ia_css_isys_stream_start: 5CB3 */
+/* function ia_css_isys_stream_start: 6026 */
 
-/* function sp_warning: 949 */
+/* function sp_warning: 954 */
 
-/* function ia_css_rmgr_sp_vbuf_enqueue: 5F7F */
+/* function ia_css_rmgr_sp_vbuf_enqueue: 62F2 */
 
-/* function ia_css_tagger_sp_tag_exp_id: 291A */
+/* function ia_css_tagger_sp_tag_exp_id: 2A5B */
 
-/* function ia_css_pipeline_sp_sfi_release_current_frame: 2670 */
+/* function ia_css_pipeline_sp_sfi_release_current_frame: 2752 */
 
-/* function ia_css_dmaproxy_sp_write: 37E6 */
+/* function ia_css_dmaproxy_sp_write: 3A89 */
 
-/* function ia_css_isys_stream_start_async: 5D2D */
+/* function ia_css_isys_stream_start_async: 60A0 */
 
-/* function ia_css_parambuf_sp_release_in_param: 18F0 */
+/* function ia_css_parambuf_sp_release_in_param: 1905 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_irq_sw_interrupt_token
 #define HIVE_MEM_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_irq_sw_interrupt_token 0x3DF8
+#define HIVE_ADDR_irq_sw_interrupt_token 0x3E28
 #define HIVE_SIZE_irq_sw_interrupt_token 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_irq_sw_interrupt_token scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3DF8
+#define HIVE_ADDR_sp_irq_sw_interrupt_token 0x3E28
 #define HIVE_SIZE_sp_irq_sw_interrupt_token 4
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_isp_addresses
 #define HIVE_MEM_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_addresses 0x6F84
+#define HIVE_ADDR_sp_isp_addresses 0x6FCC
 #define HIVE_SIZE_sp_isp_addresses 172
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_isp_addresses scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_isp_addresses 0x6F84
+#define HIVE_ADDR_sp_sp_isp_addresses 0x6FCC
 #define HIVE_SIZE_sp_sp_isp_addresses 172
 
-/* function ia_css_rmgr_sp_acq_gen: 5EA4 */
+/* function ia_css_rmgr_sp_acq_gen: 6217 */
 
-/* function input_system_input_port_open: 10DF */
+/* function input_system_input_port_open: 10ED */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isps
 #define HIVE_MEM_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_isps 0x7324
+#define HIVE_ADDR_isps 0x736C
 #define HIVE_SIZE_isps 28
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isps scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isps 0x7324
+#define HIVE_ADDR_sp_isps 0x736C
 #define HIVE_SIZE_sp_isps 28
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_host_sp_queues_initialized
 #define HIVE_MEM_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_host_sp_queues_initialized 0x3E10
+#define HIVE_ADDR_host_sp_queues_initialized 0x3E40
 #define HIVE_SIZE_host_sp_queues_initialized 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_host_sp_queues_initialized scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3E10
+#define HIVE_ADDR_sp_host_sp_queues_initialized 0x3E40
 #define HIVE_SIZE_sp_host_sp_queues_initialized 4
 
-/* function ia_css_queue_uninit: 50CC */
+/* function ia_css_queue_uninit: 543F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_ispctrl_sp_isp_started
 #define HIVE_MEM_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x6C3C
+#define HIVE_ADDR_ia_css_ispctrl_sp_isp_started 0x6C80
 #define HIVE_SIZE_ia_css_ispctrl_sp_isp_started 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_ispctrl_sp_isp_started scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x6C3C
+#define HIVE_ADDR_sp_ia_css_ispctrl_sp_isp_started 0x6C80
 #define HIVE_SIZE_sp_ia_css_ispctrl_sp_isp_started 4
 
-/* function ia_css_bufq_sp_release_dynamic_buf: 33BA */
+/* function ia_css_bufq_sp_release_dynamic_buf: 365D */
 
-/* function ia_css_dmaproxy_sp_set_height_exception: 38DE */
+/* function ia_css_dmaproxy_sp_set_height_exception: 3B81 */
 
-/* function ia_css_dmaproxy_sp_init_vmem_channel: 3863 */
+/* function ia_css_dmaproxy_sp_init_vmem_channel: 3B06 */
 
-/* function csi_rx_backend_stop: C49 */
+/* function csi_rx_backend_stop: C57 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_num_ready_threads
 #define HIVE_MEM_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_num_ready_threads 0x5A38
+#define HIVE_ADDR_num_ready_threads 0x5A7C
 #define HIVE_SIZE_num_ready_threads 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_num_ready_threads scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_num_ready_threads 0x5A38
+#define HIVE_ADDR_sp_num_ready_threads 0x5A7C
 #define HIVE_SIZE_sp_num_ready_threads 4
 
-/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 37B8 */
+/* function ia_css_dmaproxy_sp_write_byte_addr_mmio: 3A5B */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_vbuf_spref
 #define HIVE_MEM_vbuf_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_vbuf_spref 0x374
+#define HIVE_ADDR_vbuf_spref 0x370
 #define HIVE_SIZE_vbuf_spref 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_vbuf_spref scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_vbuf_spref 0x374
+#define HIVE_ADDR_sp_vbuf_spref 0x370
 #define HIVE_SIZE_sp_vbuf_spref 4
 
-/* function ia_css_queue_enqueue: 5016 */
+/* function ia_css_queue_enqueue: 5389 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_request
 #define HIVE_MEM_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_request 0x5AEC
+#define HIVE_ADDR_ia_css_flash_sp_request 0x5B30
 #define HIVE_SIZE_ia_css_flash_sp_request 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_request scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x5AEC
+#define HIVE_ADDR_sp_ia_css_flash_sp_request 0x5B30
 #define HIVE_SIZE_sp_ia_css_flash_sp_request 4
 
-/* function ia_css_dmaproxy_sp_vmem_write: 3789 */
+/* function ia_css_dmaproxy_sp_vmem_write: 3A2C */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_tagger_frames
 #define HIVE_MEM_tagger_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_tagger_frames 0x5A40
+#define HIVE_ADDR_tagger_frames 0x5A84
 #define HIVE_SIZE_tagger_frames 168
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_tagger_frames scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_tagger_frames 0x5A40
+#define HIVE_ADDR_sp_tagger_frames 0x5A84
 #define HIVE_SIZE_sp_tagger_frames 168
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_reading_if
 #define HIVE_MEM_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_reading_if 0x5860
+#define HIVE_ADDR_sem_for_reading_if 0x58A4
 #define HIVE_SIZE_sem_for_reading_if 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_reading_if scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_reading_if 0x5860
+#define HIVE_ADDR_sp_sem_for_reading_if 0x58A4
 #define HIVE_SIZE_sp_sem_for_reading_if 20
 
-/* function sp_generate_interrupts: 9C8 */
+/* function sp_generate_interrupts: 9D3 */
 
-/* function ia_css_pipeline_sp_start: 1F2F */
+/* function ia_css_pipeline_sp_start: 1FEE */
 
-/* function csi_rx_backend_enable: C37 */
+/* function csi_rx_backend_enable: C45 */
 
-/* function ia_css_sp_rawcopy_init: 5539 */
+/* function ia_css_sp_rawcopy_init: 58AC */
 
-/* function input_system_input_port_configure: 1131 */
+/* function input_system_input_port_configure: 113F */
 
-/* function tmr_clock_read: 16D9 */
+/* function tmr_clock_read: 16EF */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_BAMEM_BASE
@@ -1813,68 +1827,68 @@
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues
 #define HIVE_MEM_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6B94
+#define HIVE_ADDR_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6BD8
 #define HIVE_SIZE_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6B94
+#define HIVE_ADDR_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 0x6BD8
 #define HIVE_SIZE_sp_ia_css_bufq_sp_sems_for_sp2host_buf_queues 160
 
-/* function isys2401_dma_config_legacy: DD2 */
+/* function isys2401_dma_config_legacy: DE0 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ibuf_ctrl_master_ports
 #define HIVE_MEM_ibuf_ctrl_master_ports scalar_processor_2400_dmem
-#define HIVE_ADDR_ibuf_ctrl_master_ports 0x20C
+#define HIVE_ADDR_ibuf_ctrl_master_ports 0x208
 #define HIVE_SIZE_ibuf_ctrl_master_ports 12
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ibuf_ctrl_master_ports scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ibuf_ctrl_master_ports 0x20C
+#define HIVE_ADDR_sp_ibuf_ctrl_master_ports 0x208
 #define HIVE_SIZE_sp_ibuf_ctrl_master_ports 12
 
-/* function css_get_frame_processing_time_start: 27F6 */
+/* function css_get_frame_processing_time_start: 28D8 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_all_cbs_frame
 #define HIVE_MEM_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_all_cbs_frame 0x5874
+#define HIVE_ADDR_sp_all_cbs_frame 0x58B8
 #define HIVE_SIZE_sp_all_cbs_frame 16
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_all_cbs_frame scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_all_cbs_frame 0x5874
+#define HIVE_ADDR_sp_sp_all_cbs_frame 0x58B8
 #define HIVE_SIZE_sp_sp_all_cbs_frame 16
 
-/* function ia_css_virtual_isys_sp_isr: 6AE6 */
+/* function ia_css_virtual_isys_sp_isr: 6F1D */
 
-/* function thread_sp_queue_print: 141D */
+/* function thread_sp_queue_print: 142B */
 
-/* function sp_notify_eof: 974 */
+/* function sp_notify_eof: 97F */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sem_for_str2mem
 #define HIVE_MEM_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sem_for_str2mem 0x5884
+#define HIVE_ADDR_sem_for_str2mem 0x58C8
 #define HIVE_SIZE_sem_for_str2mem 20
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sem_for_str2mem scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sem_for_str2mem 0x5884
+#define HIVE_ADDR_sp_sem_for_str2mem 0x58C8
 #define HIVE_SIZE_sp_sem_for_str2mem 20
 
-/* function ia_css_tagger_buf_sp_is_marked_from_start: 31DE */
+/* function ia_css_tagger_buf_sp_is_marked_from_start: 33EE */
 
-/* function ia_css_bufq_sp_acquire_dynamic_buf: 356F */
+/* function ia_css_bufq_sp_acquire_dynamic_buf: 3812 */
 
-/* function ia_css_pipeline_sp_sfi_mode_is_enabled: 27C4 */
+/* function ia_css_pipeline_sp_sfi_mode_is_enabled: 28A6 */
 
-/* function ia_css_circbuf_destroy: 16A3 */
+/* function ia_css_circbuf_destroy: 16B9 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ISP_PMEM_BASE
@@ -1888,69 +1902,69 @@
 #define HIVE_ADDR_sp_ISP_PMEM_BASE 0xC
 #define HIVE_SIZE_sp_ISP_PMEM_BASE 4
 
-/* function ia_css_sp_isp_param_mem_load: 4BF7 */
+/* function ia_css_sp_isp_param_mem_load: 4F6A */
 
-/* function __div: 6468 */
+/* function __div: 6834 */
 
-/* function ia_css_rmgr_sp_refcount_release_vbuf: 5F9E */
+/* function ia_css_rmgr_sp_refcount_release_vbuf: 6311 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_ia_css_flash_sp_in_use
 #define HIVE_MEM_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_ia_css_flash_sp_in_use 0x5AF0
+#define HIVE_ADDR_ia_css_flash_sp_in_use 0x5B34
 #define HIVE_SIZE_ia_css_flash_sp_in_use 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_ia_css_flash_sp_in_use scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x5AF0
+#define HIVE_ADDR_sp_ia_css_flash_sp_in_use 0x5B34
 #define HIVE_SIZE_sp_ia_css_flash_sp_in_use 4
 
-/* function ia_css_thread_sem_sp_wait: 672E */
+/* function ia_css_thread_sem_sp_wait: 6AFA */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_sleep_mode
 #define HIVE_MEM_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sleep_mode 0x3E14
+#define HIVE_ADDR_sp_sleep_mode 0x3E44
 #define HIVE_SIZE_sp_sleep_mode 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_sleep_mode scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_sleep_mode 0x3E14
+#define HIVE_ADDR_sp_sp_sleep_mode 0x3E44
 #define HIVE_SIZE_sp_sp_sleep_mode 4
 
-/* function ia_css_tagger_buf_sp_push: 30F7 */
+/* function ia_css_tagger_buf_sp_push: 32E9 */
 
 /* function mmu_invalidate_cache: D3 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_sp_max_cb_elems
 #define HIVE_MEM_sp_max_cb_elems scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_max_cb_elems 0x14C
+#define HIVE_ADDR_sp_max_cb_elems 0x148
 #define HIVE_SIZE_sp_max_cb_elems 8
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_sp_max_cb_elems scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_sp_max_cb_elems 0x14C
+#define HIVE_ADDR_sp_sp_max_cb_elems 0x148
 #define HIVE_SIZE_sp_sp_max_cb_elems 8
 
-/* function ia_css_queue_remote_init: 50EE */
+/* function ia_css_queue_remote_init: 5461 */
 
 #ifndef HIVE_MULTIPLE_PROGRAMS
 #ifndef HIVE_MEM_isp_stop_req
 #define HIVE_MEM_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_isp_stop_req 0x5718
+#define HIVE_ADDR_isp_stop_req 0x575C
 #define HIVE_SIZE_isp_stop_req 4
 #else
 #endif
 #endif
 #define HIVE_MEM_sp_isp_stop_req scalar_processor_2400_dmem
-#define HIVE_ADDR_sp_isp_stop_req 0x5718
+#define HIVE_ADDR_sp_isp_stop_req 0x575C
 #define HIVE_SIZE_sp_isp_stop_req 4
 
-/* function ia_css_pipeline_sp_sfi_request_next_frame: 2686 */
+/* function ia_css_pipeline_sp_sfi_request_next_frame: 2768 */
 
 #define HIVE_ICACHE_sp_critical_SEGMENT_START 0
 #define HIVE_ICACHE_sp_critical_NUM_SEGMENTS  1
-- 
1.9.1

